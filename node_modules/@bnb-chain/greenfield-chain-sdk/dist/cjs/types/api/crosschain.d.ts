import { QueryParamsResponse } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/query';
import { QueryCrossChainPackageResponse, QueryReceiveSequenceResponse, QuerySendSequenceResponse } from '@bnb-chain/greenfield-cosmos-types/cosmos/crosschain/v1/query';
import { QueryInturnRelayerResponse } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/query';
import { MsgClaim } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/tx';
import { MsgTransferOut } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/tx';
import { MsgMirrorBucket, MsgMirrorGroup, MsgMirrorObject } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/tx';
import { ITxOption, SimulateOrBroad, SimulateOrBroadResponse } from '..';
import { Account } from './account';
export interface ICrossChain {
    /**
     * makes a transfer from Greenfield to BSC
     */
    transferOut<T extends ITxOption>(msg: MsgTransferOut, txOption: T): Promise<SimulateOrBroad<T>>;
    transferOut(msg: MsgTransferOut, txOption: ITxOption): Promise<SimulateOrBroadResponse>;
    /**
     * cross-chain packages from BSC to Greenfield, used by relayers which run by validators
     */
    claims<T extends ITxOption>(msg: MsgClaim, txOption: T): Promise<SimulateOrBroad<T>>;
    claims(msg: MsgClaim, txOption: ITxOption): Promise<SimulateOrBroadResponse>;
    /**
     * gets the next send sequence for a channel
     */
    getChannelSendSequence(channelId: number): Promise<QuerySendSequenceResponse>;
    /**
     * gets the next receive sequence for a channel
     */
    getChannelReceiveSequence(channelId: number): Promise<QueryReceiveSequenceResponse>;
    /**
     * gets the in-turn relayer bls public key and its relay interval
     */
    getInturnRelayer(): Promise<QueryInturnRelayerResponse>;
    getCrosschainPackage(channelId: number, sequence: number): Promise<QueryCrossChainPackageResponse>;
    /**
     * mirrors the group to BSC as NFT
     */
    mirrorGroup<T extends ITxOption>(msg: MsgMirrorGroup, txOption: T): Promise<SimulateOrBroad<T>>;
    mirrorGroup(msg: MsgMirrorGroup, txOption: ITxOption): Promise<SimulateOrBroadResponse>;
    /**
     * mirrors the bucket to BSC as NFT
     */
    mirrorBucket<T extends ITxOption>(msg: MsgMirrorBucket, txOption: T): Promise<SimulateOrBroad<T>>;
    mirrorBucket(msg: MsgMirrorBucket, txOption: ITxOption): Promise<SimulateOrBroadResponse>;
    /**
     * mirrors the object to BSC as NFT
     */
    mirrorObject<T extends ITxOption>(msg: MsgMirrorObject, txOption: T): Promise<SimulateOrBroad<T>>;
    mirrorObject(msg: MsgMirrorObject, txOption: ITxOption): Promise<SimulateOrBroadResponse>;
    getParams(): Promise<QueryParamsResponse>;
}
export declare class CrossChain extends Account implements ICrossChain {
    transferOut(msg: MsgTransferOut, txOption: ITxOption): Promise<any>;
    claims(msg: MsgClaim, txOption: ITxOption): Promise<any>;
    getChannelSendSequence(channelId: number): Promise<QuerySendSequenceResponse>;
    getChannelReceiveSequence(channelId: number): Promise<QueryReceiveSequenceResponse>;
    getInturnRelayer(): Promise<QueryInturnRelayerResponse>;
    getCrosschainPackage(channelId: number, sequence: number): Promise<QueryCrossChainPackageResponse>;
    mirrorGroup(msg: MsgMirrorGroup, txOption: ITxOption): Promise<any>;
    mirrorBucket(msg: MsgMirrorBucket, txOption: ITxOption): Promise<any>;
    mirrorObject(msg: MsgMirrorObject, txOption: ITxOption): Promise<any>;
    getParams(): Promise<QueryParamsResponse>;
}
