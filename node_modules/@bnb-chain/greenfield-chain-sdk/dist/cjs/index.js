'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Long$1 = require('long');
var units = require('@ethersproject/units');
var protoSigning = require('@cosmjs/proto-signing');
var stargate = require('@cosmjs/stargate');
var util = require('@ethereumjs/util');
var ethSigUtil = require('@metamask/eth-sig-util');
var signingKey = require('@ethersproject/signing-key');
var tendermintRpc = require('@cosmjs/tendermint-rpc');
var greenfiledFileHandle = require('@bnb-chain/greenfiled-file-handle');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
        e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
            if (k !== 'default' && !(k in n)) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    });
    return Object.freeze(n);
}

var Long__default = /*#__PURE__*/_interopDefaultLegacy(Long$1);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const MsgSendTypeUrl = '/cosmos.bank.v1beta1.MsgSend';
const MsgSendSDKTypeEIP712$1 = {
    Msg: [
        { name: 'type', type: 'string' },
        { name: 'from_address', type: 'string' },
        { name: 'to_address', type: 'string' },
        { name: 'amount', type: 'TypeAmount[]' },
    ],
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var auth = {};

var any = {};

var minimal$1 = {exports: {}};

var indexMinimal = {};

var writer = {exports: {}};

var minimal = {};

var aspromise = {exports: {}};

(function (module) {
	module.exports = asPromise;

	/**
	 * Callback as used by {@link util.asPromise}.
	 * @typedef asPromiseCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {...*} params Additional arguments
	 * @returns {undefined}
	 */

	/**
	 * Returns a promise from a node-style callback function.
	 * @memberof util
	 * @param {asPromiseCallback} fn Function to call
	 * @param {*} ctx Function context
	 * @param {...*} params Function arguments
	 * @returns {Promise<*>} Promisified function
	 */
	function asPromise(fn, ctx/*, varargs */) {
	    var params  = new Array(arguments.length - 1),
	        offset  = 0,
	        index   = 2,
	        pending = true;
	    while (index < arguments.length)
	        params[offset++] = arguments[index++];
	    return new Promise(function executor(resolve, reject) {
	        params[offset] = function callback(err/*, varargs */) {
	            if (pending) {
	                pending = false;
	                if (err)
	                    reject(err);
	                else {
	                    var params = new Array(arguments.length - 1),
	                        offset = 0;
	                    while (offset < params.length)
	                        params[offset++] = arguments[offset];
	                    resolve.apply(null, params);
	                }
	            }
	        };
	        try {
	            fn.apply(ctx || null, params);
	        } catch (err) {
	            if (pending) {
	                pending = false;
	                reject(err);
	            }
	        }
	    });
	}
} (aspromise));

aspromise.exports.default;

var base64 = {};

(function (exports) {

	/**
	 * A minimal base64 implementation for number arrays.
	 * @memberof util
	 * @namespace
	 */
	var base64 = exports;

	/**
	 * Calculates the byte length of a base64 encoded string.
	 * @param {string} string Base64 encoded string
	 * @returns {number} Byte length
	 */
	base64.length = function length(string) {
	    var p = string.length;
	    if (!p)
	        return 0;
	    var n = 0;
	    while (--p % 4 > 1 && string.charAt(p) === "=")
	        ++n;
	    return Math.ceil(string.length * 3) / 4 - n;
	};

	// Base64 encoding table
	var b64 = new Array(64);

	// Base64 decoding table
	var s64 = new Array(123);

	// 65..90, 97..122, 48..57, 43, 47
	for (var i = 0; i < 64;)
	    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

	/**
	 * Encodes a buffer to a base64 encoded string.
	 * @param {Uint8Array} buffer Source buffer
	 * @param {number} start Source start
	 * @param {number} end Source end
	 * @returns {string} Base64 encoded string
	 */
	base64.encode = function encode(buffer, start, end) {
	    var parts = null,
	        chunk = [];
	    var i = 0, // output index
	        j = 0, // goto index
	        t;     // temporary
	    while (start < end) {
	        var b = buffer[start++];
	        switch (j) {
	            case 0:
	                chunk[i++] = b64[b >> 2];
	                t = (b & 3) << 4;
	                j = 1;
	                break;
	            case 1:
	                chunk[i++] = b64[t | b >> 4];
	                t = (b & 15) << 2;
	                j = 2;
	                break;
	            case 2:
	                chunk[i++] = b64[t | b >> 6];
	                chunk[i++] = b64[b & 63];
	                j = 0;
	                break;
	        }
	        if (i > 8191) {
	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
	            i = 0;
	        }
	    }
	    if (j) {
	        chunk[i++] = b64[t];
	        chunk[i++] = 61;
	        if (j === 1)
	            chunk[i++] = 61;
	    }
	    if (parts) {
	        if (i)
	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
	        return parts.join("");
	    }
	    return String.fromCharCode.apply(String, chunk.slice(0, i));
	};

	var invalidEncoding = "invalid encoding";

	/**
	 * Decodes a base64 encoded string to a buffer.
	 * @param {string} string Source string
	 * @param {Uint8Array} buffer Destination buffer
	 * @param {number} offset Destination offset
	 * @returns {number} Number of bytes written
	 * @throws {Error} If encoding is invalid
	 */
	base64.decode = function decode(string, buffer, offset) {
	    var start = offset;
	    var j = 0, // goto index
	        t;     // temporary
	    for (var i = 0; i < string.length;) {
	        var c = string.charCodeAt(i++);
	        if (c === 61 && j > 1)
	            break;
	        if ((c = s64[c]) === undefined)
	            throw Error(invalidEncoding);
	        switch (j) {
	            case 0:
	                t = c;
	                j = 1;
	                break;
	            case 1:
	                buffer[offset++] = t << 2 | (c & 48) >> 4;
	                t = c;
	                j = 2;
	                break;
	            case 2:
	                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
	                t = c;
	                j = 3;
	                break;
	            case 3:
	                buffer[offset++] = (t & 3) << 6 | c;
	                j = 0;
	                break;
	        }
	    }
	    if (j === 1)
	        throw Error(invalidEncoding);
	    return offset - start;
	};

	/**
	 * Tests if the specified string appears to be base64 encoded.
	 * @param {string} string String to test
	 * @returns {boolean} `true` if probably base64 encoded, otherwise false
	 */
	base64.test = function test(string) {
	    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
	};
} (base64));

base64.default;

var eventemitter = {exports: {}};

(function (module) {
	module.exports = EventEmitter;

	/**
	 * Constructs a new event emitter instance.
	 * @classdesc A minimal event emitter.
	 * @memberof util
	 * @constructor
	 */
	function EventEmitter() {

	    /**
	     * Registered listeners.
	     * @type {Object.<string,*>}
	     * @private
	     */
	    this._listeners = {};
	}

	/**
	 * Registers an event listener.
	 * @param {string} evt Event name
	 * @param {function} fn Listener
	 * @param {*} [ctx] Listener context
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.on = function on(evt, fn, ctx) {
	    (this._listeners[evt] || (this._listeners[evt] = [])).push({
	        fn  : fn,
	        ctx : ctx || this
	    });
	    return this;
	};

	/**
	 * Removes an event listener or any matching listeners if arguments are omitted.
	 * @param {string} [evt] Event name. Removes all listeners if omitted.
	 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.off = function off(evt, fn) {
	    if (evt === undefined)
	        this._listeners = {};
	    else {
	        if (fn === undefined)
	            this._listeners[evt] = [];
	        else {
	            var listeners = this._listeners[evt];
	            for (var i = 0; i < listeners.length;)
	                if (listeners[i].fn === fn)
	                    listeners.splice(i, 1);
	                else
	                    ++i;
	        }
	    }
	    return this;
	};

	/**
	 * Emits an event by calling its listeners with the specified arguments.
	 * @param {string} evt Event name
	 * @param {...*} args Arguments
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.emit = function emit(evt) {
	    var listeners = this._listeners[evt];
	    if (listeners) {
	        var args = [],
	            i = 1;
	        for (; i < arguments.length;)
	            args.push(arguments[i++]);
	        for (i = 0; i < listeners.length;)
	            listeners[i].fn.apply(listeners[i++].ctx, args);
	    }
	    return this;
	};
} (eventemitter));

eventemitter.exports.default;

var float = {exports: {}};

(function (module) {

	module.exports = factory(factory);

	/**
	 * Reads / writes floats / doubles from / to buffers.
	 * @name util.float
	 * @namespace
	 */

	/**
	 * Writes a 32 bit float to a buffer using little endian byte order.
	 * @name util.float.writeFloatLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 32 bit float to a buffer using big endian byte order.
	 * @name util.float.writeFloatBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 32 bit float from a buffer using little endian byte order.
	 * @name util.float.readFloatLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 32 bit float from a buffer using big endian byte order.
	 * @name util.float.readFloatBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Writes a 64 bit double to a buffer using little endian byte order.
	 * @name util.float.writeDoubleLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 64 bit double to a buffer using big endian byte order.
	 * @name util.float.writeDoubleBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 64 bit double from a buffer using little endian byte order.
	 * @name util.float.readDoubleLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 64 bit double from a buffer using big endian byte order.
	 * @name util.float.readDoubleBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	// Factory function for the purpose of node-based testing in modified global environments
	function factory(exports) {

	    // float: typed array
	    if (typeof Float32Array !== "undefined") (function() {

	        var f32 = new Float32Array([ -0 ]),
	            f8b = new Uint8Array(f32.buffer),
	            le  = f8b[3] === 128;

	        function writeFloat_f32_cpy(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	        }

	        function writeFloat_f32_rev(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[3];
	            buf[pos + 1] = f8b[2];
	            buf[pos + 2] = f8b[1];
	            buf[pos + 3] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

	        function readFloat_f32_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            return f32[0];
	        }

	        function readFloat_f32_rev(buf, pos) {
	            f8b[3] = buf[pos    ];
	            f8b[2] = buf[pos + 1];
	            f8b[1] = buf[pos + 2];
	            f8b[0] = buf[pos + 3];
	            return f32[0];
	        }

	        /* istanbul ignore next */
	        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

	    // float: ieee754
	    })(); else (function() {

	        function writeFloat_ieee754(writeUint, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0)
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
	            else if (isNaN(val))
	                writeUint(2143289344, buf, pos);
	            else if (val > 3.4028234663852886e+38) // +-Infinity
	                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
	            else if (val < 1.1754943508222875e-38) // denormal
	                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
	            else {
	                var exponent = Math.floor(Math.log(val) / Math.LN2),
	                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
	                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
	            }
	        }

	        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
	        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

	        function readFloat_ieee754(readUint, buf, pos) {
	            var uint = readUint(buf, pos),
	                sign = (uint >> 31) * 2 + 1,
	                exponent = uint >>> 23 & 255,
	                mantissa = uint & 8388607;
	            return exponent === 255
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 1.401298464324817e-45 * mantissa
	                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
	        }

	        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
	        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

	    })();

	    // double: typed array
	    if (typeof Float64Array !== "undefined") (function() {

	        var f64 = new Float64Array([-0]),
	            f8b = new Uint8Array(f64.buffer),
	            le  = f8b[7] === 128;

	        function writeDouble_f64_cpy(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	            buf[pos + 4] = f8b[4];
	            buf[pos + 5] = f8b[5];
	            buf[pos + 6] = f8b[6];
	            buf[pos + 7] = f8b[7];
	        }

	        function writeDouble_f64_rev(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[7];
	            buf[pos + 1] = f8b[6];
	            buf[pos + 2] = f8b[5];
	            buf[pos + 3] = f8b[4];
	            buf[pos + 4] = f8b[3];
	            buf[pos + 5] = f8b[2];
	            buf[pos + 6] = f8b[1];
	            buf[pos + 7] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

	        function readDouble_f64_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            f8b[4] = buf[pos + 4];
	            f8b[5] = buf[pos + 5];
	            f8b[6] = buf[pos + 6];
	            f8b[7] = buf[pos + 7];
	            return f64[0];
	        }

	        function readDouble_f64_rev(buf, pos) {
	            f8b[7] = buf[pos    ];
	            f8b[6] = buf[pos + 1];
	            f8b[5] = buf[pos + 2];
	            f8b[4] = buf[pos + 3];
	            f8b[3] = buf[pos + 4];
	            f8b[2] = buf[pos + 5];
	            f8b[1] = buf[pos + 6];
	            f8b[0] = buf[pos + 7];
	            return f64[0];
	        }

	        /* istanbul ignore next */
	        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

	    // double: ieee754
	    })(); else (function() {

	        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0) {
	                writeUint(0, buf, pos + off0);
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
	            } else if (isNaN(val)) {
	                writeUint(0, buf, pos + off0);
	                writeUint(2146959360, buf, pos + off1);
	            } else if (val > 1.7976931348623157e+308) { // +-Infinity
	                writeUint(0, buf, pos + off0);
	                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
	            } else {
	                var mantissa;
	                if (val < 2.2250738585072014e-308) { // denormal
	                    mantissa = val / 5e-324;
	                    writeUint(mantissa >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
	                } else {
	                    var exponent = Math.floor(Math.log(val) / Math.LN2);
	                    if (exponent === 1024)
	                        exponent = 1023;
	                    mantissa = val * Math.pow(2, -exponent);
	                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
	                }
	            }
	        }

	        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
	        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

	        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
	            var lo = readUint(buf, pos + off0),
	                hi = readUint(buf, pos + off1);
	            var sign = (hi >> 31) * 2 + 1,
	                exponent = hi >>> 20 & 2047,
	                mantissa = 4294967296 * (hi & 1048575) + lo;
	            return exponent === 2047
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 5e-324 * mantissa
	                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
	        }

	        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
	        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

	    })();

	    return exports;
	}

	// uint helpers

	function writeUintLE(val, buf, pos) {
	    buf[pos    ] =  val        & 255;
	    buf[pos + 1] =  val >>> 8  & 255;
	    buf[pos + 2] =  val >>> 16 & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	function writeUintBE(val, buf, pos) {
	    buf[pos    ] =  val >>> 24;
	    buf[pos + 1] =  val >>> 16 & 255;
	    buf[pos + 2] =  val >>> 8  & 255;
	    buf[pos + 3] =  val        & 255;
	}

	function readUintLE(buf, pos) {
	    return (buf[pos    ]
	          | buf[pos + 1] << 8
	          | buf[pos + 2] << 16
	          | buf[pos + 3] << 24) >>> 0;
	}

	function readUintBE(buf, pos) {
	    return (buf[pos    ] << 24
	          | buf[pos + 1] << 16
	          | buf[pos + 2] << 8
	          | buf[pos + 3]) >>> 0;
	}
} (float));

float.exports.default;

var inquire = {exports: {}};

(function (module) {
	module.exports = inquire;

	/**
	 * Requires a module only if available.
	 * @memberof util
	 * @param {string} moduleName Module to require
	 * @returns {?Object} Required module if available and not empty, otherwise `null`
	 */
	function inquire(moduleName) {
	    try {
	        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
	        if (mod && (mod.length || Object.keys(mod).length))
	            return mod;
	    } catch (e) {} // eslint-disable-line no-empty
	    return null;
	}
} (inquire));

inquire.exports.default;

var utf8 = {};

(function (exports) {

	/**
	 * A minimal UTF8 implementation for number arrays.
	 * @memberof util
	 * @namespace
	 */
	var utf8 = exports;

	/**
	 * Calculates the UTF8 byte length of a string.
	 * @param {string} string String
	 * @returns {number} Byte length
	 */
	utf8.length = function utf8_length(string) {
	    var len = 0,
	        c = 0;
	    for (var i = 0; i < string.length; ++i) {
	        c = string.charCodeAt(i);
	        if (c < 128)
	            len += 1;
	        else if (c < 2048)
	            len += 2;
	        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
	            ++i;
	            len += 4;
	        } else
	            len += 3;
	    }
	    return len;
	};

	/**
	 * Reads UTF8 bytes as a string.
	 * @param {Uint8Array} buffer Source buffer
	 * @param {number} start Source start
	 * @param {number} end Source end
	 * @returns {string} String read
	 */
	utf8.read = function utf8_read(buffer, start, end) {
	    var len = end - start;
	    if (len < 1)
	        return "";
	    var parts = null,
	        chunk = [],
	        i = 0, // char offset
	        t;     // temporary
	    while (start < end) {
	        t = buffer[start++];
	        if (t < 128)
	            chunk[i++] = t;
	        else if (t > 191 && t < 224)
	            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
	        else if (t > 239 && t < 365) {
	            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
	            chunk[i++] = 0xD800 + (t >> 10);
	            chunk[i++] = 0xDC00 + (t & 1023);
	        } else
	            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
	        if (i > 8191) {
	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
	            i = 0;
	        }
	    }
	    if (parts) {
	        if (i)
	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
	        return parts.join("");
	    }
	    return String.fromCharCode.apply(String, chunk.slice(0, i));
	};

	/**
	 * Writes a string as UTF8 bytes.
	 * @param {string} string Source string
	 * @param {Uint8Array} buffer Destination buffer
	 * @param {number} offset Destination offset
	 * @returns {number} Bytes written
	 */
	utf8.write = function utf8_write(string, buffer, offset) {
	    var start = offset,
	        c1, // character 1
	        c2; // character 2
	    for (var i = 0; i < string.length; ++i) {
	        c1 = string.charCodeAt(i);
	        if (c1 < 128) {
	            buffer[offset++] = c1;
	        } else if (c1 < 2048) {
	            buffer[offset++] = c1 >> 6       | 192;
	            buffer[offset++] = c1       & 63 | 128;
	        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
	            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
	            ++i;
	            buffer[offset++] = c1 >> 18      | 240;
	            buffer[offset++] = c1 >> 12 & 63 | 128;
	            buffer[offset++] = c1 >> 6  & 63 | 128;
	            buffer[offset++] = c1       & 63 | 128;
	        } else {
	            buffer[offset++] = c1 >> 12      | 224;
	            buffer[offset++] = c1 >> 6  & 63 | 128;
	            buffer[offset++] = c1       & 63 | 128;
	        }
	    }
	    return offset - start;
	};
} (utf8));

utf8.default;

var pool = {exports: {}};

(function (module) {
	module.exports = pool;

	/**
	 * An allocator as used by {@link util.pool}.
	 * @typedef PoolAllocator
	 * @type {function}
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */

	/**
	 * A slicer as used by {@link util.pool}.
	 * @typedef PoolSlicer
	 * @type {function}
	 * @param {number} start Start offset
	 * @param {number} end End offset
	 * @returns {Uint8Array} Buffer slice
	 * @this {Uint8Array}
	 */

	/**
	 * A general purpose buffer pool.
	 * @memberof util
	 * @function
	 * @param {PoolAllocator} alloc Allocator
	 * @param {PoolSlicer} slice Slicer
	 * @param {number} [size=8192] Slab size
	 * @returns {PoolAllocator} Pooled allocator
	 */
	function pool(alloc, slice, size) {
	    var SIZE   = size || 8192;
	    var MAX    = SIZE >>> 1;
	    var slab   = null;
	    var offset = SIZE;
	    return function pool_alloc(size) {
	        if (size < 1 || size > MAX)
	            return alloc(size);
	        if (offset + size > SIZE) {
	            slab = alloc(SIZE);
	            offset = 0;
	        }
	        var buf = slice.call(slab, offset, offset += size);
	        if (offset & 7) // align to 32 bit
	            offset = (offset | 7) + 1;
	        return buf;
	    };
	}
} (pool));

pool.exports.default;

var longbits = {exports: {}};

var hasRequiredLongbits;

function requireLongbits () {
	if (hasRequiredLongbits) return longbits.exports;
	hasRequiredLongbits = 1;
	(function (module) {
		module.exports = LongBits;

		var util = requireMinimal();

		/**
		 * Constructs new long bits.
		 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
		 * @memberof util
		 * @constructor
		 * @param {number} lo Low 32 bits, unsigned
		 * @param {number} hi High 32 bits, unsigned
		 */
		function LongBits(lo, hi) {

		    // note that the casts below are theoretically unnecessary as of today, but older statically
		    // generated converter code might still call the ctor with signed 32bits. kept for compat.

		    /**
		     * Low bits.
		     * @type {number}
		     */
		    this.lo = lo >>> 0;

		    /**
		     * High bits.
		     * @type {number}
		     */
		    this.hi = hi >>> 0;
		}

		/**
		 * Zero bits.
		 * @memberof util.LongBits
		 * @type {util.LongBits}
		 */
		var zero = LongBits.zero = new LongBits(0, 0);

		zero.toNumber = function() { return 0; };
		zero.zzEncode = zero.zzDecode = function() { return this; };
		zero.length = function() { return 1; };

		/**
		 * Zero hash.
		 * @memberof util.LongBits
		 * @type {string}
		 */
		var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

		/**
		 * Constructs new long bits from the specified number.
		 * @param {number} value Value
		 * @returns {util.LongBits} Instance
		 */
		LongBits.fromNumber = function fromNumber(value) {
		    if (value === 0)
		        return zero;
		    var sign = value < 0;
		    if (sign)
		        value = -value;
		    var lo = value >>> 0,
		        hi = (value - lo) / 4294967296 >>> 0;
		    if (sign) {
		        hi = ~hi >>> 0;
		        lo = ~lo >>> 0;
		        if (++lo > 4294967295) {
		            lo = 0;
		            if (++hi > 4294967295)
		                hi = 0;
		        }
		    }
		    return new LongBits(lo, hi);
		};

		/**
		 * Constructs new long bits from a number, long or string.
		 * @param {Long|number|string} value Value
		 * @returns {util.LongBits} Instance
		 */
		LongBits.from = function from(value) {
		    if (typeof value === "number")
		        return LongBits.fromNumber(value);
		    if (util.isString(value)) {
		        /* istanbul ignore else */
		        if (util.Long)
		            value = util.Long.fromString(value);
		        else
		            return LongBits.fromNumber(parseInt(value, 10));
		    }
		    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
		};

		/**
		 * Converts this long bits to a possibly unsafe JavaScript number.
		 * @param {boolean} [unsigned=false] Whether unsigned or not
		 * @returns {number} Possibly unsafe number
		 */
		LongBits.prototype.toNumber = function toNumber(unsigned) {
		    if (!unsigned && this.hi >>> 31) {
		        var lo = ~this.lo + 1 >>> 0,
		            hi = ~this.hi     >>> 0;
		        if (!lo)
		            hi = hi + 1 >>> 0;
		        return -(lo + hi * 4294967296);
		    }
		    return this.lo + this.hi * 4294967296;
		};

		/**
		 * Converts this long bits to a long.
		 * @param {boolean} [unsigned=false] Whether unsigned or not
		 * @returns {Long} Long
		 */
		LongBits.prototype.toLong = function toLong(unsigned) {
		    return util.Long
		        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
		        /* istanbul ignore next */
		        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
		};

		var charCodeAt = String.prototype.charCodeAt;

		/**
		 * Constructs new long bits from the specified 8 characters long hash.
		 * @param {string} hash Hash
		 * @returns {util.LongBits} Bits
		 */
		LongBits.fromHash = function fromHash(hash) {
		    if (hash === zeroHash)
		        return zero;
		    return new LongBits(
		        ( charCodeAt.call(hash, 0)
		        | charCodeAt.call(hash, 1) << 8
		        | charCodeAt.call(hash, 2) << 16
		        | charCodeAt.call(hash, 3) << 24) >>> 0
		    ,
		        ( charCodeAt.call(hash, 4)
		        | charCodeAt.call(hash, 5) << 8
		        | charCodeAt.call(hash, 6) << 16
		        | charCodeAt.call(hash, 7) << 24) >>> 0
		    );
		};

		/**
		 * Converts this long bits to a 8 characters long hash.
		 * @returns {string} Hash
		 */
		LongBits.prototype.toHash = function toHash() {
		    return String.fromCharCode(
		        this.lo        & 255,
		        this.lo >>> 8  & 255,
		        this.lo >>> 16 & 255,
		        this.lo >>> 24      ,
		        this.hi        & 255,
		        this.hi >>> 8  & 255,
		        this.hi >>> 16 & 255,
		        this.hi >>> 24
		    );
		};

		/**
		 * Zig-zag encodes this long bits.
		 * @returns {util.LongBits} `this`
		 */
		LongBits.prototype.zzEncode = function zzEncode() {
		    var mask =   this.hi >> 31;
		    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
		    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
		    return this;
		};

		/**
		 * Zig-zag decodes this long bits.
		 * @returns {util.LongBits} `this`
		 */
		LongBits.prototype.zzDecode = function zzDecode() {
		    var mask = -(this.lo & 1);
		    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
		    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
		    return this;
		};

		/**
		 * Calculates the length of this longbits when encoded as a varint.
		 * @returns {number} Length
		 */
		LongBits.prototype.length = function length() {
		    var part0 =  this.lo,
		        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
		        part2 =  this.hi >>> 24;
		    return part2 === 0
		         ? part1 === 0
		           ? part0 < 16384
		             ? part0 < 128 ? 1 : 2
		             : part0 < 2097152 ? 3 : 4
		           : part1 < 16384
		             ? part1 < 128 ? 5 : 6
		             : part1 < 2097152 ? 7 : 8
		         : part2 < 128 ? 9 : 10;
		};
} (longbits));
	return longbits.exports;
}

var hasRequiredMinimal;

function requireMinimal () {
	if (hasRequiredMinimal) return minimal;
	hasRequiredMinimal = 1;
	(function (exports) {
		var util = exports;

		// used to return a Promise where callback is omitted
		util.asPromise = aspromise.exports;

		// converts to / from base64 encoded strings
		util.base64 = base64;

		// base class of rpc.Service
		util.EventEmitter = eventemitter.exports;

		// float handling accross browsers
		util.float = float.exports;

		// requires modules optionally and hides the call from bundlers
		util.inquire = inquire.exports;

		// converts to / from utf8 encoded strings
		util.utf8 = utf8;

		// provides a node-like buffer pool in the browser
		util.pool = pool.exports;

		// utility to work with the low and high bits of a 64 bit value
		util.LongBits = requireLongbits();

		/**
		 * Whether running within node or not.
		 * @memberof util
		 * @type {boolean}
		 */
		util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
		                   && commonjsGlobal
		                   && commonjsGlobal.process
		                   && commonjsGlobal.process.versions
		                   && commonjsGlobal.process.versions.node);

		/**
		 * Global object reference.
		 * @memberof util
		 * @type {Object}
		 */
		util.global = util.isNode && commonjsGlobal
		           || typeof window !== "undefined" && window
		           || typeof self   !== "undefined" && self
		           || commonjsGlobal; // eslint-disable-line no-invalid-this

		/**
		 * An immuable empty array.
		 * @memberof util
		 * @type {Array.<*>}
		 * @const
		 */
		util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

		/**
		 * An immutable empty object.
		 * @type {Object}
		 * @const
		 */
		util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

		/**
		 * Tests if the specified value is an integer.
		 * @function
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is an integer
		 */
		util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
		    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
		};

		/**
		 * Tests if the specified value is a string.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a string
		 */
		util.isString = function isString(value) {
		    return typeof value === "string" || value instanceof String;
		};

		/**
		 * Tests if the specified value is a non-null object.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a non-null object
		 */
		util.isObject = function isObject(value) {
		    return value && typeof value === "object";
		};

		/**
		 * Checks if a property on a message is considered to be present.
		 * This is an alias of {@link util.isSet}.
		 * @function
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isset =

		/**
		 * Checks if a property on a message is considered to be present.
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isSet = function isSet(obj, prop) {
		    var value = obj[prop];
		    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
		        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
		    return false;
		};

		/**
		 * Any compatible Buffer instance.
		 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
		 * @interface Buffer
		 * @extends Uint8Array
		 */

		/**
		 * Node's Buffer class if available.
		 * @type {Constructor<Buffer>}
		 */
		util.Buffer = (function() {
		    try {
		        var Buffer = util.inquire("buffer").Buffer;
		        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
		        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
		    } catch (e) {
		        /* istanbul ignore next */
		        return null;
		    }
		})();

		// Internal alias of or polyfull for Buffer.from.
		util._Buffer_from = null;

		// Internal alias of or polyfill for Buffer.allocUnsafe.
		util._Buffer_allocUnsafe = null;

		/**
		 * Creates a new buffer of whatever type supported by the environment.
		 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
		 * @returns {Uint8Array|Buffer} Buffer
		 */
		util.newBuffer = function newBuffer(sizeOrArray) {
		    /* istanbul ignore next */
		    return typeof sizeOrArray === "number"
		        ? util.Buffer
		            ? util._Buffer_allocUnsafe(sizeOrArray)
		            : new util.Array(sizeOrArray)
		        : util.Buffer
		            ? util._Buffer_from(sizeOrArray)
		            : typeof Uint8Array === "undefined"
		                ? sizeOrArray
		                : new Uint8Array(sizeOrArray);
		};

		/**
		 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
		 * @type {Constructor<Uint8Array>}
		 */
		util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

		/**
		 * Any compatible Long instance.
		 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
		 * @interface Long
		 * @property {number} low Low bits
		 * @property {number} high High bits
		 * @property {boolean} unsigned Whether unsigned or not
		 */

		/**
		 * Long.js's Long class if available.
		 * @type {Constructor<Long>}
		 */
		util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
		         || /* istanbul ignore next */ util.global.Long
		         || util.inquire("long");

		/**
		 * Regular expression used to verify 2 bit (`bool`) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key2Re = /^true|false|0|1$/;

		/**
		 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

		/**
		 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

		/**
		 * Converts a number or long to an 8 characters long hash string.
		 * @param {Long|number} value Value to convert
		 * @returns {string} Hash
		 */
		util.longToHash = function longToHash(value) {
		    return value
		        ? util.LongBits.from(value).toHash()
		        : util.LongBits.zeroHash;
		};

		/**
		 * Converts an 8 characters long hash string to a long or number.
		 * @param {string} hash Hash
		 * @param {boolean} [unsigned=false] Whether unsigned or not
		 * @returns {Long|number} Original value
		 */
		util.longFromHash = function longFromHash(hash, unsigned) {
		    var bits = util.LongBits.fromHash(hash);
		    if (util.Long)
		        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
		    return bits.toNumber(Boolean(unsigned));
		};

		/**
		 * Merges the properties of the source object into the destination object.
		 * @memberof util
		 * @param {Object.<string,*>} dst Destination object
		 * @param {Object.<string,*>} src Source object
		 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
		 * @returns {Object.<string,*>} Destination object
		 */
		function merge(dst, src, ifNotSet) { // used by converters
		    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
		        if (dst[keys[i]] === undefined || !ifNotSet)
		            dst[keys[i]] = src[keys[i]];
		    return dst;
		}

		util.merge = merge;

		/**
		 * Converts the first character of a string to lower case.
		 * @param {string} str String to convert
		 * @returns {string} Converted string
		 */
		util.lcFirst = function lcFirst(str) {
		    return str.charAt(0).toLowerCase() + str.substring(1);
		};

		/**
		 * Creates a custom error constructor.
		 * @memberof util
		 * @param {string} name Error name
		 * @returns {Constructor<Error>} Custom error constructor
		 */
		function newError(name) {

		    function CustomError(message, properties) {

		        if (!(this instanceof CustomError))
		            return new CustomError(message, properties);

		        // Error.call(this, message);
		        // ^ just returns a new error instance because the ctor can be called as a function

		        Object.defineProperty(this, "message", { get: function() { return message; } });

		        /* istanbul ignore next */
		        if (Error.captureStackTrace) // node
		            Error.captureStackTrace(this, CustomError);
		        else
		            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

		        if (properties)
		            merge(this, properties);
		    }

		    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

		    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

		    CustomError.prototype.toString = function toString() {
		        return this.name + ": " + this.message;
		    };

		    return CustomError;
		}

		util.newError = newError;

		/**
		 * Constructs a new protocol error.
		 * @classdesc Error subclass indicating a protocol specifc error.
		 * @memberof util
		 * @extends Error
		 * @template T extends Message<T>
		 * @constructor
		 * @param {string} message Error message
		 * @param {Object.<string,*>} [properties] Additional properties
		 * @example
		 * try {
		 *     MyMessage.decode(someBuffer); // throws if required fields are missing
		 * } catch (e) {
		 *     if (e instanceof ProtocolError && e.instance)
		 *         console.log("decoded so far: " + JSON.stringify(e.instance));
		 * }
		 */
		util.ProtocolError = newError("ProtocolError");

		/**
		 * So far decoded message instance.
		 * @name util.ProtocolError#instance
		 * @type {Message<T>}
		 */

		/**
		 * A OneOf getter as returned by {@link util.oneOfGetter}.
		 * @typedef OneOfGetter
		 * @type {function}
		 * @returns {string|undefined} Set field name, if any
		 */

		/**
		 * Builds a getter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfGetter} Unbound getter
		 */
		util.oneOfGetter = function getOneOf(fieldNames) {
		    var fieldMap = {};
		    for (var i = 0; i < fieldNames.length; ++i)
		        fieldMap[fieldNames[i]] = 1;

		    /**
		     * @returns {string|undefined} Set field name, if any
		     * @this Object
		     * @ignore
		     */
		    return function() { // eslint-disable-line consistent-return
		        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
		            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
		                return keys[i];
		    };
		};

		/**
		 * A OneOf setter as returned by {@link util.oneOfSetter}.
		 * @typedef OneOfSetter
		 * @type {function}
		 * @param {string|undefined} value Field name
		 * @returns {undefined}
		 */

		/**
		 * Builds a setter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfSetter} Unbound setter
		 */
		util.oneOfSetter = function setOneOf(fieldNames) {

		    /**
		     * @param {string} name Field name
		     * @returns {undefined}
		     * @this Object
		     * @ignore
		     */
		    return function(name) {
		        for (var i = 0; i < fieldNames.length; ++i)
		            if (fieldNames[i] !== name)
		                delete this[fieldNames[i]];
		    };
		};

		/**
		 * Default conversion options used for {@link Message#toJSON} implementations.
		 *
		 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
		 *
		 * - Longs become strings
		 * - Enums become string keys
		 * - Bytes become base64 encoded strings
		 * - (Sub-)Messages become plain objects
		 * - Maps become plain objects with all string keys
		 * - Repeated fields become arrays
		 * - NaN and Infinity for float and double fields become strings
		 *
		 * @type {IConversionOptions}
		 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
		 */
		util.toJSONOptions = {
		    longs: String,
		    enums: String,
		    bytes: String,
		    json: true
		};

		// Sets up buffer utility according to the environment (called in index-minimal)
		util._configure = function() {
		    var Buffer = util.Buffer;
		    /* istanbul ignore if */
		    if (!Buffer) {
		        util._Buffer_from = util._Buffer_allocUnsafe = null;
		        return;
		    }
		    // because node 4.x buffers are incompatible & immutable
		    // see: https://github.com/dcodeIO/protobuf.js/pull/665
		    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
		        /* istanbul ignore next */
		        function Buffer_from(value, encoding) {
		            return new Buffer(value, encoding);
		        };
		    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
		        /* istanbul ignore next */
		        function Buffer_allocUnsafe(size) {
		            return new Buffer(size);
		        };
		};
} (minimal));
	return minimal;
}

(function (module) {
	module.exports = Writer;

	var util      = requireMinimal();

	var BufferWriter; // cyclic

	var LongBits  = util.LongBits,
	    base64    = util.base64,
	    utf8      = util.utf8;

	/**
	 * Constructs a new writer operation instance.
	 * @classdesc Scheduled writer operation.
	 * @constructor
	 * @param {function(*, Uint8Array, number)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {*} val Value to write
	 * @ignore
	 */
	function Op(fn, len, val) {

	    /**
	     * Function to call.
	     * @type {function(Uint8Array, number, *)}
	     */
	    this.fn = fn;

	    /**
	     * Value byte length.
	     * @type {number}
	     */
	    this.len = len;

	    /**
	     * Next operation.
	     * @type {Writer.Op|undefined}
	     */
	    this.next = undefined;

	    /**
	     * Value to write.
	     * @type {*}
	     */
	    this.val = val; // type varies
	}

	/* istanbul ignore next */
	function noop() {} // eslint-disable-line no-empty-function

	/**
	 * Constructs a new writer state instance.
	 * @classdesc Copied writer state.
	 * @memberof Writer
	 * @constructor
	 * @param {Writer} writer Writer to copy state from
	 * @ignore
	 */
	function State(writer) {

	    /**
	     * Current head.
	     * @type {Writer.Op}
	     */
	    this.head = writer.head;

	    /**
	     * Current tail.
	     * @type {Writer.Op}
	     */
	    this.tail = writer.tail;

	    /**
	     * Current buffer length.
	     * @type {number}
	     */
	    this.len = writer.len;

	    /**
	     * Next state.
	     * @type {State|null}
	     */
	    this.next = writer.states;
	}

	/**
	 * Constructs a new writer instance.
	 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 */
	function Writer() {

	    /**
	     * Current length.
	     * @type {number}
	     */
	    this.len = 0;

	    /**
	     * Operations head.
	     * @type {Object}
	     */
	    this.head = new Op(noop, 0, 0);

	    /**
	     * Operations tail
	     * @type {Object}
	     */
	    this.tail = this.head;

	    /**
	     * Linked forked states.
	     * @type {Object|null}
	     */
	    this.states = null;

	    // When a value is written, the writer calculates its byte length and puts it into a linked
	    // list of operations to perform when finish() is called. This both allows us to allocate
	    // buffers of the exact required size and reduces the amount of work we have to do compared
	    // to first calculating over objects and then encoding over objects. In our case, the encoding
	    // part is just a linked list walk calling operations with already prepared values.
	}

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup() {
	            return (Writer.create = function create_buffer() {
	                return new BufferWriter();
	            })();
	        }
	        /* istanbul ignore next */
	        : function create_array() {
	            return new Writer();
	        };
	};

	/**
	 * Creates a new writer.
	 * @function
	 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
	 */
	Writer.create = create();

	/**
	 * Allocates a buffer of the specified size.
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */
	Writer.alloc = function alloc(size) {
	    return new util.Array(size);
	};

	// Use Uint8Array buffer pool in the browser, just like node does with buffers
	/* istanbul ignore else */
	if (util.Array !== Array)
	    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

	/**
	 * Pushes a new operation to the queue.
	 * @param {function(Uint8Array, number, *)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @returns {Writer} `this`
	 * @private
	 */
	Writer.prototype._push = function push(fn, len, val) {
	    this.tail = this.tail.next = new Op(fn, len, val);
	    this.len += len;
	    return this;
	};

	function writeByte(val, buf, pos) {
	    buf[pos] = val & 255;
	}

	function writeVarint32(val, buf, pos) {
	    while (val > 127) {
	        buf[pos++] = val & 127 | 128;
	        val >>>= 7;
	    }
	    buf[pos] = val;
	}

	/**
	 * Constructs a new varint writer operation instance.
	 * @classdesc Scheduled varint writer operation.
	 * @extends Op
	 * @constructor
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @ignore
	 */
	function VarintOp(len, val) {
	    this.len = len;
	    this.next = undefined;
	    this.val = val;
	}

	VarintOp.prototype = Object.create(Op.prototype);
	VarintOp.prototype.fn = writeVarint32;

	/**
	 * Writes an unsigned 32 bit value as a varint.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.uint32 = function write_uint32(value) {
	    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
	    // uint32 is by far the most frequently used operation and benefits significantly from this.
	    this.len += (this.tail = this.tail.next = new VarintOp(
	        (value = value >>> 0)
	                < 128       ? 1
	        : value < 16384     ? 2
	        : value < 2097152   ? 3
	        : value < 268435456 ? 4
	        :                     5,
	    value)).len;
	    return this;
	};

	/**
	 * Writes a signed 32 bit value as a varint.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.int32 = function write_int32(value) {
	    return value < 0
	        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
	        : this.uint32(value);
	};

	/**
	 * Writes a 32 bit value as a varint, zig-zag encoded.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sint32 = function write_sint32(value) {
	    return this.uint32((value << 1 ^ value >> 31) >>> 0);
	};

	function writeVarint64(val, buf, pos) {
	    while (val.hi) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
	        val.hi >>>= 7;
	    }
	    while (val.lo > 127) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = val.lo >>> 7;
	    }
	    buf[pos++] = val.lo;
	}

	/**
	 * Writes an unsigned 64 bit value as a varint.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.uint64 = function write_uint64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a signed 64 bit value as a varint.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.int64 = Writer.prototype.uint64;

	/**
	 * Writes a signed 64 bit value as a varint, zig-zag encoded.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sint64 = function write_sint64(value) {
	    var bits = LongBits.from(value).zzEncode();
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a boolish value as a varint.
	 * @param {boolean} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bool = function write_bool(value) {
	    return this._push(writeByte, 1, value ? 1 : 0);
	};

	function writeFixed32(val, buf, pos) {
	    buf[pos    ] =  val         & 255;
	    buf[pos + 1] =  val >>> 8   & 255;
	    buf[pos + 2] =  val >>> 16  & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	/**
	 * Writes an unsigned 32 bit value as fixed 32 bits.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fixed32 = function write_fixed32(value) {
	    return this._push(writeFixed32, 4, value >>> 0);
	};

	/**
	 * Writes a signed 32 bit value as fixed 32 bits.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sfixed32 = Writer.prototype.fixed32;

	/**
	 * Writes an unsigned 64 bit value as fixed 64 bits.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.fixed64 = function write_fixed64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
	};

	/**
	 * Writes a signed 64 bit value as fixed 64 bits.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sfixed64 = Writer.prototype.fixed64;

	/**
	 * Writes a float (32 bit).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.float = function write_float(value) {
	    return this._push(util.float.writeFloatLE, 4, value);
	};

	/**
	 * Writes a double (64 bit float).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.double = function write_double(value) {
	    return this._push(util.float.writeDoubleLE, 8, value);
	};

	var writeBytes = util.Array.prototype.set
	    ? function writeBytes_set(val, buf, pos) {
	        buf.set(val, pos); // also works for plain array values
	    }
	    /* istanbul ignore next */
	    : function writeBytes_for(val, buf, pos) {
	        for (var i = 0; i < val.length; ++i)
	            buf[pos + i] = val[i];
	    };

	/**
	 * Writes a sequence of bytes.
	 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bytes = function write_bytes(value) {
	    var len = value.length >>> 0;
	    if (!len)
	        return this._push(writeByte, 1, 0);
	    if (util.isString(value)) {
	        var buf = Writer.alloc(len = base64.length(value));
	        base64.decode(value, buf, 0);
	        value = buf;
	    }
	    return this.uint32(len)._push(writeBytes, len, value);
	};

	/**
	 * Writes a string.
	 * @param {string} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.string = function write_string(value) {
	    var len = utf8.length(value);
	    return len
	        ? this.uint32(len)._push(utf8.write, len, value)
	        : this._push(writeByte, 1, 0);
	};

	/**
	 * Forks this writer's state by pushing it to a stack.
	 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fork = function fork() {
	    this.states = new State(this);
	    this.head = this.tail = new Op(noop, 0, 0);
	    this.len = 0;
	    return this;
	};

	/**
	 * Resets this instance to the last state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.reset = function reset() {
	    if (this.states) {
	        this.head   = this.states.head;
	        this.tail   = this.states.tail;
	        this.len    = this.states.len;
	        this.states = this.states.next;
	    } else {
	        this.head = this.tail = new Op(noop, 0, 0);
	        this.len  = 0;
	    }
	    return this;
	};

	/**
	 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.ldelim = function ldelim() {
	    var head = this.head,
	        tail = this.tail,
	        len  = this.len;
	    this.reset().uint32(len);
	    if (len) {
	        this.tail.next = head.next; // skip noop
	        this.tail = tail;
	        this.len += len;
	    }
	    return this;
	};

	/**
	 * Finishes the write operation.
	 * @returns {Uint8Array} Finished buffer
	 */
	Writer.prototype.finish = function finish() {
	    var head = this.head.next, // skip noop
	        buf  = this.constructor.alloc(this.len),
	        pos  = 0;
	    while (head) {
	        head.fn(head.val, buf, pos);
	        pos += head.len;
	        head = head.next;
	    }
	    // this.head = this.tail = null;
	    return buf;
	};

	Writer._configure = function(BufferWriter_) {
	    BufferWriter = BufferWriter_;
	    Writer.create = create();
	    BufferWriter._configure();
	};
} (writer));

writer.exports.default;

var writer_buffer = {exports: {}};

(function (module) {
	module.exports = BufferWriter;

	// extends Writer
	var Writer = writer.exports;
	(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

	var util = requireMinimal();

	/**
	 * Constructs a new buffer writer instance.
	 * @classdesc Wire format writer using node buffers.
	 * @extends Writer
	 * @constructor
	 */
	function BufferWriter() {
	    Writer.call(this);
	}

	BufferWriter._configure = function () {
	    /**
	     * Allocates a buffer of the specified size.
	     * @function
	     * @param {number} size Buffer size
	     * @returns {Buffer} Buffer
	     */
	    BufferWriter.alloc = util._Buffer_allocUnsafe;

	    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
	        ? function writeBytesBuffer_set(val, buf, pos) {
	          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
	          // also works for plain array values
	        }
	        /* istanbul ignore next */
	        : function writeBytesBuffer_copy(val, buf, pos) {
	          if (val.copy) // Buffer values
	            val.copy(buf, pos, 0, val.length);
	          else for (var i = 0; i < val.length;) // plain array values
	            buf[pos++] = val[i++];
	        };
	};


	/**
	 * @override
	 */
	BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
	    if (util.isString(value))
	        value = util._Buffer_from(value, "base64");
	    var len = value.length >>> 0;
	    this.uint32(len);
	    if (len)
	        this._push(BufferWriter.writeBytesBuffer, len, value);
	    return this;
	};

	function writeStringBuffer(val, buf, pos) {
	    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
	        util.utf8.write(val, buf, pos);
	    else if (buf.utf8Write)
	        buf.utf8Write(val, pos);
	    else
	        buf.write(val, pos);
	}

	/**
	 * @override
	 */
	BufferWriter.prototype.string = function write_string_buffer(value) {
	    var len = util.Buffer.byteLength(value);
	    this.uint32(len);
	    if (len)
	        this._push(writeStringBuffer, len, value);
	    return this;
	};


	/**
	 * Finishes the write operation.
	 * @name BufferWriter#finish
	 * @function
	 * @returns {Buffer} Finished buffer
	 */

	BufferWriter._configure();
} (writer_buffer));

writer_buffer.exports.default;

var reader = {exports: {}};

(function (module) {
	module.exports = Reader;

	var util      = requireMinimal();

	var BufferReader; // cyclic

	var LongBits  = util.LongBits,
	    utf8      = util.utf8;

	/* istanbul ignore next */
	function indexOutOfRange(reader, writeLength) {
	    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
	}

	/**
	 * Constructs a new reader instance using the specified buffer.
	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 * @param {Uint8Array} buffer Buffer to read from
	 */
	function Reader(buffer) {

	    /**
	     * Read buffer.
	     * @type {Uint8Array}
	     */
	    this.buf = buffer;

	    /**
	     * Read buffer position.
	     * @type {number}
	     */
	    this.pos = 0;

	    /**
	     * Read buffer length.
	     * @type {number}
	     */
	    this.len = buffer.length;
	}

	var create_array = typeof Uint8Array !== "undefined"
	    ? function create_typed_array(buffer) {
	        if (buffer instanceof Uint8Array || Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    }
	    /* istanbul ignore next */
	    : function create_array(buffer) {
	        if (Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    };

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup(buffer) {
	            return (Reader.create = function create_buffer(buffer) {
	                return util.Buffer.isBuffer(buffer)
	                    ? new BufferReader(buffer)
	                    /* istanbul ignore next */
	                    : create_array(buffer);
	            })(buffer);
	        }
	        /* istanbul ignore next */
	        : create_array;
	};

	/**
	 * Creates a new reader using the specified buffer.
	 * @function
	 * @param {Uint8Array|Buffer} buffer Buffer to read from
	 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
	 * @throws {Error} If `buffer` is not a valid buffer
	 */
	Reader.create = create();

	Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

	/**
	 * Reads a varint as an unsigned 32 bit value.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.uint32 = (function read_uint32_setup() {
	    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
	    return function read_uint32() {
	        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

	        /* istanbul ignore if */
	        if ((this.pos += 5) > this.len) {
	            this.pos = this.len;
	            throw indexOutOfRange(this, 10);
	        }
	        return value;
	    };
	})();

	/**
	 * Reads a varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.int32 = function read_int32() {
	    return this.uint32() | 0;
	};

	/**
	 * Reads a zig-zag encoded varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.sint32 = function read_sint32() {
	    var value = this.uint32();
	    return value >>> 1 ^ -(value & 1) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readLongVarint() {
	    // tends to deopt with local vars for octet etc.
	    var bits = new LongBits(0, 0);
	    var i = 0;
	    if (this.len - this.pos > 4) { // fast route (lo)
	        for (; i < 4; ++i) {
	            // 1st..4th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 5th
	        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
	        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
	        if (this.buf[this.pos++] < 128)
	            return bits;
	        i = 0;
	    } else {
	        for (; i < 3; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 1st..3th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 4th
	        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
	        return bits;
	    }
	    if (this.len - this.pos > 4) { // fast route (hi)
	        for (; i < 5; ++i) {
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    } else {
	        for (; i < 5; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    }
	    /* istanbul ignore next */
	    throw Error("invalid varint encoding");
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads a varint as a signed 64 bit value.
	 * @name Reader#int64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as an unsigned 64 bit value.
	 * @name Reader#uint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a zig-zag encoded varint as a signed 64 bit value.
	 * @name Reader#sint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as a boolean.
	 * @returns {boolean} Value read
	 */
	Reader.prototype.bool = function read_bool() {
	    return this.uint32() !== 0;
	};

	function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
	    return (buf[end - 4]
	          | buf[end - 3] << 8
	          | buf[end - 2] << 16
	          | buf[end - 1] << 24) >>> 0;
	}

	/**
	 * Reads fixed 32 bits as an unsigned 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.fixed32 = function read_fixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4);
	};

	/**
	 * Reads fixed 32 bits as a signed 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.sfixed32 = function read_sfixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readFixed64(/* this: Reader */) {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 8);

	    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads fixed 64 bits.
	 * @name Reader#fixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads zig-zag encoded fixed 64 bits.
	 * @name Reader#sfixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a float (32 bit) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.float = function read_float() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readFloatLE(this.buf, this.pos);
	    this.pos += 4;
	    return value;
	};

	/**
	 * Reads a double (64 bit float) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.double = function read_double() {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readDoubleLE(this.buf, this.pos);
	    this.pos += 8;
	    return value;
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @returns {Uint8Array} Value read
	 */
	Reader.prototype.bytes = function read_bytes() {
	    var length = this.uint32(),
	        start  = this.pos,
	        end    = this.pos + length;

	    /* istanbul ignore if */
	    if (end > this.len)
	        throw indexOutOfRange(this, length);

	    this.pos += length;
	    if (Array.isArray(this.buf)) // plain array
	        return this.buf.slice(start, end);
	    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
	        ? new this.buf.constructor(0)
	        : this._slice.call(this.buf, start, end);
	};

	/**
	 * Reads a string preceeded by its byte length as a varint.
	 * @returns {string} Value read
	 */
	Reader.prototype.string = function read_string() {
	    var bytes = this.bytes();
	    return utf8.read(bytes, 0, bytes.length);
	};

	/**
	 * Skips the specified number of bytes if specified, otherwise skips a varint.
	 * @param {number} [length] Length if known, otherwise a varint is assumed
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skip = function skip(length) {
	    if (typeof length === "number") {
	        /* istanbul ignore if */
	        if (this.pos + length > this.len)
	            throw indexOutOfRange(this, length);
	        this.pos += length;
	    } else {
	        do {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	        } while (this.buf[this.pos++] & 128);
	    }
	    return this;
	};

	/**
	 * Skips the next element of the specified wire type.
	 * @param {number} wireType Wire type received
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skipType = function(wireType) {
	    switch (wireType) {
	        case 0:
	            this.skip();
	            break;
	        case 1:
	            this.skip(8);
	            break;
	        case 2:
	            this.skip(this.uint32());
	            break;
	        case 3:
	            while ((wireType = this.uint32() & 7) !== 4) {
	                this.skipType(wireType);
	            }
	            break;
	        case 5:
	            this.skip(4);
	            break;

	        /* istanbul ignore next */
	        default:
	            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
	    }
	    return this;
	};

	Reader._configure = function(BufferReader_) {
	    BufferReader = BufferReader_;
	    Reader.create = create();
	    BufferReader._configure();

	    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
	    util.merge(Reader.prototype, {

	        int64: function read_int64() {
	            return readLongVarint.call(this)[fn](false);
	        },

	        uint64: function read_uint64() {
	            return readLongVarint.call(this)[fn](true);
	        },

	        sint64: function read_sint64() {
	            return readLongVarint.call(this).zzDecode()[fn](false);
	        },

	        fixed64: function read_fixed64() {
	            return readFixed64.call(this)[fn](true);
	        },

	        sfixed64: function read_sfixed64() {
	            return readFixed64.call(this)[fn](false);
	        }

	    });
	};
} (reader));

reader.exports.default;

var reader_buffer = {exports: {}};

(function (module) {
	module.exports = BufferReader;

	// extends Reader
	var Reader = reader.exports;
	(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

	var util = requireMinimal();

	/**
	 * Constructs a new buffer reader instance.
	 * @classdesc Wire format reader using node buffers.
	 * @extends Reader
	 * @constructor
	 * @param {Buffer} buffer Buffer to read from
	 */
	function BufferReader(buffer) {
	    Reader.call(this, buffer);

	    /**
	     * Read buffer.
	     * @name BufferReader#buf
	     * @type {Buffer}
	     */
	}

	BufferReader._configure = function () {
	    /* istanbul ignore else */
	    if (util.Buffer)
	        BufferReader.prototype._slice = util.Buffer.prototype.slice;
	};


	/**
	 * @override
	 */
	BufferReader.prototype.string = function read_string_buffer() {
	    var len = this.uint32(); // modifies pos
	    return this.buf.utf8Slice
	        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
	        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @name BufferReader#bytes
	 * @function
	 * @returns {Buffer} Value read
	 */

	BufferReader._configure();
} (reader_buffer));

reader_buffer.exports.default;

var rpc = {};

var service$1 = {exports: {}};

(function (module) {
	module.exports = Service;

	var util = requireMinimal();

	// Extends EventEmitter
	(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

	/**
	 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
	 *
	 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
	 * @typedef rpc.ServiceMethodCallback
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {TRes} [response] Response message
	 * @returns {undefined}
	 */

	/**
	 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
	 * @typedef rpc.ServiceMethod
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
	 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
	 */

	/**
	 * Constructs a new RPC service instance.
	 * @classdesc An RPC service as returned by {@link Service#create}.
	 * @exports rpc.Service
	 * @extends util.EventEmitter
	 * @constructor
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 */
	function Service(rpcImpl, requestDelimited, responseDelimited) {

	    if (typeof rpcImpl !== "function")
	        throw TypeError("rpcImpl must be a function");

	    util.EventEmitter.call(this);

	    /**
	     * RPC implementation. Becomes `null` once the service is ended.
	     * @type {RPCImpl|null}
	     */
	    this.rpcImpl = rpcImpl;

	    /**
	     * Whether requests are length-delimited.
	     * @type {boolean}
	     */
	    this.requestDelimited = Boolean(requestDelimited);

	    /**
	     * Whether responses are length-delimited.
	     * @type {boolean}
	     */
	    this.responseDelimited = Boolean(responseDelimited);
	}

	/**
	 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
	 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
	 * @param {Constructor<TReq>} requestCtor Request constructor
	 * @param {Constructor<TRes>} responseCtor Response constructor
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
	 * @returns {undefined}
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 */
	Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

	    if (!request)
	        throw TypeError("request must be specified");

	    var self = this;
	    if (!callback)
	        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

	    if (!self.rpcImpl) {
	        setTimeout(function() { callback(Error("already ended")); }, 0);
	        return undefined;
	    }

	    try {
	        return self.rpcImpl(
	            method,
	            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
	            function rpcCallback(err, response) {

	                if (err) {
	                    self.emit("error", err, method);
	                    return callback(err);
	                }

	                if (response === null) {
	                    self.end(/* endedByRPC */ true);
	                    return undefined;
	                }

	                if (!(response instanceof responseCtor)) {
	                    try {
	                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
	                    } catch (err) {
	                        self.emit("error", err, method);
	                        return callback(err);
	                    }
	                }

	                self.emit("data", response, method);
	                return callback(null, response);
	            }
	        );
	    } catch (err) {
	        self.emit("error", err, method);
	        setTimeout(function() { callback(err); }, 0);
	        return undefined;
	    }
	};

	/**
	 * Ends this service and emits the `end` event.
	 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
	 * @returns {rpc.Service} `this`
	 */
	Service.prototype.end = function end(endedByRPC) {
	    if (this.rpcImpl) {
	        if (!endedByRPC) // signal end to rpcImpl
	            this.rpcImpl(null, null, null);
	        this.rpcImpl = null;
	        this.emit("end").off();
	    }
	    return this;
	};
} (service$1));

service$1.exports.default;

(function (exports) {

	/**
	 * Streaming RPC helpers.
	 * @namespace
	 */
	var rpc = exports;

	/**
	 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
	 * @typedef RPCImpl
	 * @type {function}
	 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
	 * @param {Uint8Array} requestData Request data
	 * @param {RPCImplCallback} callback Callback function
	 * @returns {undefined}
	 * @example
	 * function rpcImpl(method, requestData, callback) {
	 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
	 *         throw Error("no such method");
	 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
	 *         callback(err, responseData);
	 *     });
	 * }
	 */

	/**
	 * Node-style callback as used by {@link RPCImpl}.
	 * @typedef RPCImplCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any, otherwise `null`
	 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
	 * @returns {undefined}
	 */

	rpc.Service = service$1.exports;
} (rpc));

rpc.default;

var roots = {exports: {}};

(function (module) {
	module.exports = {};

	/**
	 * Named roots.
	 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
	 * Can also be used manually to make roots available accross modules.
	 * @name roots
	 * @type {Object.<string,Root>}
	 * @example
	 * // pbjs -r myroot -o compiled.js ...
	 *
	 * // in another module:
	 * require("./compiled.js");
	 *
	 * // in any subsequent module:
	 * var root = protobuf.roots["myroot"];
	 */
} (roots));

roots.exports.default;

(function (exports) {
	var protobuf = exports;

	/**
	 * Build type, one of `"full"`, `"light"` or `"minimal"`.
	 * @name build
	 * @type {string}
	 * @const
	 */
	protobuf.build = "minimal";

	// Serialization
	protobuf.Writer       = writer.exports;
	protobuf.BufferWriter = writer_buffer.exports;
	protobuf.Reader       = reader.exports;
	protobuf.BufferReader = reader_buffer.exports;

	// Utility
	protobuf.util         = requireMinimal();
	protobuf.rpc          = rpc;
	protobuf.roots        = roots.exports;
	protobuf.configure    = configure;

	/* istanbul ignore next */
	/**
	 * Reconfigures the library according to the environment.
	 * @returns {undefined}
	 */
	function configure() {
	    protobuf.util._configure();
	    protobuf.Writer._configure(protobuf.BufferWriter);
	    protobuf.Reader._configure(protobuf.BufferReader);
	}

	// Set up buffer utility according to the environment
	configure();
} (indexMinimal));

indexMinimal.default;

(function (module) {
	module.exports = indexMinimal;
} (minimal$1));

minimal$1.exports.default;

var helpers = {};

/* eslint-disable */
/**
* This file and any referenced files were automatically generated by @osmonauts/telescope@0.81.5
* DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
* and run the transpile command or yarn proto command to regenerate this bundle.
*/
var __createBinding$l = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$l = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$l = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$l(result, mod, k);
    __setModuleDefault$l(result, mod);
    return result;
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(helpers, "__esModule", { value: true });
helpers.fromJsonTimestamp = helpers.fromTimestamp = helpers.toTimestamp = helpers.setPaginationParams = helpers.isObject = helpers.isSet = helpers.fromDuration = helpers.toDuration = helpers.omitDefault = helpers.base64FromBytes = bytesFromBase64_1 = helpers.bytesFromBase64 = Long = helpers.Long = void 0;
const _m0$l = __importStar$l(minimal$1.exports);
const long_1 = __importDefault(Long__default["default"]);
var Long = helpers.Long = long_1.default;
// @ts-ignore
if (_m0$l.util.Long !== long_1.default) {
    _m0$l.util.Long = long_1.default;
    _m0$l.configure();
}
var globalThis$1 = (() => {
    if (typeof globalThis$1 !== 'undefined')
        return globalThis$1;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof commonjsGlobal !== 'undefined')
        return commonjsGlobal;
    throw 'Unable to locate global object';
})();
const atob = globalThis$1.atob || ((b64) => globalThis$1.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
var bytesFromBase64_1 = helpers.bytesFromBase64 = bytesFromBase64;
const btoa = globalThis$1.btoa || ((bin) => globalThis$1.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte) => {
        bin.push(String.fromCharCode(byte));
    });
    return btoa(bin.join(''));
}
helpers.base64FromBytes = base64FromBytes;
function omitDefault(input) {
    if (typeof input === "string") {
        return input === "" ? undefined : input;
    }
    if (typeof input === "number") {
        return input === 0 ? undefined : input;
    }
    if (long_1.default.isLong(input)) {
        return input.isZero() ? undefined : input;
    }
    throw new Error(`Got unsupported type ${typeof input}`);
}
helpers.omitDefault = omitDefault;
function toDuration(duration) {
    return {
        seconds: long_1.default.fromNumber(Math.floor(parseInt(duration) / 1000000000)),
        nanos: parseInt(duration) % 1000000000
    };
}
helpers.toDuration = toDuration;
function fromDuration(duration) {
    return (parseInt(duration.seconds.toString()) * 1000000000 + duration.nanos).toString();
}
helpers.fromDuration = fromDuration;
function isSet(value) {
    return value !== null && value !== undefined;
}
helpers.isSet = isSet;
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
helpers.isObject = isObject;
const setPaginationParams = (options, pagination) => {
    if (!pagination) {
        return options;
    }
    if (typeof pagination?.countTotal !== "undefined") {
        options.params['pagination.count_total'] = pagination.countTotal;
    }
    if (typeof pagination?.key !== "undefined") {
        // String to Uint8Array
        // let uint8arr = new Uint8Array(Buffer.from(data,'base64')); 
        // Uint8Array to String
        options.params['pagination.key'] = Buffer.from(pagination.key).toString('base64');
    }
    if (typeof pagination?.limit !== "undefined") {
        options.params["pagination.limit"] = pagination.limit.toString();
    }
    if (typeof pagination?.offset !== "undefined") {
        options.params["pagination.offset"] = pagination.offset.toString();
    }
    if (typeof pagination?.reverse !== "undefined") {
        options.params['pagination.reverse'] = pagination.reverse;
    }
    return options;
};
helpers.setPaginationParams = setPaginationParams;
function toTimestamp(date) {
    const seconds = numberToLong(date.getTime() / 1000);
    const nanos = date.getTime() % 1000 * 1000000;
    return {
        seconds,
        nanos
    };
}
helpers.toTimestamp = toTimestamp;
function fromTimestamp(t) {
    let millis = t.seconds.toNumber() * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
helpers.fromTimestamp = fromTimestamp;
const timestampFromJSON = (object) => {
    return {
        seconds: isSet(object.seconds) ? long_1.default.fromValue(object.seconds) : long_1.default.ZERO,
        nanos: isSet(object.nanos) ? Number(object.nanos) : 0,
    };
};
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return toTimestamp(o);
    }
    else if (typeof o === "string") {
        return toTimestamp(new Date(o));
    }
    else {
        return timestampFromJSON(o);
    }
}
helpers.fromJsonTimestamp = fromJsonTimestamp;
function numberToLong(number) {
    return long_1.default.fromNumber(number);
}

var __createBinding$k = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$k = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$k = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$k(result, mod, k);
    __setModuleDefault$k(result, mod);
    return result;
};
Object.defineProperty(any, "__esModule", { value: true });
var Any = any.Any = any.protobufPackage = void 0;
/* eslint-disable */
const _m0$k = __importStar$k(minimal$1.exports);
const helpers_1$k = helpers;
any.protobufPackage = "google.protobuf";
function createBaseAny() {
    return {
        typeUrl: "",
        value: new Uint8Array()
    };
}
Any = any.Any = {
    encode(message, writer = _m0$k.Writer.create()) {
        if (message.typeUrl !== "") {
            writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$k.Reader ? input : new _m0$k.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.typeUrl = reader.string();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            typeUrl: (0, helpers_1$k.isSet)(object.typeUrl) ? String(object.typeUrl) : "",
            value: (0, helpers_1$k.isSet)(object.value) ? (0, helpers_1$k.bytesFromBase64)(object.value) : new Uint8Array()
        };
    },
    toJSON(message) {
        const obj = {};
        message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);
        message.value !== undefined && (obj.value = (0, helpers_1$k.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAny();
        message.typeUrl = object.typeUrl ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
    },
    fromSDK(object) {
        return {
            typeUrl: object?.type_url,
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.type_url = message.typeUrl;
        obj.value = message.value;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Params = exports.ModuleCredential = exports.ModuleAccount = exports.BaseAccount = exports.protobufPackage = void 0;
	/* eslint-disable */
	const any_1 = any;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "cosmos.auth.v1beta1";
	function createBaseBaseAccount() {
	    return {
	        address: "",
	        pubKey: undefined,
	        accountNumber: helpers_1.Long.UZERO,
	        sequence: helpers_1.Long.UZERO
	    };
	}
	exports.BaseAccount = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.pubKey !== undefined) {
	            any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.accountNumber.isZero()) {
	            writer.uint32(24).uint64(message.accountNumber);
	        }
	        if (!message.sequence.isZero()) {
	            writer.uint32(32).uint64(message.sequence);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBaseAccount();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.pubKey = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.accountNumber = reader.uint64();
	                    break;
	                case 4:
	                    message.sequence = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            pubKey: (0, helpers_1.isSet)(object.pubKey) ? any_1.Any.fromJSON(object.pubKey) : undefined,
	            accountNumber: (0, helpers_1.isSet)(object.accountNumber) ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO,
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : undefined);
	        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || helpers_1.Long.UZERO).toString());
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBaseAccount();
	        message.address = object.address ?? "";
	        message.pubKey = object.pubKey !== undefined && object.pubKey !== null ? any_1.Any.fromPartial(object.pubKey) : undefined;
	        message.accountNumber = object.accountNumber !== undefined && object.accountNumber !== null ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO;
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            pubKey: object.pub_key ? any_1.Any.fromSDK(object.pub_key) : undefined,
	            accountNumber: object?.account_number,
	            sequence: object?.sequence
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.pubKey !== undefined && (obj.pub_key = message.pubKey ? any_1.Any.toSDK(message.pubKey) : undefined);
	        obj.account_number = message.accountNumber;
	        obj.sequence = message.sequence;
	        return obj;
	    }
	};
	function createBaseModuleAccount() {
	    return {
	        baseAccount: undefined,
	        name: "",
	        permissions: []
	    };
	}
	exports.ModuleAccount = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.baseAccount !== undefined) {
	            exports.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.name !== "") {
	            writer.uint32(18).string(message.name);
	        }
	        for (const v of message.permissions) {
	            writer.uint32(26).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseModuleAccount();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.baseAccount = exports.BaseAccount.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.name = reader.string();
	                    break;
	                case 3:
	                    message.permissions.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            baseAccount: (0, helpers_1.isSet)(object.baseAccount) ? exports.BaseAccount.fromJSON(object.baseAccount) : undefined,
	            name: (0, helpers_1.isSet)(object.name) ? String(object.name) : "",
	            permissions: Array.isArray(object?.permissions) ? object.permissions.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.baseAccount !== undefined && (obj.baseAccount = message.baseAccount ? exports.BaseAccount.toJSON(message.baseAccount) : undefined);
	        message.name !== undefined && (obj.name = message.name);
	        if (message.permissions) {
	            obj.permissions = message.permissions.map(e => e);
	        }
	        else {
	            obj.permissions = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseModuleAccount();
	        message.baseAccount = object.baseAccount !== undefined && object.baseAccount !== null ? exports.BaseAccount.fromPartial(object.baseAccount) : undefined;
	        message.name = object.name ?? "";
	        message.permissions = object.permissions?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            baseAccount: object.base_account ? exports.BaseAccount.fromSDK(object.base_account) : undefined,
	            name: object?.name,
	            permissions: Array.isArray(object?.permissions) ? object.permissions.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.baseAccount !== undefined && (obj.base_account = message.baseAccount ? exports.BaseAccount.toSDK(message.baseAccount) : undefined);
	        obj.name = message.name;
	        if (message.permissions) {
	            obj.permissions = message.permissions.map(e => e);
	        }
	        else {
	            obj.permissions = [];
	        }
	        return obj;
	    }
	};
	function createBaseModuleCredential() {
	    return {
	        moduleName: "",
	        derivationKeys: []
	    };
	}
	exports.ModuleCredential = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.moduleName !== "") {
	            writer.uint32(10).string(message.moduleName);
	        }
	        for (const v of message.derivationKeys) {
	            writer.uint32(18).bytes(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseModuleCredential();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.moduleName = reader.string();
	                    break;
	                case 2:
	                    message.derivationKeys.push(reader.bytes());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            moduleName: (0, helpers_1.isSet)(object.moduleName) ? String(object.moduleName) : "",
	            derivationKeys: Array.isArray(object?.derivationKeys) ? object.derivationKeys.map((e) => (0, helpers_1.bytesFromBase64)(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.moduleName !== undefined && (obj.moduleName = message.moduleName);
	        if (message.derivationKeys) {
	            obj.derivationKeys = message.derivationKeys.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.derivationKeys = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseModuleCredential();
	        message.moduleName = object.moduleName ?? "";
	        message.derivationKeys = object.derivationKeys?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            moduleName: object?.module_name,
	            derivationKeys: Array.isArray(object?.derivation_keys) ? object.derivation_keys.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.module_name = message.moduleName;
	        if (message.derivationKeys) {
	            obj.derivation_keys = message.derivationKeys.map(e => e);
	        }
	        else {
	            obj.derivation_keys = [];
	        }
	        return obj;
	    }
	};
	function createBaseParams() {
	    return {
	        maxMemoCharacters: helpers_1.Long.UZERO,
	        txSigLimit: helpers_1.Long.UZERO,
	        txSizeCostPerByte: helpers_1.Long.UZERO,
	        sigVerifyCostEd25519: helpers_1.Long.UZERO,
	        sigVerifyCostSecp256k1: helpers_1.Long.UZERO
	    };
	}
	exports.Params = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.maxMemoCharacters.isZero()) {
	            writer.uint32(8).uint64(message.maxMemoCharacters);
	        }
	        if (!message.txSigLimit.isZero()) {
	            writer.uint32(16).uint64(message.txSigLimit);
	        }
	        if (!message.txSizeCostPerByte.isZero()) {
	            writer.uint32(24).uint64(message.txSizeCostPerByte);
	        }
	        if (!message.sigVerifyCostEd25519.isZero()) {
	            writer.uint32(32).uint64(message.sigVerifyCostEd25519);
	        }
	        if (!message.sigVerifyCostSecp256k1.isZero()) {
	            writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.maxMemoCharacters = reader.uint64();
	                    break;
	                case 2:
	                    message.txSigLimit = reader.uint64();
	                    break;
	                case 3:
	                    message.txSizeCostPerByte = reader.uint64();
	                    break;
	                case 4:
	                    message.sigVerifyCostEd25519 = reader.uint64();
	                    break;
	                case 5:
	                    message.sigVerifyCostSecp256k1 = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            maxMemoCharacters: (0, helpers_1.isSet)(object.maxMemoCharacters) ? helpers_1.Long.fromValue(object.maxMemoCharacters) : helpers_1.Long.UZERO,
	            txSigLimit: (0, helpers_1.isSet)(object.txSigLimit) ? helpers_1.Long.fromValue(object.txSigLimit) : helpers_1.Long.UZERO,
	            txSizeCostPerByte: (0, helpers_1.isSet)(object.txSizeCostPerByte) ? helpers_1.Long.fromValue(object.txSizeCostPerByte) : helpers_1.Long.UZERO,
	            sigVerifyCostEd25519: (0, helpers_1.isSet)(object.sigVerifyCostEd25519) ? helpers_1.Long.fromValue(object.sigVerifyCostEd25519) : helpers_1.Long.UZERO,
	            sigVerifyCostSecp256k1: (0, helpers_1.isSet)(object.sigVerifyCostSecp256k1) ? helpers_1.Long.fromValue(object.sigVerifyCostSecp256k1) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.maxMemoCharacters !== undefined && (obj.maxMemoCharacters = (message.maxMemoCharacters || helpers_1.Long.UZERO).toString());
	        message.txSigLimit !== undefined && (obj.txSigLimit = (message.txSigLimit || helpers_1.Long.UZERO).toString());
	        message.txSizeCostPerByte !== undefined && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || helpers_1.Long.UZERO).toString());
	        message.sigVerifyCostEd25519 !== undefined && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || helpers_1.Long.UZERO).toString());
	        message.sigVerifyCostSecp256k1 !== undefined && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseParams();
	        message.maxMemoCharacters = object.maxMemoCharacters !== undefined && object.maxMemoCharacters !== null ? helpers_1.Long.fromValue(object.maxMemoCharacters) : helpers_1.Long.UZERO;
	        message.txSigLimit = object.txSigLimit !== undefined && object.txSigLimit !== null ? helpers_1.Long.fromValue(object.txSigLimit) : helpers_1.Long.UZERO;
	        message.txSizeCostPerByte = object.txSizeCostPerByte !== undefined && object.txSizeCostPerByte !== null ? helpers_1.Long.fromValue(object.txSizeCostPerByte) : helpers_1.Long.UZERO;
	        message.sigVerifyCostEd25519 = object.sigVerifyCostEd25519 !== undefined && object.sigVerifyCostEd25519 !== null ? helpers_1.Long.fromValue(object.sigVerifyCostEd25519) : helpers_1.Long.UZERO;
	        message.sigVerifyCostSecp256k1 = object.sigVerifyCostSecp256k1 !== undefined && object.sigVerifyCostSecp256k1 !== null ? helpers_1.Long.fromValue(object.sigVerifyCostSecp256k1) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            maxMemoCharacters: object?.max_memo_characters,
	            txSigLimit: object?.tx_sig_limit,
	            txSizeCostPerByte: object?.tx_size_cost_per_byte,
	            sigVerifyCostEd25519: object?.sig_verify_cost_ed25519,
	            sigVerifyCostSecp256k1: object?.sig_verify_cost_secp256k1
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.max_memo_characters = message.maxMemoCharacters;
	        obj.tx_sig_limit = message.txSigLimit;
	        obj.tx_size_cost_per_byte = message.txSizeCostPerByte;
	        obj.sig_verify_cost_ed25519 = message.sigVerifyCostEd25519;
	        obj.sig_verify_cost_secp256k1 = message.sigVerifyCostSecp256k1;
	        return obj;
	    }
	};
	
} (auth));

auth.default;

var query$9 = {};

var pagination = {};

var __createBinding$j = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$j = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$j = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$j(result, mod, k);
    __setModuleDefault$j(result, mod);
    return result;
};
Object.defineProperty(pagination, "__esModule", { value: true });
pagination.PageResponse = pagination.PageRequest = pagination.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$j = helpers;
const _m0$j = __importStar$j(minimal$1.exports);
pagination.protobufPackage = "cosmos.base.query.v1beta1";
function createBasePageRequest() {
    return {
        key: new Uint8Array(),
        offset: helpers_1$j.Long.UZERO,
        limit: helpers_1$j.Long.UZERO,
        countTotal: false,
        reverse: false
    };
}
pagination.PageRequest = {
    encode(message, writer = _m0$j.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        if (!message.offset.isZero()) {
            writer.uint32(16).uint64(message.offset);
        }
        if (!message.limit.isZero()) {
            writer.uint32(24).uint64(message.limit);
        }
        if (message.countTotal === true) {
            writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse === true) {
            writer.uint32(40).bool(message.reverse);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$j.Reader ? input : new _m0$j.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.offset = reader.uint64();
                    break;
                case 3:
                    message.limit = reader.uint64();
                    break;
                case 4:
                    message.countTotal = reader.bool();
                    break;
                case 5:
                    message.reverse = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: (0, helpers_1$j.isSet)(object.key) ? (0, helpers_1$j.bytesFromBase64)(object.key) : new Uint8Array(),
            offset: (0, helpers_1$j.isSet)(object.offset) ? helpers_1$j.Long.fromValue(object.offset) : helpers_1$j.Long.UZERO,
            limit: (0, helpers_1$j.isSet)(object.limit) ? helpers_1$j.Long.fromValue(object.limit) : helpers_1$j.Long.UZERO,
            countTotal: (0, helpers_1$j.isSet)(object.countTotal) ? Boolean(object.countTotal) : false,
            reverse: (0, helpers_1$j.isSet)(object.reverse) ? Boolean(object.reverse) : false
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1$j.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.offset !== undefined && (obj.offset = (message.offset || helpers_1$j.Long.UZERO).toString());
        message.limit !== undefined && (obj.limit = (message.limit || helpers_1$j.Long.UZERO).toString());
        message.countTotal !== undefined && (obj.countTotal = message.countTotal);
        message.reverse !== undefined && (obj.reverse = message.reverse);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePageRequest();
        message.key = object.key ?? new Uint8Array();
        message.offset = object.offset !== undefined && object.offset !== null ? helpers_1$j.Long.fromValue(object.offset) : helpers_1$j.Long.UZERO;
        message.limit = object.limit !== undefined && object.limit !== null ? helpers_1$j.Long.fromValue(object.limit) : helpers_1$j.Long.UZERO;
        message.countTotal = object.countTotal ?? false;
        message.reverse = object.reverse ?? false;
        return message;
    },
    fromSDK(object) {
        return {
            key: object?.key,
            offset: object?.offset,
            limit: object?.limit,
            countTotal: object?.count_total,
            reverse: object?.reverse
        };
    },
    toSDK(message) {
        const obj = {};
        obj.key = message.key;
        obj.offset = message.offset;
        obj.limit = message.limit;
        obj.count_total = message.countTotal;
        obj.reverse = message.reverse;
        return obj;
    }
};
function createBasePageResponse() {
    return {
        nextKey: new Uint8Array(),
        total: helpers_1$j.Long.UZERO
    };
}
pagination.PageResponse = {
    encode(message, writer = _m0$j.Writer.create()) {
        if (message.nextKey.length !== 0) {
            writer.uint32(10).bytes(message.nextKey);
        }
        if (!message.total.isZero()) {
            writer.uint32(16).uint64(message.total);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$j.Reader ? input : new _m0$j.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nextKey = reader.bytes();
                    break;
                case 2:
                    message.total = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            nextKey: (0, helpers_1$j.isSet)(object.nextKey) ? (0, helpers_1$j.bytesFromBase64)(object.nextKey) : new Uint8Array(),
            total: (0, helpers_1$j.isSet)(object.total) ? helpers_1$j.Long.fromValue(object.total) : helpers_1$j.Long.UZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.nextKey !== undefined && (obj.nextKey = (0, helpers_1$j.base64FromBytes)(message.nextKey !== undefined ? message.nextKey : new Uint8Array()));
        message.total !== undefined && (obj.total = (message.total || helpers_1$j.Long.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBasePageResponse();
        message.nextKey = object.nextKey ?? new Uint8Array();
        message.total = object.total !== undefined && object.total !== null ? helpers_1$j.Long.fromValue(object.total) : helpers_1$j.Long.UZERO;
        return message;
    },
    fromSDK(object) {
        return {
            nextKey: object?.next_key,
            total: object?.total
        };
    },
    toSDK(message) {
        const obj = {};
        obj.next_key = message.nextKey;
        obj.total = message.total;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QueryAccountInfoResponse = exports.QueryAccountInfoRequest = exports.QueryAccountAddressByIDResponse = exports.QueryAccountAddressByIDRequest = exports.AddressStringToBytesResponse = exports.AddressStringToBytesRequest = exports.AddressBytesToStringResponse = exports.AddressBytesToStringRequest = exports.QueryModuleAccountByNameResponse = exports.QueryModuleAccountByNameRequest = exports.QueryModuleAccountsResponse = exports.QueryModuleAccountsRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryAccountResponse = exports.QueryAccountRequest = exports.QueryAccountsResponse = exports.QueryAccountsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const pagination_1 = pagination;
	const any_1 = any;
	const auth_1 = auth;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.auth.v1beta1";
	function createBaseQueryAccountsRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryAccountsRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountsRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAccountsResponse() {
	    return {
	        accounts: [],
	        pagination: undefined
	    };
	}
	exports.QueryAccountsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.accounts) {
	            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            accounts: Array.isArray(object?.accounts) ? object.accounts.map((e) => any_1.Any.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.accounts) {
	            obj.accounts = message.accounts.map(e => e ? any_1.Any.toJSON(e) : undefined);
	        }
	        else {
	            obj.accounts = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountsResponse();
	        message.accounts = object.accounts?.map(e => any_1.Any.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            accounts: Array.isArray(object?.accounts) ? object.accounts.map((e) => any_1.Any.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.accounts) {
	            obj.accounts = message.accounts.map(e => e ? any_1.Any.toSDK(e) : undefined);
	        }
	        else {
	            obj.accounts = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAccountRequest() {
	    return {
	        address: ""
	    };
	}
	exports.QueryAccountRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountRequest();
	        message.address = object.address ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        return obj;
	    }
	};
	function createBaseQueryAccountResponse() {
	    return {
	        account: undefined
	    };
	}
	exports.QueryAccountResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.account !== undefined) {
	            any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.account = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            account: (0, helpers_1.isSet)(object.account) ? any_1.Any.fromJSON(object.account) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.account !== undefined && (obj.account = message.account ? any_1.Any.toJSON(message.account) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountResponse();
	        message.account = object.account !== undefined && object.account !== null ? any_1.Any.fromPartial(object.account) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            account: object.account ? any_1.Any.fromSDK(object.account) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.account !== undefined && (obj.account = message.account ? any_1.Any.toSDK(message.account) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = auth_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? auth_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? auth_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? auth_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? auth_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryModuleAccountsRequest() {
	    return {};
	}
	exports.QueryModuleAccountsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryModuleAccountsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryModuleAccountsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryModuleAccountsResponse() {
	    return {
	        accounts: []
	    };
	}
	exports.QueryModuleAccountsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.accounts) {
	            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryModuleAccountsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            accounts: Array.isArray(object?.accounts) ? object.accounts.map((e) => any_1.Any.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.accounts) {
	            obj.accounts = message.accounts.map(e => e ? any_1.Any.toJSON(e) : undefined);
	        }
	        else {
	            obj.accounts = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryModuleAccountsResponse();
	        message.accounts = object.accounts?.map(e => any_1.Any.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            accounts: Array.isArray(object?.accounts) ? object.accounts.map((e) => any_1.Any.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.accounts) {
	            obj.accounts = message.accounts.map(e => e ? any_1.Any.toSDK(e) : undefined);
	        }
	        else {
	            obj.accounts = [];
	        }
	        return obj;
	    }
	};
	function createBaseQueryModuleAccountByNameRequest() {
	    return {
	        name: ""
	    };
	}
	exports.QueryModuleAccountByNameRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.name !== "") {
	            writer.uint32(10).string(message.name);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryModuleAccountByNameRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.name = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            name: (0, helpers_1.isSet)(object.name) ? String(object.name) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.name !== undefined && (obj.name = message.name);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryModuleAccountByNameRequest();
	        message.name = object.name ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            name: object?.name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.name = message.name;
	        return obj;
	    }
	};
	function createBaseQueryModuleAccountByNameResponse() {
	    return {
	        account: undefined
	    };
	}
	exports.QueryModuleAccountByNameResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.account !== undefined) {
	            any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryModuleAccountByNameResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.account = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            account: (0, helpers_1.isSet)(object.account) ? any_1.Any.fromJSON(object.account) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.account !== undefined && (obj.account = message.account ? any_1.Any.toJSON(message.account) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryModuleAccountByNameResponse();
	        message.account = object.account !== undefined && object.account !== null ? any_1.Any.fromPartial(object.account) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            account: object.account ? any_1.Any.fromSDK(object.account) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.account !== undefined && (obj.account = message.account ? any_1.Any.toSDK(message.account) : undefined);
	        return obj;
	    }
	};
	function createBaseAddressBytesToStringRequest() {
	    return {
	        addressBytes: new Uint8Array()
	    };
	}
	exports.AddressBytesToStringRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.addressBytes.length !== 0) {
	            writer.uint32(10).bytes(message.addressBytes);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAddressBytesToStringRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.addressBytes = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            addressBytes: (0, helpers_1.isSet)(object.addressBytes) ? (0, helpers_1.bytesFromBase64)(object.addressBytes) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.addressBytes !== undefined && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== undefined ? message.addressBytes : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAddressBytesToStringRequest();
	        message.addressBytes = object.addressBytes ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            addressBytes: object?.address_bytes
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address_bytes = message.addressBytes;
	        return obj;
	    }
	};
	function createBaseAddressBytesToStringResponse() {
	    return {
	        addressString: ""
	    };
	}
	exports.AddressBytesToStringResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.addressString !== "") {
	            writer.uint32(10).string(message.addressString);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAddressBytesToStringResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.addressString = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            addressString: (0, helpers_1.isSet)(object.addressString) ? String(object.addressString) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.addressString !== undefined && (obj.addressString = message.addressString);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAddressBytesToStringResponse();
	        message.addressString = object.addressString ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            addressString: object?.address_string
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address_string = message.addressString;
	        return obj;
	    }
	};
	function createBaseAddressStringToBytesRequest() {
	    return {
	        addressString: ""
	    };
	}
	exports.AddressStringToBytesRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.addressString !== "") {
	            writer.uint32(10).string(message.addressString);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAddressStringToBytesRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.addressString = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            addressString: (0, helpers_1.isSet)(object.addressString) ? String(object.addressString) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.addressString !== undefined && (obj.addressString = message.addressString);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAddressStringToBytesRequest();
	        message.addressString = object.addressString ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            addressString: object?.address_string
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address_string = message.addressString;
	        return obj;
	    }
	};
	function createBaseAddressStringToBytesResponse() {
	    return {
	        addressBytes: new Uint8Array()
	    };
	}
	exports.AddressStringToBytesResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.addressBytes.length !== 0) {
	            writer.uint32(10).bytes(message.addressBytes);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAddressStringToBytesResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.addressBytes = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            addressBytes: (0, helpers_1.isSet)(object.addressBytes) ? (0, helpers_1.bytesFromBase64)(object.addressBytes) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.addressBytes !== undefined && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== undefined ? message.addressBytes : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAddressStringToBytesResponse();
	        message.addressBytes = object.addressBytes ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            addressBytes: object?.address_bytes
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address_bytes = message.addressBytes;
	        return obj;
	    }
	};
	function createBaseQueryAccountAddressByIDRequest() {
	    return {
	        id: helpers_1.Long.ZERO,
	        accountId: helpers_1.Long.UZERO
	    };
	}
	exports.QueryAccountAddressByIDRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.id.isZero()) {
	            writer.uint32(8).int64(message.id);
	        }
	        if (!message.accountId.isZero()) {
	            writer.uint32(16).uint64(message.accountId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountAddressByIDRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.id = reader.int64();
	                    break;
	                case 2:
	                    message.accountId = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            id: (0, helpers_1.isSet)(object.id) ? helpers_1.Long.fromValue(object.id) : helpers_1.Long.ZERO,
	            accountId: (0, helpers_1.isSet)(object.accountId) ? helpers_1.Long.fromValue(object.accountId) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.id !== undefined && (obj.id = (message.id || helpers_1.Long.ZERO).toString());
	        message.accountId !== undefined && (obj.accountId = (message.accountId || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountAddressByIDRequest();
	        message.id = object.id !== undefined && object.id !== null ? helpers_1.Long.fromValue(object.id) : helpers_1.Long.ZERO;
	        message.accountId = object.accountId !== undefined && object.accountId !== null ? helpers_1.Long.fromValue(object.accountId) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            id: object?.id,
	            accountId: object?.account_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.id = message.id;
	        obj.account_id = message.accountId;
	        return obj;
	    }
	};
	function createBaseQueryAccountAddressByIDResponse() {
	    return {
	        accountAddress: ""
	    };
	}
	exports.QueryAccountAddressByIDResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.accountAddress !== "") {
	            writer.uint32(10).string(message.accountAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountAddressByIDResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.accountAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            accountAddress: (0, helpers_1.isSet)(object.accountAddress) ? String(object.accountAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountAddressByIDResponse();
	        message.accountAddress = object.accountAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            accountAddress: object?.account_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.account_address = message.accountAddress;
	        return obj;
	    }
	};
	function createBaseQueryAccountInfoRequest() {
	    return {
	        address: ""
	    };
	}
	exports.QueryAccountInfoRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountInfoRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountInfoRequest();
	        message.address = object.address ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        return obj;
	    }
	};
	function createBaseQueryAccountInfoResponse() {
	    return {
	        info: undefined
	    };
	}
	exports.QueryAccountInfoResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.info !== undefined) {
	            auth_1.BaseAccount.encode(message.info, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAccountInfoResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.info = auth_1.BaseAccount.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            info: (0, helpers_1.isSet)(object.info) ? auth_1.BaseAccount.fromJSON(object.info) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.info !== undefined && (obj.info = message.info ? auth_1.BaseAccount.toJSON(message.info) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAccountInfoResponse();
	        message.info = object.info !== undefined && object.info !== null ? auth_1.BaseAccount.fromPartial(object.info) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            info: object.info ? auth_1.BaseAccount.fromSDK(object.info) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.info !== undefined && (obj.info = message.info ? auth_1.BaseAccount.toSDK(message.info) : undefined);
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Accounts = this.Accounts.bind(this);
	        this.Account = this.Account.bind(this);
	        this.AccountAddressByID = this.AccountAddressByID.bind(this);
	        this.Params = this.Params.bind(this);
	        this.ModuleAccounts = this.ModuleAccounts.bind(this);
	        this.ModuleAccountByName = this.ModuleAccountByName.bind(this);
	        this.AccountInfo = this.AccountInfo.bind(this);
	    }
	    Accounts(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryAccountsRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);
	        return promise.then(data => exports.QueryAccountsResponse.decode(new _m0.Reader(data)));
	    }
	    Account(request) {
	        const data = exports.QueryAccountRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data);
	        return promise.then(data => exports.QueryAccountResponse.decode(new _m0.Reader(data)));
	    }
	    AccountAddressByID(request) {
	        const data = exports.QueryAccountAddressByIDRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", data);
	        return promise.then(data => exports.QueryAccountAddressByIDResponse.decode(new _m0.Reader(data)));
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    ModuleAccounts(request = {}) {
	        const data = exports.QueryModuleAccountsRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", data);
	        return promise.then(data => exports.QueryModuleAccountsResponse.decode(new _m0.Reader(data)));
	    }
	    ModuleAccountByName(request) {
	        const data = exports.QueryModuleAccountByNameRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", data);
	        return promise.then(data => exports.QueryModuleAccountByNameResponse.decode(new _m0.Reader(data)));
	    }
	    AccountInfo(request) {
	        const data = exports.QueryAccountInfoRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", data);
	        return promise.then(data => exports.QueryAccountInfoResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$9));

query$9.default;

var query$8 = {};

var coin = {};

var __createBinding$i = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$i = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$i = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$i(result, mod, k);
    __setModuleDefault$i(result, mod);
    return result;
};
Object.defineProperty(coin, "__esModule", { value: true });
coin.DecProto = coin.IntProto = coin.DecCoin = coin.Coin = coin.protobufPackage = void 0;
/* eslint-disable */
const _m0$i = __importStar$i(minimal$1.exports);
const helpers_1$i = helpers;
coin.protobufPackage = "cosmos.base.v1beta1";
function createBaseCoin() {
    return {
        denom: "",
        amount: ""
    };
}
coin.Coin = {
    encode(message, writer = _m0$i.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$i.Reader ? input : new _m0$i.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: (0, helpers_1$i.isSet)(object.denom) ? String(object.denom) : "",
            amount: (0, helpers_1$i.isSet)(object.amount) ? String(object.amount) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            denom: object?.denom,
            amount: object?.amount
        };
    },
    toSDK(message) {
        const obj = {};
        obj.denom = message.denom;
        obj.amount = message.amount;
        return obj;
    }
};
function createBaseDecCoin() {
    return {
        denom: "",
        amount: ""
    };
}
coin.DecCoin = {
    encode(message, writer = _m0$i.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$i.Reader ? input : new _m0$i.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: (0, helpers_1$i.isSet)(object.denom) ? String(object.denom) : "",
            amount: (0, helpers_1$i.isSet)(object.amount) ? String(object.amount) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDecCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            denom: object?.denom,
            amount: object?.amount
        };
    },
    toSDK(message) {
        const obj = {};
        obj.denom = message.denom;
        obj.amount = message.amount;
        return obj;
    }
};
function createBaseIntProto() {
    return {
        int: ""
    };
}
coin.IntProto = {
    encode(message, writer = _m0$i.Writer.create()) {
        if (message.int !== "") {
            writer.uint32(10).string(message.int);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$i.Reader ? input : new _m0$i.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.int = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            int: (0, helpers_1$i.isSet)(object.int) ? String(object.int) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.int !== undefined && (obj.int = message.int);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseIntProto();
        message.int = object.int ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            int: object?.int
        };
    },
    toSDK(message) {
        const obj = {};
        obj.int = message.int;
        return obj;
    }
};
function createBaseDecProto() {
    return {
        dec: ""
    };
}
coin.DecProto = {
    encode(message, writer = _m0$i.Writer.create()) {
        if (message.dec !== "") {
            writer.uint32(10).string(message.dec);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$i.Reader ? input : new _m0$i.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dec = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            dec: (0, helpers_1$i.isSet)(object.dec) ? String(object.dec) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.dec !== undefined && (obj.dec = message.dec);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDecProto();
        message.dec = object.dec ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            dec: object?.dec
        };
    },
    toSDK(message) {
        const obj = {};
        obj.dec = message.dec;
        return obj;
    }
};

var bank = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Metadata = exports.DenomUnit = exports.Supply = exports.Output = exports.Input = exports.SendEnabled = exports.Params = exports.protobufPackage = void 0;
	/* eslint-disable */
	const coin_1 = coin;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.bank.v1beta1";
	function createBaseParams() {
	    return {
	        sendEnabled: [],
	        defaultSendEnabled: false
	    };
	}
	exports.Params = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.sendEnabled) {
	            exports.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.defaultSendEnabled === true) {
	            writer.uint32(16).bool(message.defaultSendEnabled);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.sendEnabled.push(exports.SendEnabled.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.defaultSendEnabled = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            sendEnabled: Array.isArray(object?.sendEnabled) ? object.sendEnabled.map((e) => exports.SendEnabled.fromJSON(e)) : [],
	            defaultSendEnabled: (0, helpers_1.isSet)(object.defaultSendEnabled) ? Boolean(object.defaultSendEnabled) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.sendEnabled) {
	            obj.sendEnabled = message.sendEnabled.map(e => e ? exports.SendEnabled.toJSON(e) : undefined);
	        }
	        else {
	            obj.sendEnabled = [];
	        }
	        message.defaultSendEnabled !== undefined && (obj.defaultSendEnabled = message.defaultSendEnabled);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseParams();
	        message.sendEnabled = object.sendEnabled?.map(e => exports.SendEnabled.fromPartial(e)) || [];
	        message.defaultSendEnabled = object.defaultSendEnabled ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            sendEnabled: Array.isArray(object?.send_enabled) ? object.send_enabled.map((e) => exports.SendEnabled.fromSDK(e)) : [],
	            defaultSendEnabled: object?.default_send_enabled
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.sendEnabled) {
	            obj.send_enabled = message.sendEnabled.map(e => e ? exports.SendEnabled.toSDK(e) : undefined);
	        }
	        else {
	            obj.send_enabled = [];
	        }
	        obj.default_send_enabled = message.defaultSendEnabled;
	        return obj;
	    }
	};
	function createBaseSendEnabled() {
	    return {
	        denom: "",
	        enabled: false
	    };
	}
	exports.SendEnabled = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.denom !== "") {
	            writer.uint32(10).string(message.denom);
	        }
	        if (message.enabled === true) {
	            writer.uint32(16).bool(message.enabled);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSendEnabled();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.denom = reader.string();
	                    break;
	                case 2:
	                    message.enabled = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            denom: (0, helpers_1.isSet)(object.denom) ? String(object.denom) : "",
	            enabled: (0, helpers_1.isSet)(object.enabled) ? Boolean(object.enabled) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.denom !== undefined && (obj.denom = message.denom);
	        message.enabled !== undefined && (obj.enabled = message.enabled);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSendEnabled();
	        message.denom = object.denom ?? "";
	        message.enabled = object.enabled ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            denom: object?.denom,
	            enabled: object?.enabled
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.denom = message.denom;
	        obj.enabled = message.enabled;
	        return obj;
	    }
	};
	function createBaseInput() {
	    return {
	        address: "",
	        coins: []
	    };
	}
	exports.Input = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        for (const v of message.coins) {
	            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseInput();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            coins: Array.isArray(object?.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        if (message.coins) {
	            obj.coins = message.coins.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.coins = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseInput();
	        message.address = object.address ?? "";
	        message.coins = object.coins?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            coins: Array.isArray(object?.coins) ? object.coins.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        if (message.coins) {
	            obj.coins = message.coins.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.coins = [];
	        }
	        return obj;
	    }
	};
	function createBaseOutput() {
	    return {
	        address: "",
	        coins: []
	    };
	}
	exports.Output = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        for (const v of message.coins) {
	            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseOutput();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            coins: Array.isArray(object?.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        if (message.coins) {
	            obj.coins = message.coins.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.coins = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseOutput();
	        message.address = object.address ?? "";
	        message.coins = object.coins?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            coins: Array.isArray(object?.coins) ? object.coins.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        if (message.coins) {
	            obj.coins = message.coins.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.coins = [];
	        }
	        return obj;
	    }
	};
	function createBaseSupply() {
	    return {
	        total: []
	    };
	}
	exports.Supply = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.total) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSupply();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            total: Array.isArray(object?.total) ? object.total.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.total) {
	            obj.total = message.total.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.total = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSupply();
	        message.total = object.total?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            total: Array.isArray(object?.total) ? object.total.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.total) {
	            obj.total = message.total.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.total = [];
	        }
	        return obj;
	    }
	};
	function createBaseDenomUnit() {
	    return {
	        denom: "",
	        exponent: 0,
	        aliases: []
	    };
	}
	exports.DenomUnit = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.denom !== "") {
	            writer.uint32(10).string(message.denom);
	        }
	        if (message.exponent !== 0) {
	            writer.uint32(16).uint32(message.exponent);
	        }
	        for (const v of message.aliases) {
	            writer.uint32(26).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDenomUnit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.denom = reader.string();
	                    break;
	                case 2:
	                    message.exponent = reader.uint32();
	                    break;
	                case 3:
	                    message.aliases.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            denom: (0, helpers_1.isSet)(object.denom) ? String(object.denom) : "",
	            exponent: (0, helpers_1.isSet)(object.exponent) ? Number(object.exponent) : 0,
	            aliases: Array.isArray(object?.aliases) ? object.aliases.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.denom !== undefined && (obj.denom = message.denom);
	        message.exponent !== undefined && (obj.exponent = Math.round(message.exponent));
	        if (message.aliases) {
	            obj.aliases = message.aliases.map(e => e);
	        }
	        else {
	            obj.aliases = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDenomUnit();
	        message.denom = object.denom ?? "";
	        message.exponent = object.exponent ?? 0;
	        message.aliases = object.aliases?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            denom: object?.denom,
	            exponent: object?.exponent,
	            aliases: Array.isArray(object?.aliases) ? object.aliases.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.denom = message.denom;
	        obj.exponent = message.exponent;
	        if (message.aliases) {
	            obj.aliases = message.aliases.map(e => e);
	        }
	        else {
	            obj.aliases = [];
	        }
	        return obj;
	    }
	};
	function createBaseMetadata() {
	    return {
	        description: "",
	        denomUnits: [],
	        base: "",
	        display: "",
	        name: "",
	        symbol: "",
	        uri: "",
	        uriHash: ""
	    };
	}
	exports.Metadata = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.description !== "") {
	            writer.uint32(10).string(message.description);
	        }
	        for (const v of message.denomUnits) {
	            exports.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.base !== "") {
	            writer.uint32(26).string(message.base);
	        }
	        if (message.display !== "") {
	            writer.uint32(34).string(message.display);
	        }
	        if (message.name !== "") {
	            writer.uint32(42).string(message.name);
	        }
	        if (message.symbol !== "") {
	            writer.uint32(50).string(message.symbol);
	        }
	        if (message.uri !== "") {
	            writer.uint32(58).string(message.uri);
	        }
	        if (message.uriHash !== "") {
	            writer.uint32(66).string(message.uriHash);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMetadata();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.description = reader.string();
	                    break;
	                case 2:
	                    message.denomUnits.push(exports.DenomUnit.decode(reader, reader.uint32()));
	                    break;
	                case 3:
	                    message.base = reader.string();
	                    break;
	                case 4:
	                    message.display = reader.string();
	                    break;
	                case 5:
	                    message.name = reader.string();
	                    break;
	                case 6:
	                    message.symbol = reader.string();
	                    break;
	                case 7:
	                    message.uri = reader.string();
	                    break;
	                case 8:
	                    message.uriHash = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
	            denomUnits: Array.isArray(object?.denomUnits) ? object.denomUnits.map((e) => exports.DenomUnit.fromJSON(e)) : [],
	            base: (0, helpers_1.isSet)(object.base) ? String(object.base) : "",
	            display: (0, helpers_1.isSet)(object.display) ? String(object.display) : "",
	            name: (0, helpers_1.isSet)(object.name) ? String(object.name) : "",
	            symbol: (0, helpers_1.isSet)(object.symbol) ? String(object.symbol) : "",
	            uri: (0, helpers_1.isSet)(object.uri) ? String(object.uri) : "",
	            uriHash: (0, helpers_1.isSet)(object.uriHash) ? String(object.uriHash) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.description !== undefined && (obj.description = message.description);
	        if (message.denomUnits) {
	            obj.denomUnits = message.denomUnits.map(e => e ? exports.DenomUnit.toJSON(e) : undefined);
	        }
	        else {
	            obj.denomUnits = [];
	        }
	        message.base !== undefined && (obj.base = message.base);
	        message.display !== undefined && (obj.display = message.display);
	        message.name !== undefined && (obj.name = message.name);
	        message.symbol !== undefined && (obj.symbol = message.symbol);
	        message.uri !== undefined && (obj.uri = message.uri);
	        message.uriHash !== undefined && (obj.uriHash = message.uriHash);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMetadata();
	        message.description = object.description ?? "";
	        message.denomUnits = object.denomUnits?.map(e => exports.DenomUnit.fromPartial(e)) || [];
	        message.base = object.base ?? "";
	        message.display = object.display ?? "";
	        message.name = object.name ?? "";
	        message.symbol = object.symbol ?? "";
	        message.uri = object.uri ?? "";
	        message.uriHash = object.uriHash ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            description: object?.description,
	            denomUnits: Array.isArray(object?.denom_units) ? object.denom_units.map((e) => exports.DenomUnit.fromSDK(e)) : [],
	            base: object?.base,
	            display: object?.display,
	            name: object?.name,
	            symbol: object?.symbol,
	            uri: object?.uri,
	            uriHash: object?.uri_hash
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.description = message.description;
	        if (message.denomUnits) {
	            obj.denom_units = message.denomUnits.map(e => e ? exports.DenomUnit.toSDK(e) : undefined);
	        }
	        else {
	            obj.denom_units = [];
	        }
	        obj.base = message.base;
	        obj.display = message.display;
	        obj.name = message.name;
	        obj.symbol = message.symbol;
	        obj.uri = message.uri;
	        obj.uri_hash = message.uriHash;
	        return obj;
	    }
	};
	
} (bank));

bank.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QuerySendEnabledResponse = exports.QuerySendEnabledRequest = exports.QueryDenomOwnersResponse = exports.DenomOwner = exports.QueryDenomOwnersRequest = exports.QueryDenomMetadataResponse = exports.QueryDenomMetadataRequest = exports.QueryDenomsMetadataResponse = exports.QueryDenomsMetadataRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QuerySupplyOfResponse = exports.QuerySupplyOfRequest = exports.QueryTotalSupplyResponse = exports.QueryTotalSupplyRequest = exports.QuerySpendableBalanceByDenomResponse = exports.QuerySpendableBalanceByDenomRequest = exports.QuerySpendableBalancesResponse = exports.QuerySpendableBalancesRequest = exports.QueryAllBalancesResponse = exports.QueryAllBalancesRequest = exports.QueryBalanceResponse = exports.QueryBalanceRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const pagination_1 = pagination;
	const coin_1 = coin;
	const bank_1 = bank;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.bank.v1beta1";
	function createBaseQueryBalanceRequest() {
	    return {
	        address: "",
	        denom: ""
	    };
	}
	exports.QueryBalanceRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.denom !== "") {
	            writer.uint32(18).string(message.denom);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryBalanceRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.denom = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            denom: (0, helpers_1.isSet)(object.denom) ? String(object.denom) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.denom !== undefined && (obj.denom = message.denom);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryBalanceRequest();
	        message.address = object.address ?? "";
	        message.denom = object.denom ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            denom: object?.denom
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        obj.denom = message.denom;
	        return obj;
	    }
	};
	function createBaseQueryBalanceResponse() {
	    return {
	        balance: undefined
	    };
	}
	exports.QueryBalanceResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.balance !== undefined) {
	            coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryBalanceResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            balance: (0, helpers_1.isSet)(object.balance) ? coin_1.Coin.fromJSON(object.balance) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryBalanceResponse();
	        message.balance = object.balance !== undefined && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            balance: object.balance ? coin_1.Coin.fromSDK(object.balance) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toSDK(message.balance) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllBalancesRequest() {
	    return {
	        address: "",
	        pagination: undefined
	    };
	}
	exports.QueryAllBalancesRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllBalancesRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllBalancesRequest();
	        message.address = object.address ?? "";
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllBalancesResponse() {
	    return {
	        balances: [],
	        pagination: undefined
	    };
	}
	exports.QueryAllBalancesResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.balances) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllBalancesResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            balances: Array.isArray(object?.balances) ? object.balances.map((e) => coin_1.Coin.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.balances) {
	            obj.balances = message.balances.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.balances = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllBalancesResponse();
	        message.balances = object.balances?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            balances: Array.isArray(object?.balances) ? object.balances.map((e) => coin_1.Coin.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.balances) {
	            obj.balances = message.balances.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.balances = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQuerySpendableBalancesRequest() {
	    return {
	        address: "",
	        pagination: undefined
	    };
	}
	exports.QuerySpendableBalancesRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySpendableBalancesRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySpendableBalancesRequest();
	        message.address = object.address ?? "";
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQuerySpendableBalancesResponse() {
	    return {
	        balances: [],
	        pagination: undefined
	    };
	}
	exports.QuerySpendableBalancesResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.balances) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySpendableBalancesResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            balances: Array.isArray(object?.balances) ? object.balances.map((e) => coin_1.Coin.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.balances) {
	            obj.balances = message.balances.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.balances = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySpendableBalancesResponse();
	        message.balances = object.balances?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            balances: Array.isArray(object?.balances) ? object.balances.map((e) => coin_1.Coin.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.balances) {
	            obj.balances = message.balances.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.balances = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQuerySpendableBalanceByDenomRequest() {
	    return {
	        address: "",
	        denom: ""
	    };
	}
	exports.QuerySpendableBalanceByDenomRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.denom !== "") {
	            writer.uint32(18).string(message.denom);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySpendableBalanceByDenomRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.denom = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            denom: (0, helpers_1.isSet)(object.denom) ? String(object.denom) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.denom !== undefined && (obj.denom = message.denom);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySpendableBalanceByDenomRequest();
	        message.address = object.address ?? "";
	        message.denom = object.denom ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            denom: object?.denom
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        obj.denom = message.denom;
	        return obj;
	    }
	};
	function createBaseQuerySpendableBalanceByDenomResponse() {
	    return {
	        balance: undefined
	    };
	}
	exports.QuerySpendableBalanceByDenomResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.balance !== undefined) {
	            coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySpendableBalanceByDenomResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            balance: (0, helpers_1.isSet)(object.balance) ? coin_1.Coin.fromJSON(object.balance) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySpendableBalanceByDenomResponse();
	        message.balance = object.balance !== undefined && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            balance: object.balance ? coin_1.Coin.fromSDK(object.balance) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toSDK(message.balance) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryTotalSupplyRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryTotalSupplyRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryTotalSupplyRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryTotalSupplyRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryTotalSupplyResponse() {
	    return {
	        supply: [],
	        pagination: undefined
	    };
	}
	exports.QueryTotalSupplyResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.supply) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryTotalSupplyResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.supply.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            supply: Array.isArray(object?.supply) ? object.supply.map((e) => coin_1.Coin.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.supply) {
	            obj.supply = message.supply.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.supply = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryTotalSupplyResponse();
	        message.supply = object.supply?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            supply: Array.isArray(object?.supply) ? object.supply.map((e) => coin_1.Coin.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.supply) {
	            obj.supply = message.supply.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.supply = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQuerySupplyOfRequest() {
	    return {
	        denom: ""
	    };
	}
	exports.QuerySupplyOfRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.denom !== "") {
	            writer.uint32(10).string(message.denom);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySupplyOfRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.denom = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            denom: (0, helpers_1.isSet)(object.denom) ? String(object.denom) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.denom !== undefined && (obj.denom = message.denom);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySupplyOfRequest();
	        message.denom = object.denom ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            denom: object?.denom
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.denom = message.denom;
	        return obj;
	    }
	};
	function createBaseQuerySupplyOfResponse() {
	    return {
	        amount: undefined
	    };
	}
	exports.QuerySupplyOfResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.amount !== undefined) {
	            coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySupplyOfResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            amount: (0, helpers_1.isSet)(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySupplyOfResponse();
	        message.amount = object.amount !== undefined && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            amount: object.amount ? coin_1.Coin.fromSDK(object.amount) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toSDK(message.amount) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            bank_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = bank_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? bank_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? bank_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? bank_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? bank_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryDenomsMetadataRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryDenomsMetadataRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDenomsMetadataRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDenomsMetadataRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryDenomsMetadataResponse() {
	    return {
	        metadatas: [],
	        pagination: undefined
	    };
	}
	exports.QueryDenomsMetadataResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.metadatas) {
	            bank_1.Metadata.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDenomsMetadataResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.metadatas.push(bank_1.Metadata.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            metadatas: Array.isArray(object?.metadatas) ? object.metadatas.map((e) => bank_1.Metadata.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.metadatas) {
	            obj.metadatas = message.metadatas.map(e => e ? bank_1.Metadata.toJSON(e) : undefined);
	        }
	        else {
	            obj.metadatas = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDenomsMetadataResponse();
	        message.metadatas = object.metadatas?.map(e => bank_1.Metadata.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            metadatas: Array.isArray(object?.metadatas) ? object.metadatas.map((e) => bank_1.Metadata.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.metadatas) {
	            obj.metadatas = message.metadatas.map(e => e ? bank_1.Metadata.toSDK(e) : undefined);
	        }
	        else {
	            obj.metadatas = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryDenomMetadataRequest() {
	    return {
	        denom: ""
	    };
	}
	exports.QueryDenomMetadataRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.denom !== "") {
	            writer.uint32(10).string(message.denom);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDenomMetadataRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.denom = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            denom: (0, helpers_1.isSet)(object.denom) ? String(object.denom) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.denom !== undefined && (obj.denom = message.denom);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDenomMetadataRequest();
	        message.denom = object.denom ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            denom: object?.denom
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.denom = message.denom;
	        return obj;
	    }
	};
	function createBaseQueryDenomMetadataResponse() {
	    return {
	        metadata: undefined
	    };
	}
	exports.QueryDenomMetadataResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.metadata !== undefined) {
	            bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDenomMetadataResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            metadata: (0, helpers_1.isSet)(object.metadata) ? bank_1.Metadata.fromJSON(object.metadata) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.metadata !== undefined && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDenomMetadataResponse();
	        message.metadata = object.metadata !== undefined && object.metadata !== null ? bank_1.Metadata.fromPartial(object.metadata) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            metadata: object.metadata ? bank_1.Metadata.fromSDK(object.metadata) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.metadata !== undefined && (obj.metadata = message.metadata ? bank_1.Metadata.toSDK(message.metadata) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryDenomOwnersRequest() {
	    return {
	        denom: "",
	        pagination: undefined
	    };
	}
	exports.QueryDenomOwnersRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.denom !== "") {
	            writer.uint32(10).string(message.denom);
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDenomOwnersRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.denom = reader.string();
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            denom: (0, helpers_1.isSet)(object.denom) ? String(object.denom) : "",
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.denom !== undefined && (obj.denom = message.denom);
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDenomOwnersRequest();
	        message.denom = object.denom ?? "";
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            denom: object?.denom,
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.denom = message.denom;
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseDenomOwner() {
	    return {
	        address: "",
	        balance: undefined
	    };
	}
	exports.DenomOwner = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.balance !== undefined) {
	            coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDenomOwner();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            balance: (0, helpers_1.isSet)(object.balance) ? coin_1.Coin.fromJSON(object.balance) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDenomOwner();
	        message.address = object.address ?? "";
	        message.balance = object.balance !== undefined && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            balance: object.balance ? coin_1.Coin.fromSDK(object.balance) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toSDK(message.balance) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryDenomOwnersResponse() {
	    return {
	        denomOwners: [],
	        pagination: undefined
	    };
	}
	exports.QueryDenomOwnersResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.denomOwners) {
	            exports.DenomOwner.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDenomOwnersResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.denomOwners.push(exports.DenomOwner.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            denomOwners: Array.isArray(object?.denomOwners) ? object.denomOwners.map((e) => exports.DenomOwner.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.denomOwners) {
	            obj.denomOwners = message.denomOwners.map(e => e ? exports.DenomOwner.toJSON(e) : undefined);
	        }
	        else {
	            obj.denomOwners = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDenomOwnersResponse();
	        message.denomOwners = object.denomOwners?.map(e => exports.DenomOwner.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            denomOwners: Array.isArray(object?.denom_owners) ? object.denom_owners.map((e) => exports.DenomOwner.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.denomOwners) {
	            obj.denom_owners = message.denomOwners.map(e => e ? exports.DenomOwner.toSDK(e) : undefined);
	        }
	        else {
	            obj.denom_owners = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQuerySendEnabledRequest() {
	    return {
	        denoms: [],
	        pagination: undefined
	    };
	}
	exports.QuerySendEnabledRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.denoms) {
	            writer.uint32(10).string(v);
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(794).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySendEnabledRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.denoms.push(reader.string());
	                    break;
	                case 99:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            denoms: Array.isArray(object?.denoms) ? object.denoms.map((e) => String(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.denoms) {
	            obj.denoms = message.denoms.map(e => e);
	        }
	        else {
	            obj.denoms = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySendEnabledRequest();
	        message.denoms = object.denoms?.map(e => e) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            denoms: Array.isArray(object?.denoms) ? object.denoms.map((e) => e) : [],
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.denoms) {
	            obj.denoms = message.denoms.map(e => e);
	        }
	        else {
	            obj.denoms = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQuerySendEnabledResponse() {
	    return {
	        sendEnabled: [],
	        pagination: undefined
	    };
	}
	exports.QuerySendEnabledResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.sendEnabled) {
	            bank_1.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(794).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySendEnabledResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
	                    break;
	                case 99:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            sendEnabled: Array.isArray(object?.sendEnabled) ? object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.sendEnabled) {
	            obj.sendEnabled = message.sendEnabled.map(e => e ? bank_1.SendEnabled.toJSON(e) : undefined);
	        }
	        else {
	            obj.sendEnabled = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySendEnabledResponse();
	        message.sendEnabled = object.sendEnabled?.map(e => bank_1.SendEnabled.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            sendEnabled: Array.isArray(object?.send_enabled) ? object.send_enabled.map((e) => bank_1.SendEnabled.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.sendEnabled) {
	            obj.send_enabled = message.sendEnabled.map(e => e ? bank_1.SendEnabled.toSDK(e) : undefined);
	        }
	        else {
	            obj.send_enabled = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Balance = this.Balance.bind(this);
	        this.AllBalances = this.AllBalances.bind(this);
	        this.SpendableBalances = this.SpendableBalances.bind(this);
	        this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this);
	        this.TotalSupply = this.TotalSupply.bind(this);
	        this.SupplyOf = this.SupplyOf.bind(this);
	        this.Params = this.Params.bind(this);
	        this.DenomMetadata = this.DenomMetadata.bind(this);
	        this.DenomsMetadata = this.DenomsMetadata.bind(this);
	        this.DenomOwners = this.DenomOwners.bind(this);
	        this.SendEnabled = this.SendEnabled.bind(this);
	    }
	    Balance(request) {
	        const data = exports.QueryBalanceRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", data);
	        return promise.then(data => exports.QueryBalanceResponse.decode(new _m0.Reader(data)));
	    }
	    AllBalances(request) {
	        const data = exports.QueryAllBalancesRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", data);
	        return promise.then(data => exports.QueryAllBalancesResponse.decode(new _m0.Reader(data)));
	    }
	    SpendableBalances(request) {
	        const data = exports.QuerySpendableBalancesRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", data);
	        return promise.then(data => exports.QuerySpendableBalancesResponse.decode(new _m0.Reader(data)));
	    }
	    SpendableBalanceByDenom(request) {
	        const data = exports.QuerySpendableBalanceByDenomRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", data);
	        return promise.then(data => exports.QuerySpendableBalanceByDenomResponse.decode(new _m0.Reader(data)));
	    }
	    TotalSupply(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryTotalSupplyRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", data);
	        return promise.then(data => exports.QueryTotalSupplyResponse.decode(new _m0.Reader(data)));
	    }
	    SupplyOf(request) {
	        const data = exports.QuerySupplyOfRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", data);
	        return promise.then(data => exports.QuerySupplyOfResponse.decode(new _m0.Reader(data)));
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    DenomMetadata(request) {
	        const data = exports.QueryDenomMetadataRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", data);
	        return promise.then(data => exports.QueryDenomMetadataResponse.decode(new _m0.Reader(data)));
	    }
	    DenomsMetadata(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryDenomsMetadataRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", data);
	        return promise.then(data => exports.QueryDenomsMetadataResponse.decode(new _m0.Reader(data)));
	    }
	    DenomOwners(request) {
	        const data = exports.QueryDenomOwnersRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", data);
	        return promise.then(data => exports.QueryDenomOwnersResponse.decode(new _m0.Reader(data)));
	    }
	    SendEnabled(request) {
	        const data = exports.QuerySendEnabledRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", data);
	        return promise.then(data => exports.QuerySendEnabledResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$8));

query$8.default;

var tx$8 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgSetSendEnabledResponse = exports.MsgSetSendEnabled = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgMultiSendResponse = exports.MsgMultiSend = exports.MsgSendResponse = exports.MsgSend = exports.protobufPackage = void 0;
	/* eslint-disable */
	const coin_1 = coin;
	const bank_1 = bank;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.bank.v1beta1";
	function createBaseMsgSend() {
	    return {
	        fromAddress: "",
	        toAddress: "",
	        amount: []
	    };
	}
	exports.MsgSend = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.fromAddress !== "") {
	            writer.uint32(10).string(message.fromAddress);
	        }
	        if (message.toAddress !== "") {
	            writer.uint32(18).string(message.toAddress);
	        }
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSend();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.fromAddress = reader.string();
	                    break;
	                case 2:
	                    message.toAddress = reader.string();
	                    break;
	                case 3:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            fromAddress: (0, helpers_1.isSet)(object.fromAddress) ? String(object.fromAddress) : "",
	            toAddress: (0, helpers_1.isSet)(object.toAddress) ? String(object.toAddress) : "",
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);
	        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgSend();
	        message.fromAddress = object.fromAddress ?? "";
	        message.toAddress = object.toAddress ?? "";
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            fromAddress: object?.from_address,
	            toAddress: object?.to_address,
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.from_address = message.fromAddress;
	        obj.to_address = message.toAddress;
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgSendResponse() {
	    return {};
	}
	exports.MsgSendResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSendResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgSendResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgMultiSend() {
	    return {
	        inputs: [],
	        outputs: []
	    };
	}
	exports.MsgMultiSend = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.inputs) {
	            bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        for (const v of message.outputs) {
	            bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMultiSend();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            inputs: Array.isArray(object?.inputs) ? object.inputs.map((e) => bank_1.Input.fromJSON(e)) : [],
	            outputs: Array.isArray(object?.outputs) ? object.outputs.map((e) => bank_1.Output.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.inputs) {
	            obj.inputs = message.inputs.map(e => e ? bank_1.Input.toJSON(e) : undefined);
	        }
	        else {
	            obj.inputs = [];
	        }
	        if (message.outputs) {
	            obj.outputs = message.outputs.map(e => e ? bank_1.Output.toJSON(e) : undefined);
	        }
	        else {
	            obj.outputs = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgMultiSend();
	        message.inputs = object.inputs?.map(e => bank_1.Input.fromPartial(e)) || [];
	        message.outputs = object.outputs?.map(e => bank_1.Output.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            inputs: Array.isArray(object?.inputs) ? object.inputs.map((e) => bank_1.Input.fromSDK(e)) : [],
	            outputs: Array.isArray(object?.outputs) ? object.outputs.map((e) => bank_1.Output.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.inputs) {
	            obj.inputs = message.inputs.map(e => e ? bank_1.Input.toSDK(e) : undefined);
	        }
	        else {
	            obj.inputs = [];
	        }
	        if (message.outputs) {
	            obj.outputs = message.outputs.map(e => e ? bank_1.Output.toSDK(e) : undefined);
	        }
	        else {
	            obj.outputs = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgMultiSendResponse() {
	    return {};
	}
	exports.MsgMultiSendResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMultiSendResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgMultiSendResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            bank_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = bank_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? bank_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? bank_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? bank_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? bank_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgSetSendEnabled() {
	    return {
	        authority: "",
	        sendEnabled: [],
	        useDefaultFor: []
	    };
	}
	exports.MsgSetSendEnabled = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        for (const v of message.sendEnabled) {
	            bank_1.SendEnabled.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        for (const v of message.useDefaultFor) {
	            writer.uint32(26).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSetSendEnabled();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
	                    break;
	                case 3:
	                    message.useDefaultFor.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            sendEnabled: Array.isArray(object?.sendEnabled) ? object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e)) : [],
	            useDefaultFor: Array.isArray(object?.useDefaultFor) ? object.useDefaultFor.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        if (message.sendEnabled) {
	            obj.sendEnabled = message.sendEnabled.map(e => e ? bank_1.SendEnabled.toJSON(e) : undefined);
	        }
	        else {
	            obj.sendEnabled = [];
	        }
	        if (message.useDefaultFor) {
	            obj.useDefaultFor = message.useDefaultFor.map(e => e);
	        }
	        else {
	            obj.useDefaultFor = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgSetSendEnabled();
	        message.authority = object.authority ?? "";
	        message.sendEnabled = object.sendEnabled?.map(e => bank_1.SendEnabled.fromPartial(e)) || [];
	        message.useDefaultFor = object.useDefaultFor?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            sendEnabled: Array.isArray(object?.send_enabled) ? object.send_enabled.map((e) => bank_1.SendEnabled.fromSDK(e)) : [],
	            useDefaultFor: Array.isArray(object?.use_default_for) ? object.use_default_for.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        if (message.sendEnabled) {
	            obj.send_enabled = message.sendEnabled.map(e => e ? bank_1.SendEnabled.toSDK(e) : undefined);
	        }
	        else {
	            obj.send_enabled = [];
	        }
	        if (message.useDefaultFor) {
	            obj.use_default_for = message.useDefaultFor.map(e => e);
	        }
	        else {
	            obj.use_default_for = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgSetSendEnabledResponse() {
	    return {};
	}
	exports.MsgSetSendEnabledResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSetSendEnabledResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgSetSendEnabledResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Send = this.Send.bind(this);
	        this.MultiSend = this.MultiSend.bind(this);
	        this.UpdateParams = this.UpdateParams.bind(this);
	        this.SetSendEnabled = this.SetSendEnabled.bind(this);
	    }
	    Send(request) {
	        const data = exports.MsgSend.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", data);
	        return promise.then(data => exports.MsgSendResponse.decode(new _m0.Reader(data)));
	    }
	    MultiSend(request) {
	        const data = exports.MsgMultiSend.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", data);
	        return promise.then(data => exports.MsgMultiSendResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	    SetSendEnabled(request) {
	        const data = exports.MsgSetSendEnabled.encode(request).finish();
	        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", data);
	        return promise.then(data => exports.MsgSetSendEnabledResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx$8));

tx$8.default;

const MsgMultiSendSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from_address"
    },
    {
      "type": "string",
      "name": "to_address"
    },
    {
      "type": "TypeAmount[]",
      "name": "amount"
    },
    {
      "type": "InputSDKType[]",
      "name": "inputs"
    },
    {
      "type": "OutputSDKType[]",
      "name": "outputs"
    }
  ]
};

const MsgCreatePaymentAccountSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

var query$7 = {};

var params$5 = {};

var __createBinding$h = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$h = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$h = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$h(result, mod, k);
    __setModuleDefault$h(result, mod);
    return result;
};
Object.defineProperty(params$5, "__esModule", { value: true });
params$5.Params = params$5.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$h = helpers;
const _m0$h = __importStar$h(minimal$1.exports);
params$5.protobufPackage = "greenfield.payment";
function createBaseParams$5() {
    return {
        reserveTime: helpers_1$h.Long.UZERO,
        paymentAccountCountLimit: helpers_1$h.Long.UZERO,
        forcedSettleTime: helpers_1$h.Long.UZERO,
        maxAutoForceSettleNum: helpers_1$h.Long.UZERO,
        feeDenom: "",
        validatorTaxRate: ""
    };
}
params$5.Params = {
    encode(message, writer = _m0$h.Writer.create()) {
        if (!message.reserveTime.isZero()) {
            writer.uint32(8).uint64(message.reserveTime);
        }
        if (!message.paymentAccountCountLimit.isZero()) {
            writer.uint32(16).uint64(message.paymentAccountCountLimit);
        }
        if (!message.forcedSettleTime.isZero()) {
            writer.uint32(24).uint64(message.forcedSettleTime);
        }
        if (!message.maxAutoForceSettleNum.isZero()) {
            writer.uint32(32).uint64(message.maxAutoForceSettleNum);
        }
        if (message.feeDenom !== "") {
            writer.uint32(42).string(message.feeDenom);
        }
        if (message.validatorTaxRate !== "") {
            writer.uint32(50).string(message.validatorTaxRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$h.Reader ? input : new _m0$h.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$5();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reserveTime = reader.uint64();
                    break;
                case 2:
                    message.paymentAccountCountLimit = reader.uint64();
                    break;
                case 3:
                    message.forcedSettleTime = reader.uint64();
                    break;
                case 4:
                    message.maxAutoForceSettleNum = reader.uint64();
                    break;
                case 5:
                    message.feeDenom = reader.string();
                    break;
                case 6:
                    message.validatorTaxRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            reserveTime: (0, helpers_1$h.isSet)(object.reserveTime) ? helpers_1$h.Long.fromValue(object.reserveTime) : helpers_1$h.Long.UZERO,
            paymentAccountCountLimit: (0, helpers_1$h.isSet)(object.paymentAccountCountLimit) ? helpers_1$h.Long.fromValue(object.paymentAccountCountLimit) : helpers_1$h.Long.UZERO,
            forcedSettleTime: (0, helpers_1$h.isSet)(object.forcedSettleTime) ? helpers_1$h.Long.fromValue(object.forcedSettleTime) : helpers_1$h.Long.UZERO,
            maxAutoForceSettleNum: (0, helpers_1$h.isSet)(object.maxAutoForceSettleNum) ? helpers_1$h.Long.fromValue(object.maxAutoForceSettleNum) : helpers_1$h.Long.UZERO,
            feeDenom: (0, helpers_1$h.isSet)(object.feeDenom) ? String(object.feeDenom) : "",
            validatorTaxRate: (0, helpers_1$h.isSet)(object.validatorTaxRate) ? String(object.validatorTaxRate) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.reserveTime !== undefined && (obj.reserveTime = (message.reserveTime || helpers_1$h.Long.UZERO).toString());
        message.paymentAccountCountLimit !== undefined && (obj.paymentAccountCountLimit = (message.paymentAccountCountLimit || helpers_1$h.Long.UZERO).toString());
        message.forcedSettleTime !== undefined && (obj.forcedSettleTime = (message.forcedSettleTime || helpers_1$h.Long.UZERO).toString());
        message.maxAutoForceSettleNum !== undefined && (obj.maxAutoForceSettleNum = (message.maxAutoForceSettleNum || helpers_1$h.Long.UZERO).toString());
        message.feeDenom !== undefined && (obj.feeDenom = message.feeDenom);
        message.validatorTaxRate !== undefined && (obj.validatorTaxRate = message.validatorTaxRate);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseParams$5();
        message.reserveTime = object.reserveTime !== undefined && object.reserveTime !== null ? helpers_1$h.Long.fromValue(object.reserveTime) : helpers_1$h.Long.UZERO;
        message.paymentAccountCountLimit = object.paymentAccountCountLimit !== undefined && object.paymentAccountCountLimit !== null ? helpers_1$h.Long.fromValue(object.paymentAccountCountLimit) : helpers_1$h.Long.UZERO;
        message.forcedSettleTime = object.forcedSettleTime !== undefined && object.forcedSettleTime !== null ? helpers_1$h.Long.fromValue(object.forcedSettleTime) : helpers_1$h.Long.UZERO;
        message.maxAutoForceSettleNum = object.maxAutoForceSettleNum !== undefined && object.maxAutoForceSettleNum !== null ? helpers_1$h.Long.fromValue(object.maxAutoForceSettleNum) : helpers_1$h.Long.UZERO;
        message.feeDenom = object.feeDenom ?? "";
        message.validatorTaxRate = object.validatorTaxRate ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            reserveTime: object?.reserve_time,
            paymentAccountCountLimit: object?.payment_account_count_limit,
            forcedSettleTime: object?.forced_settle_time,
            maxAutoForceSettleNum: object?.max_auto_force_settle_num,
            feeDenom: object?.fee_denom,
            validatorTaxRate: object?.validator_tax_rate
        };
    },
    toSDK(message) {
        const obj = {};
        obj.reserve_time = message.reserveTime;
        obj.payment_account_count_limit = message.paymentAccountCountLimit;
        obj.forced_settle_time = message.forcedSettleTime;
        obj.max_auto_force_settle_num = message.maxAutoForceSettleNum;
        obj.fee_denom = message.feeDenom;
        obj.validator_tax_rate = message.validatorTaxRate;
        return obj;
    }
};

var stream_record = {};

var base = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OutFlow = exports.streamAccountStatusToJSON = exports.streamAccountStatusFromJSON = exports.StreamAccountStatusSDKType = exports.StreamAccountStatus = exports.protobufPackage = void 0;
	/* eslint-disable */
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.payment";
	/** StreamAccountStatus defines the status of a stream account */
	var StreamAccountStatus;
	(function (StreamAccountStatus) {
	    /** STREAM_ACCOUNT_STATUS_ACTIVE - STREAM_ACCOUNT_STATUS_ACTIVE defines the active status of a stream account. */
	    StreamAccountStatus[StreamAccountStatus["STREAM_ACCOUNT_STATUS_ACTIVE"] = 0] = "STREAM_ACCOUNT_STATUS_ACTIVE";
	    /**
	     * STREAM_ACCOUNT_STATUS_FROZEN - STREAM_ACCOUNT_STATUS_FROZEN defines the frozen status of a stream account.
	     * A frozen stream account cannot be used as payment address for buckets.
	     * It can be unfrozen by depositing more BNB to the stream account.
	     */
	    StreamAccountStatus[StreamAccountStatus["STREAM_ACCOUNT_STATUS_FROZEN"] = 1] = "STREAM_ACCOUNT_STATUS_FROZEN";
	    StreamAccountStatus[StreamAccountStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(StreamAccountStatus = exports.StreamAccountStatus || (exports.StreamAccountStatus = {}));
	exports.StreamAccountStatusSDKType = StreamAccountStatus;
	function streamAccountStatusFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "STREAM_ACCOUNT_STATUS_ACTIVE":
	            return StreamAccountStatus.STREAM_ACCOUNT_STATUS_ACTIVE;
	        case 1:
	        case "STREAM_ACCOUNT_STATUS_FROZEN":
	            return StreamAccountStatus.STREAM_ACCOUNT_STATUS_FROZEN;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return StreamAccountStatus.UNRECOGNIZED;
	    }
	}
	exports.streamAccountStatusFromJSON = streamAccountStatusFromJSON;
	function streamAccountStatusToJSON(object) {
	    switch (object) {
	        case StreamAccountStatus.STREAM_ACCOUNT_STATUS_ACTIVE:
	            return "STREAM_ACCOUNT_STATUS_ACTIVE";
	        case StreamAccountStatus.STREAM_ACCOUNT_STATUS_FROZEN:
	            return "STREAM_ACCOUNT_STATUS_FROZEN";
	        case StreamAccountStatus.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.streamAccountStatusToJSON = streamAccountStatusToJSON;
	function createBaseOutFlow() {
	    return {
	        toAddress: "",
	        rate: ""
	    };
	}
	exports.OutFlow = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.toAddress !== "") {
	            writer.uint32(10).string(message.toAddress);
	        }
	        if (message.rate !== "") {
	            writer.uint32(18).string(message.rate);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseOutFlow();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.toAddress = reader.string();
	                    break;
	                case 2:
	                    message.rate = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            toAddress: (0, helpers_1.isSet)(object.toAddress) ? String(object.toAddress) : "",
	            rate: (0, helpers_1.isSet)(object.rate) ? String(object.rate) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
	        message.rate !== undefined && (obj.rate = message.rate);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseOutFlow();
	        message.toAddress = object.toAddress ?? "";
	        message.rate = object.rate ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            toAddress: object?.to_address,
	            rate: object?.rate
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.to_address = message.toAddress;
	        obj.rate = message.rate;
	        return obj;
	    }
	};
	
} (base));

base.default;

var __createBinding$g = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$g = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$g = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$g(result, mod, k);
    __setModuleDefault$g(result, mod);
    return result;
};
Object.defineProperty(stream_record, "__esModule", { value: true });
stream_record.StreamRecord = stream_record.protobufPackage = void 0;
/* eslint-disable */
const base_1 = base;
const helpers_1$g = helpers;
const _m0$g = __importStar$g(minimal$1.exports);
stream_record.protobufPackage = "greenfield.payment";
function createBaseStreamRecord() {
    return {
        account: "",
        crudTimestamp: helpers_1$g.Long.ZERO,
        netflowRate: "",
        staticBalance: "",
        bufferBalance: "",
        lockBalance: "",
        status: 0,
        settleTimestamp: helpers_1$g.Long.ZERO,
        outFlows: []
    };
}
stream_record.StreamRecord = {
    encode(message, writer = _m0$g.Writer.create()) {
        if (message.account !== "") {
            writer.uint32(10).string(message.account);
        }
        if (!message.crudTimestamp.isZero()) {
            writer.uint32(16).int64(message.crudTimestamp);
        }
        if (message.netflowRate !== "") {
            writer.uint32(26).string(message.netflowRate);
        }
        if (message.staticBalance !== "") {
            writer.uint32(34).string(message.staticBalance);
        }
        if (message.bufferBalance !== "") {
            writer.uint32(42).string(message.bufferBalance);
        }
        if (message.lockBalance !== "") {
            writer.uint32(50).string(message.lockBalance);
        }
        if (message.status !== 0) {
            writer.uint32(56).int32(message.status);
        }
        if (!message.settleTimestamp.isZero()) {
            writer.uint32(64).int64(message.settleTimestamp);
        }
        for (const v of message.outFlows) {
            base_1.OutFlow.encode(v, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$g.Reader ? input : new _m0$g.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.crudTimestamp = reader.int64();
                    break;
                case 3:
                    message.netflowRate = reader.string();
                    break;
                case 4:
                    message.staticBalance = reader.string();
                    break;
                case 5:
                    message.bufferBalance = reader.string();
                    break;
                case 6:
                    message.lockBalance = reader.string();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                case 8:
                    message.settleTimestamp = reader.int64();
                    break;
                case 9:
                    message.outFlows.push(base_1.OutFlow.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            account: (0, helpers_1$g.isSet)(object.account) ? String(object.account) : "",
            crudTimestamp: (0, helpers_1$g.isSet)(object.crudTimestamp) ? helpers_1$g.Long.fromValue(object.crudTimestamp) : helpers_1$g.Long.ZERO,
            netflowRate: (0, helpers_1$g.isSet)(object.netflowRate) ? String(object.netflowRate) : "",
            staticBalance: (0, helpers_1$g.isSet)(object.staticBalance) ? String(object.staticBalance) : "",
            bufferBalance: (0, helpers_1$g.isSet)(object.bufferBalance) ? String(object.bufferBalance) : "",
            lockBalance: (0, helpers_1$g.isSet)(object.lockBalance) ? String(object.lockBalance) : "",
            status: (0, helpers_1$g.isSet)(object.status) ? (0, base_1.streamAccountStatusFromJSON)(object.status) : 0,
            settleTimestamp: (0, helpers_1$g.isSet)(object.settleTimestamp) ? helpers_1$g.Long.fromValue(object.settleTimestamp) : helpers_1$g.Long.ZERO,
            outFlows: Array.isArray(object?.outFlows) ? object.outFlows.map((e) => base_1.OutFlow.fromJSON(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        message.account !== undefined && (obj.account = message.account);
        message.crudTimestamp !== undefined && (obj.crudTimestamp = (message.crudTimestamp || helpers_1$g.Long.ZERO).toString());
        message.netflowRate !== undefined && (obj.netflowRate = message.netflowRate);
        message.staticBalance !== undefined && (obj.staticBalance = message.staticBalance);
        message.bufferBalance !== undefined && (obj.bufferBalance = message.bufferBalance);
        message.lockBalance !== undefined && (obj.lockBalance = message.lockBalance);
        message.status !== undefined && (obj.status = (0, base_1.streamAccountStatusToJSON)(message.status));
        message.settleTimestamp !== undefined && (obj.settleTimestamp = (message.settleTimestamp || helpers_1$g.Long.ZERO).toString());
        if (message.outFlows) {
            obj.outFlows = message.outFlows.map(e => e ? base_1.OutFlow.toJSON(e) : undefined);
        }
        else {
            obj.outFlows = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStreamRecord();
        message.account = object.account ?? "";
        message.crudTimestamp = object.crudTimestamp !== undefined && object.crudTimestamp !== null ? helpers_1$g.Long.fromValue(object.crudTimestamp) : helpers_1$g.Long.ZERO;
        message.netflowRate = object.netflowRate ?? "";
        message.staticBalance = object.staticBalance ?? "";
        message.bufferBalance = object.bufferBalance ?? "";
        message.lockBalance = object.lockBalance ?? "";
        message.status = object.status ?? 0;
        message.settleTimestamp = object.settleTimestamp !== undefined && object.settleTimestamp !== null ? helpers_1$g.Long.fromValue(object.settleTimestamp) : helpers_1$g.Long.ZERO;
        message.outFlows = object.outFlows?.map(e => base_1.OutFlow.fromPartial(e)) || [];
        return message;
    },
    fromSDK(object) {
        return {
            account: object?.account,
            crudTimestamp: object?.crud_timestamp,
            netflowRate: object?.netflow_rate,
            staticBalance: object?.static_balance,
            bufferBalance: object?.buffer_balance,
            lockBalance: object?.lock_balance,
            status: (0, helpers_1$g.isSet)(object.status) ? (0, base_1.streamAccountStatusFromJSON)(object.status) : 0,
            settleTimestamp: object?.settle_timestamp,
            outFlows: Array.isArray(object?.out_flows) ? object.out_flows.map((e) => base_1.OutFlow.fromSDK(e)) : []
        };
    },
    toSDK(message) {
        const obj = {};
        obj.account = message.account;
        obj.crud_timestamp = message.crudTimestamp;
        obj.netflow_rate = message.netflowRate;
        obj.static_balance = message.staticBalance;
        obj.buffer_balance = message.bufferBalance;
        obj.lock_balance = message.lockBalance;
        message.status !== undefined && (obj.status = (0, base_1.streamAccountStatusToJSON)(message.status));
        obj.settle_timestamp = message.settleTimestamp;
        if (message.outFlows) {
            obj.out_flows = message.outFlows.map(e => e ? base_1.OutFlow.toSDK(e) : undefined);
        }
        else {
            obj.out_flows = [];
        }
        return obj;
    }
};

var payment_account_count = {};

var __createBinding$f = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$f = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$f = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$f(result, mod, k);
    __setModuleDefault$f(result, mod);
    return result;
};
Object.defineProperty(payment_account_count, "__esModule", { value: true });
payment_account_count.PaymentAccountCount = payment_account_count.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$f = helpers;
const _m0$f = __importStar$f(minimal$1.exports);
payment_account_count.protobufPackage = "greenfield.payment";
function createBasePaymentAccountCount() {
    return {
        owner: "",
        count: helpers_1$f.Long.UZERO
    };
}
payment_account_count.PaymentAccountCount = {
    encode(message, writer = _m0$f.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        if (!message.count.isZero()) {
            writer.uint32(16).uint64(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$f.Reader ? input : new _m0$f.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePaymentAccountCount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.count = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            owner: (0, helpers_1$f.isSet)(object.owner) ? String(object.owner) : "",
            count: (0, helpers_1$f.isSet)(object.count) ? helpers_1$f.Long.fromValue(object.count) : helpers_1$f.Long.UZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.owner !== undefined && (obj.owner = message.owner);
        message.count !== undefined && (obj.count = (message.count || helpers_1$f.Long.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBasePaymentAccountCount();
        message.owner = object.owner ?? "";
        message.count = object.count !== undefined && object.count !== null ? helpers_1$f.Long.fromValue(object.count) : helpers_1$f.Long.UZERO;
        return message;
    },
    fromSDK(object) {
        return {
            owner: object?.owner,
            count: object?.count
        };
    },
    toSDK(message) {
        const obj = {};
        obj.owner = message.owner;
        obj.count = message.count;
        return obj;
    }
};

var payment_account = {};

var __createBinding$e = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$e = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$e = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$e(result, mod, k);
    __setModuleDefault$e(result, mod);
    return result;
};
Object.defineProperty(payment_account, "__esModule", { value: true });
payment_account.PaymentAccount = payment_account.protobufPackage = void 0;
/* eslint-disable */
const _m0$e = __importStar$e(minimal$1.exports);
const helpers_1$e = helpers;
payment_account.protobufPackage = "greenfield.payment";
function createBasePaymentAccount() {
    return {
        addr: "",
        owner: "",
        refundable: false
    };
}
payment_account.PaymentAccount = {
    encode(message, writer = _m0$e.Writer.create()) {
        if (message.addr !== "") {
            writer.uint32(10).string(message.addr);
        }
        if (message.owner !== "") {
            writer.uint32(18).string(message.owner);
        }
        if (message.refundable === true) {
            writer.uint32(24).bool(message.refundable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$e.Reader ? input : new _m0$e.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePaymentAccount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.owner = reader.string();
                    break;
                case 3:
                    message.refundable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            addr: (0, helpers_1$e.isSet)(object.addr) ? String(object.addr) : "",
            owner: (0, helpers_1$e.isSet)(object.owner) ? String(object.owner) : "",
            refundable: (0, helpers_1$e.isSet)(object.refundable) ? Boolean(object.refundable) : false
        };
    },
    toJSON(message) {
        const obj = {};
        message.addr !== undefined && (obj.addr = message.addr);
        message.owner !== undefined && (obj.owner = message.owner);
        message.refundable !== undefined && (obj.refundable = message.refundable);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePaymentAccount();
        message.addr = object.addr ?? "";
        message.owner = object.owner ?? "";
        message.refundable = object.refundable ?? false;
        return message;
    },
    fromSDK(object) {
        return {
            addr: object?.addr,
            owner: object?.owner,
            refundable: object?.refundable
        };
    },
    toSDK(message) {
        const obj = {};
        obj.addr = message.addr;
        obj.owner = message.owner;
        obj.refundable = message.refundable;
        return obj;
    }
};

var auto_settle_record = {};

var __createBinding$d = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$d = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$d = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$d(result, mod, k);
    __setModuleDefault$d(result, mod);
    return result;
};
Object.defineProperty(auto_settle_record, "__esModule", { value: true });
auto_settle_record.AutoSettleRecord = auto_settle_record.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$d = helpers;
const _m0$d = __importStar$d(minimal$1.exports);
auto_settle_record.protobufPackage = "greenfield.payment";
function createBaseAutoSettleRecord() {
    return {
        timestamp: helpers_1$d.Long.ZERO,
        addr: ""
    };
}
auto_settle_record.AutoSettleRecord = {
    encode(message, writer = _m0$d.Writer.create()) {
        if (!message.timestamp.isZero()) {
            writer.uint32(8).int64(message.timestamp);
        }
        if (message.addr !== "") {
            writer.uint32(18).string(message.addr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$d.Reader ? input : new _m0$d.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAutoSettleRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.addr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            timestamp: (0, helpers_1$d.isSet)(object.timestamp) ? helpers_1$d.Long.fromValue(object.timestamp) : helpers_1$d.Long.ZERO,
            addr: (0, helpers_1$d.isSet)(object.addr) ? String(object.addr) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || helpers_1$d.Long.ZERO).toString());
        message.addr !== undefined && (obj.addr = message.addr);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAutoSettleRecord();
        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? helpers_1$d.Long.fromValue(object.timestamp) : helpers_1$d.Long.ZERO;
        message.addr = object.addr ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            timestamp: object?.timestamp,
            addr: object?.addr
        };
    },
    toSDK(message) {
        const obj = {};
        obj.timestamp = message.timestamp;
        obj.addr = message.addr;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QueryAllAutoSettleRecordResponse = exports.QueryAllAutoSettleRecordRequest = exports.QueryGetPaymentAccountsByOwnerResponse = exports.QueryGetPaymentAccountsByOwnerRequest = exports.QueryDynamicBalanceResponse = exports.QueryDynamicBalanceRequest = exports.QueryAllPaymentAccountResponse = exports.QueryAllPaymentAccountRequest = exports.QueryGetPaymentAccountResponse = exports.QueryGetPaymentAccountRequest = exports.QueryAllPaymentAccountCountResponse = exports.QueryAllPaymentAccountCountRequest = exports.QueryGetPaymentAccountCountResponse = exports.QueryGetPaymentAccountCountRequest = exports.QueryAllStreamRecordResponse = exports.QueryAllStreamRecordRequest = exports.QueryGetStreamRecordResponse = exports.QueryGetStreamRecordRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const pagination_1 = pagination;
	const params_1 = params$5;
	const stream_record_1 = stream_record;
	const payment_account_count_1 = payment_account_count;
	const payment_account_1 = payment_account;
	const auto_settle_record_1 = auto_settle_record;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.payment";
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryGetStreamRecordRequest() {
	    return {
	        account: ""
	    };
	}
	exports.QueryGetStreamRecordRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.account !== "") {
	            writer.uint32(10).string(message.account);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetStreamRecordRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.account = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            account: (0, helpers_1.isSet)(object.account) ? String(object.account) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.account !== undefined && (obj.account = message.account);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetStreamRecordRequest();
	        message.account = object.account ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            account: object?.account
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.account = message.account;
	        return obj;
	    }
	};
	function createBaseQueryGetStreamRecordResponse() {
	    return {
	        streamRecord: undefined
	    };
	}
	exports.QueryGetStreamRecordResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.streamRecord !== undefined) {
	            stream_record_1.StreamRecord.encode(message.streamRecord, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetStreamRecordResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.streamRecord = stream_record_1.StreamRecord.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            streamRecord: (0, helpers_1.isSet)(object.streamRecord) ? stream_record_1.StreamRecord.fromJSON(object.streamRecord) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.streamRecord !== undefined && (obj.streamRecord = message.streamRecord ? stream_record_1.StreamRecord.toJSON(message.streamRecord) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetStreamRecordResponse();
	        message.streamRecord = object.streamRecord !== undefined && object.streamRecord !== null ? stream_record_1.StreamRecord.fromPartial(object.streamRecord) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            streamRecord: object.stream_record ? stream_record_1.StreamRecord.fromSDK(object.stream_record) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.streamRecord !== undefined && (obj.stream_record = message.streamRecord ? stream_record_1.StreamRecord.toSDK(message.streamRecord) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllStreamRecordRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryAllStreamRecordRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllStreamRecordRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllStreamRecordRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllStreamRecordResponse() {
	    return {
	        streamRecord: [],
	        pagination: undefined
	    };
	}
	exports.QueryAllStreamRecordResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.streamRecord) {
	            stream_record_1.StreamRecord.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllStreamRecordResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.streamRecord.push(stream_record_1.StreamRecord.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            streamRecord: Array.isArray(object?.streamRecord) ? object.streamRecord.map((e) => stream_record_1.StreamRecord.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.streamRecord) {
	            obj.streamRecord = message.streamRecord.map(e => e ? stream_record_1.StreamRecord.toJSON(e) : undefined);
	        }
	        else {
	            obj.streamRecord = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllStreamRecordResponse();
	        message.streamRecord = object.streamRecord?.map(e => stream_record_1.StreamRecord.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            streamRecord: Array.isArray(object?.stream_record) ? object.stream_record.map((e) => stream_record_1.StreamRecord.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.streamRecord) {
	            obj.stream_record = message.streamRecord.map(e => e ? stream_record_1.StreamRecord.toSDK(e) : undefined);
	        }
	        else {
	            obj.stream_record = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryGetPaymentAccountCountRequest() {
	    return {
	        owner: ""
	    };
	}
	exports.QueryGetPaymentAccountCountRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.owner !== "") {
	            writer.uint32(10).string(message.owner);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetPaymentAccountCountRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.owner = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.owner !== undefined && (obj.owner = message.owner);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetPaymentAccountCountRequest();
	        message.owner = object.owner ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            owner: object?.owner
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.owner = message.owner;
	        return obj;
	    }
	};
	function createBaseQueryGetPaymentAccountCountResponse() {
	    return {
	        paymentAccountCount: undefined
	    };
	}
	exports.QueryGetPaymentAccountCountResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.paymentAccountCount !== undefined) {
	            payment_account_count_1.PaymentAccountCount.encode(message.paymentAccountCount, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetPaymentAccountCountResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.paymentAccountCount = payment_account_count_1.PaymentAccountCount.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            paymentAccountCount: (0, helpers_1.isSet)(object.paymentAccountCount) ? payment_account_count_1.PaymentAccountCount.fromJSON(object.paymentAccountCount) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.paymentAccountCount !== undefined && (obj.paymentAccountCount = message.paymentAccountCount ? payment_account_count_1.PaymentAccountCount.toJSON(message.paymentAccountCount) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetPaymentAccountCountResponse();
	        message.paymentAccountCount = object.paymentAccountCount !== undefined && object.paymentAccountCount !== null ? payment_account_count_1.PaymentAccountCount.fromPartial(object.paymentAccountCount) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            paymentAccountCount: object.payment_account_count ? payment_account_count_1.PaymentAccountCount.fromSDK(object.payment_account_count) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.paymentAccountCount !== undefined && (obj.payment_account_count = message.paymentAccountCount ? payment_account_count_1.PaymentAccountCount.toSDK(message.paymentAccountCount) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllPaymentAccountCountRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryAllPaymentAccountCountRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllPaymentAccountCountRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllPaymentAccountCountRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllPaymentAccountCountResponse() {
	    return {
	        paymentAccountCount: [],
	        pagination: undefined
	    };
	}
	exports.QueryAllPaymentAccountCountResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.paymentAccountCount) {
	            payment_account_count_1.PaymentAccountCount.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllPaymentAccountCountResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.paymentAccountCount.push(payment_account_count_1.PaymentAccountCount.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            paymentAccountCount: Array.isArray(object?.paymentAccountCount) ? object.paymentAccountCount.map((e) => payment_account_count_1.PaymentAccountCount.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.paymentAccountCount) {
	            obj.paymentAccountCount = message.paymentAccountCount.map(e => e ? payment_account_count_1.PaymentAccountCount.toJSON(e) : undefined);
	        }
	        else {
	            obj.paymentAccountCount = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllPaymentAccountCountResponse();
	        message.paymentAccountCount = object.paymentAccountCount?.map(e => payment_account_count_1.PaymentAccountCount.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            paymentAccountCount: Array.isArray(object?.payment_account_count) ? object.payment_account_count.map((e) => payment_account_count_1.PaymentAccountCount.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.paymentAccountCount) {
	            obj.payment_account_count = message.paymentAccountCount.map(e => e ? payment_account_count_1.PaymentAccountCount.toSDK(e) : undefined);
	        }
	        else {
	            obj.payment_account_count = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryGetPaymentAccountRequest() {
	    return {
	        addr: ""
	    };
	}
	exports.QueryGetPaymentAccountRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.addr !== "") {
	            writer.uint32(10).string(message.addr);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetPaymentAccountRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.addr = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            addr: (0, helpers_1.isSet)(object.addr) ? String(object.addr) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.addr !== undefined && (obj.addr = message.addr);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetPaymentAccountRequest();
	        message.addr = object.addr ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            addr: object?.addr
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.addr = message.addr;
	        return obj;
	    }
	};
	function createBaseQueryGetPaymentAccountResponse() {
	    return {
	        paymentAccount: undefined
	    };
	}
	exports.QueryGetPaymentAccountResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.paymentAccount !== undefined) {
	            payment_account_1.PaymentAccount.encode(message.paymentAccount, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetPaymentAccountResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.paymentAccount = payment_account_1.PaymentAccount.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            paymentAccount: (0, helpers_1.isSet)(object.paymentAccount) ? payment_account_1.PaymentAccount.fromJSON(object.paymentAccount) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.paymentAccount !== undefined && (obj.paymentAccount = message.paymentAccount ? payment_account_1.PaymentAccount.toJSON(message.paymentAccount) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetPaymentAccountResponse();
	        message.paymentAccount = object.paymentAccount !== undefined && object.paymentAccount !== null ? payment_account_1.PaymentAccount.fromPartial(object.paymentAccount) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            paymentAccount: object.payment_account ? payment_account_1.PaymentAccount.fromSDK(object.payment_account) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.paymentAccount !== undefined && (obj.payment_account = message.paymentAccount ? payment_account_1.PaymentAccount.toSDK(message.paymentAccount) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllPaymentAccountRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryAllPaymentAccountRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllPaymentAccountRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllPaymentAccountRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllPaymentAccountResponse() {
	    return {
	        paymentAccount: [],
	        pagination: undefined
	    };
	}
	exports.QueryAllPaymentAccountResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.paymentAccount) {
	            payment_account_1.PaymentAccount.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllPaymentAccountResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.paymentAccount.push(payment_account_1.PaymentAccount.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            paymentAccount: Array.isArray(object?.paymentAccount) ? object.paymentAccount.map((e) => payment_account_1.PaymentAccount.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.paymentAccount) {
	            obj.paymentAccount = message.paymentAccount.map(e => e ? payment_account_1.PaymentAccount.toJSON(e) : undefined);
	        }
	        else {
	            obj.paymentAccount = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllPaymentAccountResponse();
	        message.paymentAccount = object.paymentAccount?.map(e => payment_account_1.PaymentAccount.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            paymentAccount: Array.isArray(object?.payment_account) ? object.payment_account.map((e) => payment_account_1.PaymentAccount.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.paymentAccount) {
	            obj.payment_account = message.paymentAccount.map(e => e ? payment_account_1.PaymentAccount.toSDK(e) : undefined);
	        }
	        else {
	            obj.payment_account = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryDynamicBalanceRequest() {
	    return {
	        account: ""
	    };
	}
	exports.QueryDynamicBalanceRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.account !== "") {
	            writer.uint32(10).string(message.account);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDynamicBalanceRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.account = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            account: (0, helpers_1.isSet)(object.account) ? String(object.account) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.account !== undefined && (obj.account = message.account);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDynamicBalanceRequest();
	        message.account = object.account ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            account: object?.account
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.account = message.account;
	        return obj;
	    }
	};
	function createBaseQueryDynamicBalanceResponse() {
	    return {
	        dynamicBalance: "",
	        streamRecord: undefined,
	        currentTimestamp: helpers_1.Long.ZERO,
	        bankBalance: "",
	        availableBalance: "",
	        lockedFee: "",
	        changeRate: ""
	    };
	}
	exports.QueryDynamicBalanceResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.dynamicBalance !== "") {
	            writer.uint32(10).string(message.dynamicBalance);
	        }
	        if (message.streamRecord !== undefined) {
	            stream_record_1.StreamRecord.encode(message.streamRecord, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.currentTimestamp.isZero()) {
	            writer.uint32(24).int64(message.currentTimestamp);
	        }
	        if (message.bankBalance !== "") {
	            writer.uint32(34).string(message.bankBalance);
	        }
	        if (message.availableBalance !== "") {
	            writer.uint32(42).string(message.availableBalance);
	        }
	        if (message.lockedFee !== "") {
	            writer.uint32(50).string(message.lockedFee);
	        }
	        if (message.changeRate !== "") {
	            writer.uint32(58).string(message.changeRate);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryDynamicBalanceResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.dynamicBalance = reader.string();
	                    break;
	                case 2:
	                    message.streamRecord = stream_record_1.StreamRecord.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.currentTimestamp = reader.int64();
	                    break;
	                case 4:
	                    message.bankBalance = reader.string();
	                    break;
	                case 5:
	                    message.availableBalance = reader.string();
	                    break;
	                case 6:
	                    message.lockedFee = reader.string();
	                    break;
	                case 7:
	                    message.changeRate = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            dynamicBalance: (0, helpers_1.isSet)(object.dynamicBalance) ? String(object.dynamicBalance) : "",
	            streamRecord: (0, helpers_1.isSet)(object.streamRecord) ? stream_record_1.StreamRecord.fromJSON(object.streamRecord) : undefined,
	            currentTimestamp: (0, helpers_1.isSet)(object.currentTimestamp) ? helpers_1.Long.fromValue(object.currentTimestamp) : helpers_1.Long.ZERO,
	            bankBalance: (0, helpers_1.isSet)(object.bankBalance) ? String(object.bankBalance) : "",
	            availableBalance: (0, helpers_1.isSet)(object.availableBalance) ? String(object.availableBalance) : "",
	            lockedFee: (0, helpers_1.isSet)(object.lockedFee) ? String(object.lockedFee) : "",
	            changeRate: (0, helpers_1.isSet)(object.changeRate) ? String(object.changeRate) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.dynamicBalance !== undefined && (obj.dynamicBalance = message.dynamicBalance);
	        message.streamRecord !== undefined && (obj.streamRecord = message.streamRecord ? stream_record_1.StreamRecord.toJSON(message.streamRecord) : undefined);
	        message.currentTimestamp !== undefined && (obj.currentTimestamp = (message.currentTimestamp || helpers_1.Long.ZERO).toString());
	        message.bankBalance !== undefined && (obj.bankBalance = message.bankBalance);
	        message.availableBalance !== undefined && (obj.availableBalance = message.availableBalance);
	        message.lockedFee !== undefined && (obj.lockedFee = message.lockedFee);
	        message.changeRate !== undefined && (obj.changeRate = message.changeRate);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryDynamicBalanceResponse();
	        message.dynamicBalance = object.dynamicBalance ?? "";
	        message.streamRecord = object.streamRecord !== undefined && object.streamRecord !== null ? stream_record_1.StreamRecord.fromPartial(object.streamRecord) : undefined;
	        message.currentTimestamp = object.currentTimestamp !== undefined && object.currentTimestamp !== null ? helpers_1.Long.fromValue(object.currentTimestamp) : helpers_1.Long.ZERO;
	        message.bankBalance = object.bankBalance ?? "";
	        message.availableBalance = object.availableBalance ?? "";
	        message.lockedFee = object.lockedFee ?? "";
	        message.changeRate = object.changeRate ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            dynamicBalance: object?.dynamic_balance,
	            streamRecord: object.stream_record ? stream_record_1.StreamRecord.fromSDK(object.stream_record) : undefined,
	            currentTimestamp: object?.current_timestamp,
	            bankBalance: object?.bank_balance,
	            availableBalance: object?.available_balance,
	            lockedFee: object?.locked_fee,
	            changeRate: object?.change_rate
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.dynamic_balance = message.dynamicBalance;
	        message.streamRecord !== undefined && (obj.stream_record = message.streamRecord ? stream_record_1.StreamRecord.toSDK(message.streamRecord) : undefined);
	        obj.current_timestamp = message.currentTimestamp;
	        obj.bank_balance = message.bankBalance;
	        obj.available_balance = message.availableBalance;
	        obj.locked_fee = message.lockedFee;
	        obj.change_rate = message.changeRate;
	        return obj;
	    }
	};
	function createBaseQueryGetPaymentAccountsByOwnerRequest() {
	    return {
	        owner: ""
	    };
	}
	exports.QueryGetPaymentAccountsByOwnerRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.owner !== "") {
	            writer.uint32(10).string(message.owner);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetPaymentAccountsByOwnerRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.owner = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.owner !== undefined && (obj.owner = message.owner);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetPaymentAccountsByOwnerRequest();
	        message.owner = object.owner ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            owner: object?.owner
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.owner = message.owner;
	        return obj;
	    }
	};
	function createBaseQueryGetPaymentAccountsByOwnerResponse() {
	    return {
	        paymentAccounts: []
	    };
	}
	exports.QueryGetPaymentAccountsByOwnerResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.paymentAccounts) {
	            writer.uint32(10).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetPaymentAccountsByOwnerResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.paymentAccounts.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            paymentAccounts: Array.isArray(object?.paymentAccounts) ? object.paymentAccounts.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.paymentAccounts) {
	            obj.paymentAccounts = message.paymentAccounts.map(e => e);
	        }
	        else {
	            obj.paymentAccounts = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetPaymentAccountsByOwnerResponse();
	        message.paymentAccounts = object.paymentAccounts?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            paymentAccounts: Array.isArray(object?.paymentAccounts) ? object.paymentAccounts.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.paymentAccounts) {
	            obj.paymentAccounts = message.paymentAccounts.map(e => e);
	        }
	        else {
	            obj.paymentAccounts = [];
	        }
	        return obj;
	    }
	};
	function createBaseQueryAllAutoSettleRecordRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryAllAutoSettleRecordRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllAutoSettleRecordRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllAutoSettleRecordRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryAllAutoSettleRecordResponse() {
	    return {
	        autoSettleRecord: [],
	        pagination: undefined
	    };
	}
	exports.QueryAllAutoSettleRecordResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.autoSettleRecord) {
	            auto_settle_record_1.AutoSettleRecord.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryAllAutoSettleRecordResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.autoSettleRecord.push(auto_settle_record_1.AutoSettleRecord.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            autoSettleRecord: Array.isArray(object?.autoSettleRecord) ? object.autoSettleRecord.map((e) => auto_settle_record_1.AutoSettleRecord.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.autoSettleRecord) {
	            obj.autoSettleRecord = message.autoSettleRecord.map(e => e ? auto_settle_record_1.AutoSettleRecord.toJSON(e) : undefined);
	        }
	        else {
	            obj.autoSettleRecord = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryAllAutoSettleRecordResponse();
	        message.autoSettleRecord = object.autoSettleRecord?.map(e => auto_settle_record_1.AutoSettleRecord.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            autoSettleRecord: Array.isArray(object?.auto_settle_record) ? object.auto_settle_record.map((e) => auto_settle_record_1.AutoSettleRecord.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.autoSettleRecord) {
	            obj.auto_settle_record = message.autoSettleRecord.map(e => e ? auto_settle_record_1.AutoSettleRecord.toSDK(e) : undefined);
	        }
	        else {
	            obj.auto_settle_record = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Params = this.Params.bind(this);
	        this.StreamRecord = this.StreamRecord.bind(this);
	        this.StreamRecordAll = this.StreamRecordAll.bind(this);
	        this.PaymentAccountCount = this.PaymentAccountCount.bind(this);
	        this.PaymentAccountCountAll = this.PaymentAccountCountAll.bind(this);
	        this.PaymentAccount = this.PaymentAccount.bind(this);
	        this.PaymentAccountAll = this.PaymentAccountAll.bind(this);
	        this.DynamicBalance = this.DynamicBalance.bind(this);
	        this.GetPaymentAccountsByOwner = this.GetPaymentAccountsByOwner.bind(this);
	        this.AutoSettleRecordAll = this.AutoSettleRecordAll.bind(this);
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    StreamRecord(request) {
	        const data = exports.QueryGetStreamRecordRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "StreamRecord", data);
	        return promise.then(data => exports.QueryGetStreamRecordResponse.decode(new _m0.Reader(data)));
	    }
	    StreamRecordAll(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryAllStreamRecordRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "StreamRecordAll", data);
	        return promise.then(data => exports.QueryAllStreamRecordResponse.decode(new _m0.Reader(data)));
	    }
	    PaymentAccountCount(request) {
	        const data = exports.QueryGetPaymentAccountCountRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "PaymentAccountCount", data);
	        return promise.then(data => exports.QueryGetPaymentAccountCountResponse.decode(new _m0.Reader(data)));
	    }
	    PaymentAccountCountAll(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryAllPaymentAccountCountRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "PaymentAccountCountAll", data);
	        return promise.then(data => exports.QueryAllPaymentAccountCountResponse.decode(new _m0.Reader(data)));
	    }
	    PaymentAccount(request) {
	        const data = exports.QueryGetPaymentAccountRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "PaymentAccount", data);
	        return promise.then(data => exports.QueryGetPaymentAccountResponse.decode(new _m0.Reader(data)));
	    }
	    PaymentAccountAll(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryAllPaymentAccountRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "PaymentAccountAll", data);
	        return promise.then(data => exports.QueryAllPaymentAccountResponse.decode(new _m0.Reader(data)));
	    }
	    DynamicBalance(request) {
	        const data = exports.QueryDynamicBalanceRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "DynamicBalance", data);
	        return promise.then(data => exports.QueryDynamicBalanceResponse.decode(new _m0.Reader(data)));
	    }
	    GetPaymentAccountsByOwner(request) {
	        const data = exports.QueryGetPaymentAccountsByOwnerRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "GetPaymentAccountsByOwner", data);
	        return promise.then(data => exports.QueryGetPaymentAccountsByOwnerResponse.decode(new _m0.Reader(data)));
	    }
	    AutoSettleRecordAll(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryAllAutoSettleRecordRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Query", "AutoSettleRecordAll", data);
	        return promise.then(data => exports.QueryAllAutoSettleRecordResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$7));

query$7.default;

var tx$7 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgDisableRefundResponse = exports.MsgDisableRefund = exports.MsgWithdrawResponse = exports.MsgWithdraw = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgCreatePaymentAccountResponse = exports.MsgCreatePaymentAccount = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.protobufPackage = void 0;
	/* eslint-disable */
	const params_1 = params$5;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.payment";
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgCreatePaymentAccount() {
	    return {
	        creator: ""
	    };
	}
	exports.MsgCreatePaymentAccount = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreatePaymentAccount();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreatePaymentAccount();
	        message.creator = object.creator ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        return obj;
	    }
	};
	function createBaseMsgCreatePaymentAccountResponse() {
	    return {};
	}
	exports.MsgCreatePaymentAccountResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreatePaymentAccountResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgCreatePaymentAccountResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgDeposit() {
	    return {
	        creator: "",
	        to: "",
	        amount: ""
	    };
	}
	exports.MsgDeposit = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        if (message.to !== "") {
	            writer.uint32(18).string(message.to);
	        }
	        if (message.amount !== "") {
	            writer.uint32(26).string(message.amount);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeposit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                case 2:
	                    message.to = reader.string();
	                    break;
	                case 3:
	                    message.amount = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
	            to: (0, helpers_1.isSet)(object.to) ? String(object.to) : "",
	            amount: (0, helpers_1.isSet)(object.amount) ? String(object.amount) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        message.to !== undefined && (obj.to = message.to);
	        message.amount !== undefined && (obj.amount = message.amount);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDeposit();
	        message.creator = object.creator ?? "";
	        message.to = object.to ?? "";
	        message.amount = object.amount ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator,
	            to: object?.to,
	            amount: object?.amount
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        obj.to = message.to;
	        obj.amount = message.amount;
	        return obj;
	    }
	};
	function createBaseMsgDepositResponse() {
	    return {};
	}
	exports.MsgDepositResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDepositResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDepositResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgWithdraw() {
	    return {
	        creator: "",
	        from: "",
	        amount: ""
	    };
	}
	exports.MsgWithdraw = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        if (message.from !== "") {
	            writer.uint32(18).string(message.from);
	        }
	        if (message.amount !== "") {
	            writer.uint32(26).string(message.amount);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgWithdraw();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                case 2:
	                    message.from = reader.string();
	                    break;
	                case 3:
	                    message.amount = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
	            from: (0, helpers_1.isSet)(object.from) ? String(object.from) : "",
	            amount: (0, helpers_1.isSet)(object.amount) ? String(object.amount) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        message.from !== undefined && (obj.from = message.from);
	        message.amount !== undefined && (obj.amount = message.amount);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgWithdraw();
	        message.creator = object.creator ?? "";
	        message.from = object.from ?? "";
	        message.amount = object.amount ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator,
	            from: object?.from,
	            amount: object?.amount
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        obj.from = message.from;
	        obj.amount = message.amount;
	        return obj;
	    }
	};
	function createBaseMsgWithdrawResponse() {
	    return {};
	}
	exports.MsgWithdrawResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgWithdrawResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgWithdrawResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgDisableRefund() {
	    return {
	        owner: "",
	        addr: ""
	    };
	}
	exports.MsgDisableRefund = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.owner !== "") {
	            writer.uint32(10).string(message.owner);
	        }
	        if (message.addr !== "") {
	            writer.uint32(18).string(message.addr);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDisableRefund();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.owner = reader.string();
	                    break;
	                case 2:
	                    message.addr = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : "",
	            addr: (0, helpers_1.isSet)(object.addr) ? String(object.addr) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.owner !== undefined && (obj.owner = message.owner);
	        message.addr !== undefined && (obj.addr = message.addr);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDisableRefund();
	        message.owner = object.owner ?? "";
	        message.addr = object.addr ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            owner: object?.owner,
	            addr: object?.addr
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.owner = message.owner;
	        obj.addr = message.addr;
	        return obj;
	    }
	};
	function createBaseMsgDisableRefundResponse() {
	    return {};
	}
	exports.MsgDisableRefundResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDisableRefundResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDisableRefundResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.UpdateParams = this.UpdateParams.bind(this);
	        this.CreatePaymentAccount = this.CreatePaymentAccount.bind(this);
	        this.Deposit = this.Deposit.bind(this);
	        this.Withdraw = this.Withdraw.bind(this);
	        this.DisableRefund = this.DisableRefund.bind(this);
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	    CreatePaymentAccount(request) {
	        const data = exports.MsgCreatePaymentAccount.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Msg", "CreatePaymentAccount", data);
	        return promise.then(data => exports.MsgCreatePaymentAccountResponse.decode(new _m0.Reader(data)));
	    }
	    Deposit(request) {
	        const data = exports.MsgDeposit.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Msg", "Deposit", data);
	        return promise.then(data => exports.MsgDepositResponse.decode(new _m0.Reader(data)));
	    }
	    Withdraw(request) {
	        const data = exports.MsgWithdraw.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Msg", "Withdraw", data);
	        return promise.then(data => exports.MsgWithdrawResponse.decode(new _m0.Reader(data)));
	    }
	    DisableRefund(request) {
	        const data = exports.MsgDisableRefund.encode(request).finish();
	        const promise = this.rpc.request("greenfield.payment.Msg", "DisableRefund", data);
	        return promise.then(data => exports.MsgDisableRefundResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx$7));

tx$7.default;

const getGasFeeBySimulate = (simulateTxInfo, denom = 'BNB') => {
    var _a, _b;
    if (!simulateTxInfo.gasInfo)
        throw new Error('gasInfo not found');
    const gasLimit = BigInt((_a = simulateTxInfo.gasInfo) === null || _a === void 0 ? void 0 : _a.gasUsed.toNumber());
    const gasPrice = (_b = simulateTxInfo.gasInfo) === null || _b === void 0 ? void 0 : _b.minGasPrice.replace(denom, '');
    const gasFee = gasLimit * BigInt(gasPrice);
    return {
        gasLimit,
        gasPrice,
        gasFee: units.formatEther(String(gasFee)),
    };
};

var query$6 = {};

var types$9 = {};

var proof = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;
	/* eslint-disable */
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "tendermint.crypto";
	function createBaseProof() {
	    return {
	        total: helpers_1.Long.ZERO,
	        index: helpers_1.Long.ZERO,
	        leafHash: new Uint8Array(),
	        aunts: []
	    };
	}
	exports.Proof = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.total.isZero()) {
	            writer.uint32(8).int64(message.total);
	        }
	        if (!message.index.isZero()) {
	            writer.uint32(16).int64(message.index);
	        }
	        if (message.leafHash.length !== 0) {
	            writer.uint32(26).bytes(message.leafHash);
	        }
	        for (const v of message.aunts) {
	            writer.uint32(34).bytes(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseProof();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.total = reader.int64();
	                    break;
	                case 2:
	                    message.index = reader.int64();
	                    break;
	                case 3:
	                    message.leafHash = reader.bytes();
	                    break;
	                case 4:
	                    message.aunts.push(reader.bytes());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            total: (0, helpers_1.isSet)(object.total) ? helpers_1.Long.fromValue(object.total) : helpers_1.Long.ZERO,
	            index: (0, helpers_1.isSet)(object.index) ? helpers_1.Long.fromValue(object.index) : helpers_1.Long.ZERO,
	            leafHash: (0, helpers_1.isSet)(object.leafHash) ? (0, helpers_1.bytesFromBase64)(object.leafHash) : new Uint8Array(),
	            aunts: Array.isArray(object?.aunts) ? object.aunts.map((e) => (0, helpers_1.bytesFromBase64)(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.total !== undefined && (obj.total = (message.total || helpers_1.Long.ZERO).toString());
	        message.index !== undefined && (obj.index = (message.index || helpers_1.Long.ZERO).toString());
	        message.leafHash !== undefined && (obj.leafHash = (0, helpers_1.base64FromBytes)(message.leafHash !== undefined ? message.leafHash : new Uint8Array()));
	        if (message.aunts) {
	            obj.aunts = message.aunts.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.aunts = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseProof();
	        message.total = object.total !== undefined && object.total !== null ? helpers_1.Long.fromValue(object.total) : helpers_1.Long.ZERO;
	        message.index = object.index !== undefined && object.index !== null ? helpers_1.Long.fromValue(object.index) : helpers_1.Long.ZERO;
	        message.leafHash = object.leafHash ?? new Uint8Array();
	        message.aunts = object.aunts?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            total: object?.total,
	            index: object?.index,
	            leafHash: object?.leaf_hash,
	            aunts: Array.isArray(object?.aunts) ? object.aunts.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.total = message.total;
	        obj.index = message.index;
	        obj.leaf_hash = message.leafHash;
	        if (message.aunts) {
	            obj.aunts = message.aunts.map(e => e);
	        }
	        else {
	            obj.aunts = [];
	        }
	        return obj;
	    }
	};
	function createBaseValueOp() {
	    return {
	        key: new Uint8Array(),
	        proof: undefined
	    };
	}
	exports.ValueOp = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.key.length !== 0) {
	            writer.uint32(10).bytes(message.key);
	        }
	        if (message.proof !== undefined) {
	            exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValueOp();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.key = reader.bytes();
	                    break;
	                case 2:
	                    message.proof = exports.Proof.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            key: (0, helpers_1.isSet)(object.key) ? (0, helpers_1.bytesFromBase64)(object.key) : new Uint8Array(),
	            proof: (0, helpers_1.isSet)(object.proof) ? exports.Proof.fromJSON(object.proof) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
	        message.proof !== undefined && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValueOp();
	        message.key = object.key ?? new Uint8Array();
	        message.proof = object.proof !== undefined && object.proof !== null ? exports.Proof.fromPartial(object.proof) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            key: object?.key,
	            proof: object.proof ? exports.Proof.fromSDK(object.proof) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.key = message.key;
	        message.proof !== undefined && (obj.proof = message.proof ? exports.Proof.toSDK(message.proof) : undefined);
	        return obj;
	    }
	};
	function createBaseDominoOp() {
	    return {
	        key: "",
	        input: "",
	        output: ""
	    };
	}
	exports.DominoOp = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.key !== "") {
	            writer.uint32(10).string(message.key);
	        }
	        if (message.input !== "") {
	            writer.uint32(18).string(message.input);
	        }
	        if (message.output !== "") {
	            writer.uint32(26).string(message.output);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDominoOp();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.key = reader.string();
	                    break;
	                case 2:
	                    message.input = reader.string();
	                    break;
	                case 3:
	                    message.output = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            key: (0, helpers_1.isSet)(object.key) ? String(object.key) : "",
	            input: (0, helpers_1.isSet)(object.input) ? String(object.input) : "",
	            output: (0, helpers_1.isSet)(object.output) ? String(object.output) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.key !== undefined && (obj.key = message.key);
	        message.input !== undefined && (obj.input = message.input);
	        message.output !== undefined && (obj.output = message.output);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDominoOp();
	        message.key = object.key ?? "";
	        message.input = object.input ?? "";
	        message.output = object.output ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            key: object?.key,
	            input: object?.input,
	            output: object?.output
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.key = message.key;
	        obj.input = message.input;
	        obj.output = message.output;
	        return obj;
	    }
	};
	function createBaseProofOp() {
	    return {
	        type: "",
	        key: new Uint8Array(),
	        data: new Uint8Array()
	    };
	}
	exports.ProofOp = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== "") {
	            writer.uint32(10).string(message.type);
	        }
	        if (message.key.length !== 0) {
	            writer.uint32(18).bytes(message.key);
	        }
	        if (message.data.length !== 0) {
	            writer.uint32(26).bytes(message.data);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseProofOp();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.string();
	                    break;
	                case 2:
	                    message.key = reader.bytes();
	                    break;
	                case 3:
	                    message.data = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? String(object.type) : "",
	            key: (0, helpers_1.isSet)(object.key) ? (0, helpers_1.bytesFromBase64)(object.key) : new Uint8Array(),
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = message.type);
	        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseProofOp();
	        message.type = object.type ?? "";
	        message.key = object.key ?? new Uint8Array();
	        message.data = object.data ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: object?.type,
	            key: object?.key,
	            data: object?.data
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.type = message.type;
	        obj.key = message.key;
	        obj.data = message.data;
	        return obj;
	    }
	};
	function createBaseProofOps() {
	    return {
	        ops: []
	    };
	}
	exports.ProofOps = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.ops) {
	            exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseProofOps();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            ops: Array.isArray(object?.ops) ? object.ops.map((e) => exports.ProofOp.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.ops) {
	            obj.ops = message.ops.map(e => e ? exports.ProofOp.toJSON(e) : undefined);
	        }
	        else {
	            obj.ops = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseProofOps();
	        message.ops = object.ops?.map(e => exports.ProofOp.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            ops: Array.isArray(object?.ops) ? object.ops.map((e) => exports.ProofOp.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.ops) {
	            obj.ops = message.ops.map(e => e ? exports.ProofOp.toSDK(e) : undefined);
	        }
	        else {
	            obj.ops = [];
	        }
	        return obj;
	    }
	};
	
} (proof));

proof.default;

var types$8 = {};

var __createBinding$c = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$c = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$c = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$c(result, mod, k);
    __setModuleDefault$c(result, mod);
    return result;
};
Object.defineProperty(types$8, "__esModule", { value: true });
types$8.Consensus = types$8.App = types$8.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$c = helpers;
const _m0$c = __importStar$c(minimal$1.exports);
types$8.protobufPackage = "tendermint.version";
function createBaseApp() {
    return {
        protocol: helpers_1$c.Long.UZERO,
        software: ""
    };
}
types$8.App = {
    encode(message, writer = _m0$c.Writer.create()) {
        if (!message.protocol.isZero()) {
            writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
            writer.uint32(18).string(message.software);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$c.Reader ? input : new _m0$c.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.uint64();
                    break;
                case 2:
                    message.software = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            protocol: (0, helpers_1$c.isSet)(object.protocol) ? helpers_1$c.Long.fromValue(object.protocol) : helpers_1$c.Long.UZERO,
            software: (0, helpers_1$c.isSet)(object.software) ? String(object.software) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.protocol !== undefined && (obj.protocol = (message.protocol || helpers_1$c.Long.UZERO).toString());
        message.software !== undefined && (obj.software = message.software);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseApp();
        message.protocol = object.protocol !== undefined && object.protocol !== null ? helpers_1$c.Long.fromValue(object.protocol) : helpers_1$c.Long.UZERO;
        message.software = object.software ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            protocol: object?.protocol,
            software: object?.software
        };
    },
    toSDK(message) {
        const obj = {};
        obj.protocol = message.protocol;
        obj.software = message.software;
        return obj;
    }
};
function createBaseConsensus() {
    return {
        block: helpers_1$c.Long.UZERO,
        app: helpers_1$c.Long.UZERO
    };
}
types$8.Consensus = {
    encode(message, writer = _m0$c.Writer.create()) {
        if (!message.block.isZero()) {
            writer.uint32(8).uint64(message.block);
        }
        if (!message.app.isZero()) {
            writer.uint32(16).uint64(message.app);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$c.Reader ? input : new _m0$c.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.block = reader.uint64();
                    break;
                case 2:
                    message.app = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            block: (0, helpers_1$c.isSet)(object.block) ? helpers_1$c.Long.fromValue(object.block) : helpers_1$c.Long.UZERO,
            app: (0, helpers_1$c.isSet)(object.app) ? helpers_1$c.Long.fromValue(object.app) : helpers_1$c.Long.UZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.block !== undefined && (obj.block = (message.block || helpers_1$c.Long.UZERO).toString());
        message.app !== undefined && (obj.app = (message.app || helpers_1$c.Long.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConsensus();
        message.block = object.block !== undefined && object.block !== null ? helpers_1$c.Long.fromValue(object.block) : helpers_1$c.Long.UZERO;
        message.app = object.app !== undefined && object.app !== null ? helpers_1$c.Long.fromValue(object.app) : helpers_1$c.Long.UZERO;
        return message;
    },
    fromSDK(object) {
        return {
            block: object?.block,
            app: object?.app
        };
    },
    toSDK(message) {
        const obj = {};
        obj.block = message.block;
        obj.app = message.app;
        return obj;
    }
};

var timestamp = {};

var __createBinding$b = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$b = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$b = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$b(result, mod, k);
    __setModuleDefault$b(result, mod);
    return result;
};
Object.defineProperty(timestamp, "__esModule", { value: true });
timestamp.Timestamp = timestamp.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$b = helpers;
const _m0$b = __importStar$b(minimal$1.exports);
timestamp.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
    return {
        seconds: helpers_1$b.Long.ZERO,
        nanos: 0
    };
}
timestamp.Timestamp = {
    encode(message, writer = _m0$b.Writer.create()) {
        if (!message.seconds.isZero()) {
            writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
            writer.uint32(16).int32(message.nanos);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$b.Reader ? input : new _m0$b.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.int64();
                    break;
                case 2:
                    message.nanos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            seconds: (0, helpers_1$b.isSet)(object.seconds) ? helpers_1$b.Long.fromValue(object.seconds) : helpers_1$b.Long.ZERO,
            nanos: (0, helpers_1$b.isSet)(object.nanos) ? Number(object.nanos) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.seconds !== undefined && (obj.seconds = (message.seconds || helpers_1$b.Long.ZERO).toString());
        message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTimestamp();
        message.seconds = object.seconds !== undefined && object.seconds !== null ? helpers_1$b.Long.fromValue(object.seconds) : helpers_1$b.Long.ZERO;
        message.nanos = object.nanos ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            seconds: object?.seconds,
            nanos: object?.nanos
        };
    },
    toSDK(message) {
        const obj = {};
        obj.seconds = message.seconds;
        obj.nanos = message.nanos;
        return obj;
    }
};

var validator = {};

var keys$1 = {};

var __createBinding$a = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$a = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$a = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$a(result, mod, k);
    __setModuleDefault$a(result, mod);
    return result;
};
Object.defineProperty(keys$1, "__esModule", { value: true });
keys$1.PublicKey = keys$1.protobufPackage = void 0;
/* eslint-disable */
const _m0$a = __importStar$a(minimal$1.exports);
const helpers_1$a = helpers;
keys$1.protobufPackage = "tendermint.crypto";
function createBasePublicKey() {
    return {
        ed25519: undefined,
        secp256k1: undefined
    };
}
keys$1.PublicKey = {
    encode(message, writer = _m0$a.Writer.create()) {
        if (message.ed25519 !== undefined) {
            writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== undefined) {
            writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$a.Reader ? input : new _m0$a.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                case 2:
                    message.secp256k1 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ed25519: (0, helpers_1$a.isSet)(object.ed25519) ? (0, helpers_1$a.bytesFromBase64)(object.ed25519) : undefined,
            secp256k1: (0, helpers_1$a.isSet)(object.secp256k1) ? (0, helpers_1$a.bytesFromBase64)(object.secp256k1) : undefined
        };
    },
    toJSON(message) {
        const obj = {};
        message.ed25519 !== undefined && (obj.ed25519 = message.ed25519 !== undefined ? (0, helpers_1$a.base64FromBytes)(message.ed25519) : undefined);
        message.secp256k1 !== undefined && (obj.secp256k1 = message.secp256k1 !== undefined ? (0, helpers_1$a.base64FromBytes)(message.secp256k1) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePublicKey();
        message.ed25519 = object.ed25519 ?? undefined;
        message.secp256k1 = object.secp256k1 ?? undefined;
        return message;
    },
    fromSDK(object) {
        return {
            ed25519: object?.ed25519,
            secp256k1: object?.secp256k1
        };
    },
    toSDK(message) {
        const obj = {};
        obj.ed25519 = message.ed25519;
        obj.secp256k1 = message.secp256k1;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SimpleValidator = exports.Validator = exports.ValidatorSet = exports.protobufPackage = void 0;
	/* eslint-disable */
	const keys_1 = keys$1;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "tendermint.types";
	function createBaseValidatorSet() {
	    return {
	        validators: [],
	        proposer: undefined,
	        totalVotingPower: helpers_1.Long.ZERO
	    };
	}
	exports.ValidatorSet = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.validators) {
	            exports.Validator.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.proposer !== undefined) {
	            exports.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.totalVotingPower.isZero()) {
	            writer.uint32(24).int64(message.totalVotingPower);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorSet();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validators.push(exports.Validator.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.proposer = exports.Validator.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.totalVotingPower = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.Validator.fromJSON(e)) : [],
	            proposer: (0, helpers_1.isSet)(object.proposer) ? exports.Validator.fromJSON(object.proposer) : undefined,
	            totalVotingPower: (0, helpers_1.isSet)(object.totalVotingPower) ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.Validator.toJSON(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.proposer !== undefined && (obj.proposer = message.proposer ? exports.Validator.toJSON(message.proposer) : undefined);
	        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorSet();
	        message.validators = object.validators?.map(e => exports.Validator.fromPartial(e)) || [];
	        message.proposer = object.proposer !== undefined && object.proposer !== null ? exports.Validator.fromPartial(object.proposer) : undefined;
	        message.totalVotingPower = object.totalVotingPower !== undefined && object.totalVotingPower !== null ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.Validator.fromSDK(e)) : [],
	            proposer: object.proposer ? exports.Validator.fromSDK(object.proposer) : undefined,
	            totalVotingPower: object?.total_voting_power
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.Validator.toSDK(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.proposer !== undefined && (obj.proposer = message.proposer ? exports.Validator.toSDK(message.proposer) : undefined);
	        obj.total_voting_power = message.totalVotingPower;
	        return obj;
	    }
	};
	function createBaseValidator() {
	    return {
	        address: new Uint8Array(),
	        pubKey: undefined,
	        votingPower: helpers_1.Long.ZERO,
	        proposerPriority: helpers_1.Long.ZERO
	    };
	}
	exports.Validator = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address.length !== 0) {
	            writer.uint32(10).bytes(message.address);
	        }
	        if (message.pubKey !== undefined) {
	            keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.votingPower.isZero()) {
	            writer.uint32(24).int64(message.votingPower);
	        }
	        if (!message.proposerPriority.isZero()) {
	            writer.uint32(32).int64(message.proposerPriority);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidator();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.bytes();
	                    break;
	                case 2:
	                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.votingPower = reader.int64();
	                    break;
	                case 4:
	                    message.proposerPriority = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? (0, helpers_1.bytesFromBase64)(object.address) : new Uint8Array(),
	            pubKey: (0, helpers_1.isSet)(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : undefined,
	            votingPower: (0, helpers_1.isSet)(object.votingPower) ? helpers_1.Long.fromValue(object.votingPower) : helpers_1.Long.ZERO,
	            proposerPriority: (0, helpers_1.isSet)(object.proposerPriority) ? helpers_1.Long.fromValue(object.proposerPriority) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== undefined ? message.address : new Uint8Array()));
	        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : undefined);
	        message.votingPower !== undefined && (obj.votingPower = (message.votingPower || helpers_1.Long.ZERO).toString());
	        message.proposerPriority !== undefined && (obj.proposerPriority = (message.proposerPriority || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidator();
	        message.address = object.address ?? new Uint8Array();
	        message.pubKey = object.pubKey !== undefined && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : undefined;
	        message.votingPower = object.votingPower !== undefined && object.votingPower !== null ? helpers_1.Long.fromValue(object.votingPower) : helpers_1.Long.ZERO;
	        message.proposerPriority = object.proposerPriority !== undefined && object.proposerPriority !== null ? helpers_1.Long.fromValue(object.proposerPriority) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            pubKey: object.pub_key ? keys_1.PublicKey.fromSDK(object.pub_key) : undefined,
	            votingPower: object?.voting_power,
	            proposerPriority: object?.proposer_priority
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.pubKey !== undefined && (obj.pub_key = message.pubKey ? keys_1.PublicKey.toSDK(message.pubKey) : undefined);
	        obj.voting_power = message.votingPower;
	        obj.proposer_priority = message.proposerPriority;
	        return obj;
	    }
	};
	function createBaseSimpleValidator() {
	    return {
	        pubKey: undefined,
	        votingPower: helpers_1.Long.ZERO
	    };
	}
	exports.SimpleValidator = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pubKey !== undefined) {
	            keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
	        }
	        if (!message.votingPower.isZero()) {
	            writer.uint32(16).int64(message.votingPower);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSimpleValidator();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.votingPower = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pubKey: (0, helpers_1.isSet)(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : undefined,
	            votingPower: (0, helpers_1.isSet)(object.votingPower) ? helpers_1.Long.fromValue(object.votingPower) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : undefined);
	        message.votingPower !== undefined && (obj.votingPower = (message.votingPower || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSimpleValidator();
	        message.pubKey = object.pubKey !== undefined && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : undefined;
	        message.votingPower = object.votingPower !== undefined && object.votingPower !== null ? helpers_1.Long.fromValue(object.votingPower) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pubKey: object.pub_key ? keys_1.PublicKey.fromSDK(object.pub_key) : undefined,
	            votingPower: object?.voting_power
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pubKey !== undefined && (obj.pub_key = message.pubKey ? keys_1.PublicKey.toSDK(message.pubKey) : undefined);
	        obj.voting_power = message.votingPower;
	        return obj;
	    }
	};
	
} (validator));

validator.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Reveal = exports.TxProof = exports.BlockMeta = exports.LightBlock = exports.SignedHeader = exports.Proposal = exports.CommitSig = exports.Commit = exports.Vote = exports.Data = exports.Header = exports.BlockID = exports.Part = exports.PartSetHeader = exports.signedMsgTypeToJSON = exports.signedMsgTypeFromJSON = exports.SignedMsgTypeSDKType = exports.SignedMsgType = exports.blockIDFlagToJSON = exports.blockIDFlagFromJSON = exports.BlockIDFlagSDKType = exports.BlockIDFlag = exports.protobufPackage = void 0;
	/* eslint-disable */
	const proof_1 = proof;
	const types_1 = types$8;
	const timestamp_1 = timestamp;
	const validator_1 = validator;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "tendermint.types";
	/** BlockIdFlag indicates which BlcokID the signature is for */
	var BlockIDFlag;
	(function (BlockIDFlag) {
	    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
	    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
	    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
	    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
	    BlockIDFlag[BlockIDFlag["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(BlockIDFlag = exports.BlockIDFlag || (exports.BlockIDFlag = {}));
	exports.BlockIDFlagSDKType = BlockIDFlag;
	function blockIDFlagFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "BLOCK_ID_FLAG_UNKNOWN":
	            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
	        case 1:
	        case "BLOCK_ID_FLAG_ABSENT":
	            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
	        case 2:
	        case "BLOCK_ID_FLAG_COMMIT":
	            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
	        case 3:
	        case "BLOCK_ID_FLAG_NIL":
	            return BlockIDFlag.BLOCK_ID_FLAG_NIL;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return BlockIDFlag.UNRECOGNIZED;
	    }
	}
	exports.blockIDFlagFromJSON = blockIDFlagFromJSON;
	function blockIDFlagToJSON(object) {
	    switch (object) {
	        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
	            return "BLOCK_ID_FLAG_UNKNOWN";
	        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
	            return "BLOCK_ID_FLAG_ABSENT";
	        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
	            return "BLOCK_ID_FLAG_COMMIT";
	        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
	            return "BLOCK_ID_FLAG_NIL";
	        case BlockIDFlag.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.blockIDFlagToJSON = blockIDFlagToJSON;
	/** SignedMsgType is a type of signed message in the consensus. */
	var SignedMsgType;
	(function (SignedMsgType) {
	    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
	    /** SIGNED_MSG_TYPE_PREVOTE - Votes */
	    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
	    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
	    /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */
	    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
	    SignedMsgType[SignedMsgType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(SignedMsgType = exports.SignedMsgType || (exports.SignedMsgType = {}));
	exports.SignedMsgTypeSDKType = SignedMsgType;
	function signedMsgTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "SIGNED_MSG_TYPE_UNKNOWN":
	            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
	        case 1:
	        case "SIGNED_MSG_TYPE_PREVOTE":
	            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
	        case 2:
	        case "SIGNED_MSG_TYPE_PRECOMMIT":
	            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
	        case 32:
	        case "SIGNED_MSG_TYPE_PROPOSAL":
	            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return SignedMsgType.UNRECOGNIZED;
	    }
	}
	exports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
	function signedMsgTypeToJSON(object) {
	    switch (object) {
	        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
	            return "SIGNED_MSG_TYPE_UNKNOWN";
	        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
	            return "SIGNED_MSG_TYPE_PREVOTE";
	        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
	            return "SIGNED_MSG_TYPE_PRECOMMIT";
	        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
	            return "SIGNED_MSG_TYPE_PROPOSAL";
	        case SignedMsgType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.signedMsgTypeToJSON = signedMsgTypeToJSON;
	function createBasePartSetHeader() {
	    return {
	        total: 0,
	        hash: new Uint8Array()
	    };
	}
	exports.PartSetHeader = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.total !== 0) {
	            writer.uint32(8).uint32(message.total);
	        }
	        if (message.hash.length !== 0) {
	            writer.uint32(18).bytes(message.hash);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBasePartSetHeader();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.total = reader.uint32();
	                    break;
	                case 2:
	                    message.hash = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            total: (0, helpers_1.isSet)(object.total) ? Number(object.total) : 0,
	            hash: (0, helpers_1.isSet)(object.hash) ? (0, helpers_1.bytesFromBase64)(object.hash) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.total !== undefined && (obj.total = Math.round(message.total));
	        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBasePartSetHeader();
	        message.total = object.total ?? 0;
	        message.hash = object.hash ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            total: object?.total,
	            hash: object?.hash
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.total = message.total;
	        obj.hash = message.hash;
	        return obj;
	    }
	};
	function createBasePart() {
	    return {
	        index: 0,
	        bytes: new Uint8Array(),
	        proof: undefined
	    };
	}
	exports.Part = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.index !== 0) {
	            writer.uint32(8).uint32(message.index);
	        }
	        if (message.bytes.length !== 0) {
	            writer.uint32(18).bytes(message.bytes);
	        }
	        if (message.proof !== undefined) {
	            proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBasePart();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.index = reader.uint32();
	                    break;
	                case 2:
	                    message.bytes = reader.bytes();
	                    break;
	                case 3:
	                    message.proof = proof_1.Proof.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            index: (0, helpers_1.isSet)(object.index) ? Number(object.index) : 0,
	            bytes: (0, helpers_1.isSet)(object.bytes) ? (0, helpers_1.bytesFromBase64)(object.bytes) : new Uint8Array(),
	            proof: (0, helpers_1.isSet)(object.proof) ? proof_1.Proof.fromJSON(object.proof) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.index !== undefined && (obj.index = Math.round(message.index));
	        message.bytes !== undefined && (obj.bytes = (0, helpers_1.base64FromBytes)(message.bytes !== undefined ? message.bytes : new Uint8Array()));
	        message.proof !== undefined && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBasePart();
	        message.index = object.index ?? 0;
	        message.bytes = object.bytes ?? new Uint8Array();
	        message.proof = object.proof !== undefined && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            index: object?.index,
	            bytes: object?.bytes,
	            proof: object.proof ? proof_1.Proof.fromSDK(object.proof) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.index = message.index;
	        obj.bytes = message.bytes;
	        message.proof !== undefined && (obj.proof = message.proof ? proof_1.Proof.toSDK(message.proof) : undefined);
	        return obj;
	    }
	};
	function createBaseBlockID() {
	    return {
	        hash: new Uint8Array(),
	        partSetHeader: undefined
	    };
	}
	exports.BlockID = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.hash.length !== 0) {
	            writer.uint32(10).bytes(message.hash);
	        }
	        if (message.partSetHeader !== undefined) {
	            exports.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBlockID();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.hash = reader.bytes();
	                    break;
	                case 2:
	                    message.partSetHeader = exports.PartSetHeader.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            hash: (0, helpers_1.isSet)(object.hash) ? (0, helpers_1.bytesFromBase64)(object.hash) : new Uint8Array(),
	            partSetHeader: (0, helpers_1.isSet)(object.partSetHeader) ? exports.PartSetHeader.fromJSON(object.partSetHeader) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
	        message.partSetHeader !== undefined && (obj.partSetHeader = message.partSetHeader ? exports.PartSetHeader.toJSON(message.partSetHeader) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBlockID();
	        message.hash = object.hash ?? new Uint8Array();
	        message.partSetHeader = object.partSetHeader !== undefined && object.partSetHeader !== null ? exports.PartSetHeader.fromPartial(object.partSetHeader) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            hash: object?.hash,
	            partSetHeader: object.part_set_header ? exports.PartSetHeader.fromSDK(object.part_set_header) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.hash = message.hash;
	        message.partSetHeader !== undefined && (obj.part_set_header = message.partSetHeader ? exports.PartSetHeader.toSDK(message.partSetHeader) : undefined);
	        return obj;
	    }
	};
	function createBaseHeader() {
	    return {
	        version: undefined,
	        chainId: "",
	        height: helpers_1.Long.ZERO,
	        time: undefined,
	        lastBlockId: undefined,
	        lastCommitHash: new Uint8Array(),
	        dataHash: new Uint8Array(),
	        validatorsHash: new Uint8Array(),
	        nextValidatorsHash: new Uint8Array(),
	        consensusHash: new Uint8Array(),
	        appHash: new Uint8Array(),
	        lastResultsHash: new Uint8Array(),
	        evidenceHash: new Uint8Array(),
	        proposerAddress: new Uint8Array()
	    };
	}
	exports.Header = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.version !== undefined) {
	            types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.chainId !== "") {
	            writer.uint32(18).string(message.chainId);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(24).int64(message.height);
	        }
	        if (message.time !== undefined) {
	            timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.lastBlockId !== undefined) {
	            exports.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
	        }
	        if (message.lastCommitHash.length !== 0) {
	            writer.uint32(50).bytes(message.lastCommitHash);
	        }
	        if (message.dataHash.length !== 0) {
	            writer.uint32(58).bytes(message.dataHash);
	        }
	        if (message.validatorsHash.length !== 0) {
	            writer.uint32(66).bytes(message.validatorsHash);
	        }
	        if (message.nextValidatorsHash.length !== 0) {
	            writer.uint32(74).bytes(message.nextValidatorsHash);
	        }
	        if (message.consensusHash.length !== 0) {
	            writer.uint32(82).bytes(message.consensusHash);
	        }
	        if (message.appHash.length !== 0) {
	            writer.uint32(90).bytes(message.appHash);
	        }
	        if (message.lastResultsHash.length !== 0) {
	            writer.uint32(98).bytes(message.lastResultsHash);
	        }
	        if (message.evidenceHash.length !== 0) {
	            writer.uint32(106).bytes(message.evidenceHash);
	        }
	        if (message.proposerAddress.length !== 0) {
	            writer.uint32(114).bytes(message.proposerAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseHeader();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.version = types_1.Consensus.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.chainId = reader.string();
	                    break;
	                case 3:
	                    message.height = reader.int64();
	                    break;
	                case 4:
	                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 5:
	                    message.lastBlockId = exports.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 6:
	                    message.lastCommitHash = reader.bytes();
	                    break;
	                case 7:
	                    message.dataHash = reader.bytes();
	                    break;
	                case 8:
	                    message.validatorsHash = reader.bytes();
	                    break;
	                case 9:
	                    message.nextValidatorsHash = reader.bytes();
	                    break;
	                case 10:
	                    message.consensusHash = reader.bytes();
	                    break;
	                case 11:
	                    message.appHash = reader.bytes();
	                    break;
	                case 12:
	                    message.lastResultsHash = reader.bytes();
	                    break;
	                case 13:
	                    message.evidenceHash = reader.bytes();
	                    break;
	                case 14:
	                    message.proposerAddress = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            version: (0, helpers_1.isSet)(object.version) ? types_1.Consensus.fromJSON(object.version) : undefined,
	            chainId: (0, helpers_1.isSet)(object.chainId) ? String(object.chainId) : "",
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            time: (0, helpers_1.isSet)(object.time) ? (0, helpers_1.fromJsonTimestamp)(object.time) : undefined,
	            lastBlockId: (0, helpers_1.isSet)(object.lastBlockId) ? exports.BlockID.fromJSON(object.lastBlockId) : undefined,
	            lastCommitHash: (0, helpers_1.isSet)(object.lastCommitHash) ? (0, helpers_1.bytesFromBase64)(object.lastCommitHash) : new Uint8Array(),
	            dataHash: (0, helpers_1.isSet)(object.dataHash) ? (0, helpers_1.bytesFromBase64)(object.dataHash) : new Uint8Array(),
	            validatorsHash: (0, helpers_1.isSet)(object.validatorsHash) ? (0, helpers_1.bytesFromBase64)(object.validatorsHash) : new Uint8Array(),
	            nextValidatorsHash: (0, helpers_1.isSet)(object.nextValidatorsHash) ? (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash) : new Uint8Array(),
	            consensusHash: (0, helpers_1.isSet)(object.consensusHash) ? (0, helpers_1.bytesFromBase64)(object.consensusHash) : new Uint8Array(),
	            appHash: (0, helpers_1.isSet)(object.appHash) ? (0, helpers_1.bytesFromBase64)(object.appHash) : new Uint8Array(),
	            lastResultsHash: (0, helpers_1.isSet)(object.lastResultsHash) ? (0, helpers_1.bytesFromBase64)(object.lastResultsHash) : new Uint8Array(),
	            evidenceHash: (0, helpers_1.isSet)(object.evidenceHash) ? (0, helpers_1.bytesFromBase64)(object.evidenceHash) : new Uint8Array(),
	            proposerAddress: (0, helpers_1.isSet)(object.proposerAddress) ? (0, helpers_1.bytesFromBase64)(object.proposerAddress) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.version !== undefined && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : undefined);
	        message.chainId !== undefined && (obj.chainId = message.chainId);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
	        message.lastBlockId !== undefined && (obj.lastBlockId = message.lastBlockId ? exports.BlockID.toJSON(message.lastBlockId) : undefined);
	        message.lastCommitHash !== undefined && (obj.lastCommitHash = (0, helpers_1.base64FromBytes)(message.lastCommitHash !== undefined ? message.lastCommitHash : new Uint8Array()));
	        message.dataHash !== undefined && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== undefined ? message.dataHash : new Uint8Array()));
	        message.validatorsHash !== undefined && (obj.validatorsHash = (0, helpers_1.base64FromBytes)(message.validatorsHash !== undefined ? message.validatorsHash : new Uint8Array()));
	        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
	        message.consensusHash !== undefined && (obj.consensusHash = (0, helpers_1.base64FromBytes)(message.consensusHash !== undefined ? message.consensusHash : new Uint8Array()));
	        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
	        message.lastResultsHash !== undefined && (obj.lastResultsHash = (0, helpers_1.base64FromBytes)(message.lastResultsHash !== undefined ? message.lastResultsHash : new Uint8Array()));
	        message.evidenceHash !== undefined && (obj.evidenceHash = (0, helpers_1.base64FromBytes)(message.evidenceHash !== undefined ? message.evidenceHash : new Uint8Array()));
	        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseHeader();
	        message.version = object.version !== undefined && object.version !== null ? types_1.Consensus.fromPartial(object.version) : undefined;
	        message.chainId = object.chainId ?? "";
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.time = object.time !== undefined && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : undefined;
	        message.lastBlockId = object.lastBlockId !== undefined && object.lastBlockId !== null ? exports.BlockID.fromPartial(object.lastBlockId) : undefined;
	        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();
	        message.dataHash = object.dataHash ?? new Uint8Array();
	        message.validatorsHash = object.validatorsHash ?? new Uint8Array();
	        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
	        message.consensusHash = object.consensusHash ?? new Uint8Array();
	        message.appHash = object.appHash ?? new Uint8Array();
	        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();
	        message.evidenceHash = object.evidenceHash ?? new Uint8Array();
	        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            version: object.version ? types_1.Consensus.fromSDK(object.version) : undefined,
	            chainId: object?.chain_id,
	            height: object?.height,
	            time: object.time ? timestamp_1.Timestamp.fromSDK(object.time) : undefined,
	            lastBlockId: object.last_block_id ? exports.BlockID.fromSDK(object.last_block_id) : undefined,
	            lastCommitHash: object?.last_commit_hash,
	            dataHash: object?.data_hash,
	            validatorsHash: object?.validators_hash,
	            nextValidatorsHash: object?.next_validators_hash,
	            consensusHash: object?.consensus_hash,
	            appHash: object?.app_hash,
	            lastResultsHash: object?.last_results_hash,
	            evidenceHash: object?.evidence_hash,
	            proposerAddress: object?.proposer_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.version !== undefined && (obj.version = message.version ? types_1.Consensus.toSDK(message.version) : undefined);
	        obj.chain_id = message.chainId;
	        obj.height = message.height;
	        message.time !== undefined && (obj.time = message.time ? timestamp_1.Timestamp.toSDK(message.time) : undefined);
	        message.lastBlockId !== undefined && (obj.last_block_id = message.lastBlockId ? exports.BlockID.toSDK(message.lastBlockId) : undefined);
	        obj.last_commit_hash = message.lastCommitHash;
	        obj.data_hash = message.dataHash;
	        obj.validators_hash = message.validatorsHash;
	        obj.next_validators_hash = message.nextValidatorsHash;
	        obj.consensus_hash = message.consensusHash;
	        obj.app_hash = message.appHash;
	        obj.last_results_hash = message.lastResultsHash;
	        obj.evidence_hash = message.evidenceHash;
	        obj.proposer_address = message.proposerAddress;
	        return obj;
	    }
	};
	function createBaseData() {
	    return {
	        txs: []
	    };
	}
	exports.Data = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.txs) {
	            writer.uint32(10).bytes(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseData();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txs.push(reader.bytes());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.txs = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseData();
	        message.txs = object.txs?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e);
	        }
	        else {
	            obj.txs = [];
	        }
	        return obj;
	    }
	};
	function createBaseVote() {
	    return {
	        type: 0,
	        height: helpers_1.Long.ZERO,
	        round: 0,
	        blockId: undefined,
	        timestamp: undefined,
	        validatorAddress: new Uint8Array(),
	        validatorIndex: 0,
	        signature: new Uint8Array()
	    };
	}
	exports.Vote = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== 0) {
	            writer.uint32(8).int32(message.type);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(16).int64(message.height);
	        }
	        if (message.round !== 0) {
	            writer.uint32(24).int32(message.round);
	        }
	        if (message.blockId !== undefined) {
	            exports.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.timestamp !== undefined) {
	            timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
	        }
	        if (message.validatorAddress.length !== 0) {
	            writer.uint32(50).bytes(message.validatorAddress);
	        }
	        if (message.validatorIndex !== 0) {
	            writer.uint32(56).int32(message.validatorIndex);
	        }
	        if (message.signature.length !== 0) {
	            writer.uint32(66).bytes(message.signature);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseVote();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.int32();
	                    break;
	                case 2:
	                    message.height = reader.int64();
	                    break;
	                case 3:
	                    message.round = reader.int32();
	                    break;
	                case 4:
	                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 5:
	                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 6:
	                    message.validatorAddress = reader.bytes();
	                    break;
	                case 7:
	                    message.validatorIndex = reader.int32();
	                    break;
	                case 8:
	                    message.signature = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            round: (0, helpers_1.isSet)(object.round) ? Number(object.round) : 0,
	            blockId: (0, helpers_1.isSet)(object.blockId) ? exports.BlockID.fromJSON(object.blockId) : undefined,
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? (0, helpers_1.fromJsonTimestamp)(object.timestamp) : undefined,
	            validatorAddress: (0, helpers_1.isSet)(object.validatorAddress) ? (0, helpers_1.bytesFromBase64)(object.validatorAddress) : new Uint8Array(),
	            validatorIndex: (0, helpers_1.isSet)(object.validatorIndex) ? Number(object.validatorIndex) : 0,
	            signature: (0, helpers_1.isSet)(object.signature) ? (0, helpers_1.bytesFromBase64)(object.signature) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = signedMsgTypeToJSON(message.type));
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.round !== undefined && (obj.round = Math.round(message.round));
	        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
	        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
	        message.validatorAddress !== undefined && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== undefined ? message.validatorAddress : new Uint8Array()));
	        message.validatorIndex !== undefined && (obj.validatorIndex = Math.round(message.validatorIndex));
	        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseVote();
	        message.type = object.type ?? 0;
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.round = object.round ?? 0;
	        message.blockId = object.blockId !== undefined && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : undefined;
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : undefined;
	        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
	        message.validatorIndex = object.validatorIndex ?? 0;
	        message.signature = object.signature ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
	            height: object?.height,
	            round: object?.round,
	            blockId: object.block_id ? exports.BlockID.fromSDK(object.block_id) : undefined,
	            timestamp: object.timestamp ? timestamp_1.Timestamp.fromSDK(object.timestamp) : undefined,
	            validatorAddress: object?.validator_address,
	            validatorIndex: object?.validator_index,
	            signature: object?.signature
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = signedMsgTypeToJSON(message.type));
	        obj.height = message.height;
	        obj.round = message.round;
	        message.blockId !== undefined && (obj.block_id = message.blockId ? exports.BlockID.toSDK(message.blockId) : undefined);
	        message.timestamp !== undefined && (obj.timestamp = message.timestamp ? timestamp_1.Timestamp.toSDK(message.timestamp) : undefined);
	        obj.validator_address = message.validatorAddress;
	        obj.validator_index = message.validatorIndex;
	        obj.signature = message.signature;
	        return obj;
	    }
	};
	function createBaseCommit() {
	    return {
	        height: helpers_1.Long.ZERO,
	        round: 0,
	        blockId: undefined,
	        signatures: []
	    };
	}
	exports.Commit = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        if (message.round !== 0) {
	            writer.uint32(16).int32(message.round);
	        }
	        if (message.blockId !== undefined) {
	            exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
	        }
	        for (const v of message.signatures) {
	            exports.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseCommit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                case 2:
	                    message.round = reader.int32();
	                    break;
	                case 3:
	                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.signatures.push(exports.CommitSig.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            round: (0, helpers_1.isSet)(object.round) ? Number(object.round) : 0,
	            blockId: (0, helpers_1.isSet)(object.blockId) ? exports.BlockID.fromJSON(object.blockId) : undefined,
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => exports.CommitSig.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.round !== undefined && (obj.round = Math.round(message.round));
	        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e ? exports.CommitSig.toJSON(e) : undefined);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseCommit();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.round = object.round ?? 0;
	        message.blockId = object.blockId !== undefined && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : undefined;
	        message.signatures = object.signatures?.map(e => exports.CommitSig.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            round: object?.round,
	            blockId: object.block_id ? exports.BlockID.fromSDK(object.block_id) : undefined,
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => exports.CommitSig.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        obj.round = message.round;
	        message.blockId !== undefined && (obj.block_id = message.blockId ? exports.BlockID.toSDK(message.blockId) : undefined);
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e ? exports.CommitSig.toSDK(e) : undefined);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    }
	};
	function createBaseCommitSig() {
	    return {
	        blockIdFlag: 0,
	        validatorAddress: new Uint8Array(),
	        timestamp: undefined,
	        signature: new Uint8Array()
	    };
	}
	exports.CommitSig = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.blockIdFlag !== 0) {
	            writer.uint32(8).int32(message.blockIdFlag);
	        }
	        if (message.validatorAddress.length !== 0) {
	            writer.uint32(18).bytes(message.validatorAddress);
	        }
	        if (message.timestamp !== undefined) {
	            timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.signature.length !== 0) {
	            writer.uint32(34).bytes(message.signature);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseCommitSig();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blockIdFlag = reader.int32();
	                    break;
	                case 2:
	                    message.validatorAddress = reader.bytes();
	                    break;
	                case 3:
	                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.signature = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blockIdFlag: (0, helpers_1.isSet)(object.blockIdFlag) ? blockIDFlagFromJSON(object.blockIdFlag) : 0,
	            validatorAddress: (0, helpers_1.isSet)(object.validatorAddress) ? (0, helpers_1.bytesFromBase64)(object.validatorAddress) : new Uint8Array(),
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? (0, helpers_1.fromJsonTimestamp)(object.timestamp) : undefined,
	            signature: (0, helpers_1.isSet)(object.signature) ? (0, helpers_1.bytesFromBase64)(object.signature) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blockIdFlag !== undefined && (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));
	        message.validatorAddress !== undefined && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== undefined ? message.validatorAddress : new Uint8Array()));
	        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
	        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseCommitSig();
	        message.blockIdFlag = object.blockIdFlag ?? 0;
	        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : undefined;
	        message.signature = object.signature ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blockIdFlag: (0, helpers_1.isSet)(object.block_id_flag) ? blockIDFlagFromJSON(object.block_id_flag) : 0,
	            validatorAddress: object?.validator_address,
	            timestamp: object.timestamp ? timestamp_1.Timestamp.fromSDK(object.timestamp) : undefined,
	            signature: object?.signature
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.blockIdFlag !== undefined && (obj.block_id_flag = blockIDFlagToJSON(message.blockIdFlag));
	        obj.validator_address = message.validatorAddress;
	        message.timestamp !== undefined && (obj.timestamp = message.timestamp ? timestamp_1.Timestamp.toSDK(message.timestamp) : undefined);
	        obj.signature = message.signature;
	        return obj;
	    }
	};
	function createBaseProposal() {
	    return {
	        type: 0,
	        height: helpers_1.Long.ZERO,
	        round: 0,
	        polRound: 0,
	        blockId: undefined,
	        timestamp: undefined,
	        signature: new Uint8Array()
	    };
	}
	exports.Proposal = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== 0) {
	            writer.uint32(8).int32(message.type);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(16).int64(message.height);
	        }
	        if (message.round !== 0) {
	            writer.uint32(24).int32(message.round);
	        }
	        if (message.polRound !== 0) {
	            writer.uint32(32).int32(message.polRound);
	        }
	        if (message.blockId !== undefined) {
	            exports.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
	        }
	        if (message.timestamp !== undefined) {
	            timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
	        }
	        if (message.signature.length !== 0) {
	            writer.uint32(58).bytes(message.signature);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseProposal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.int32();
	                    break;
	                case 2:
	                    message.height = reader.int64();
	                    break;
	                case 3:
	                    message.round = reader.int32();
	                    break;
	                case 4:
	                    message.polRound = reader.int32();
	                    break;
	                case 5:
	                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 6:
	                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 7:
	                    message.signature = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            round: (0, helpers_1.isSet)(object.round) ? Number(object.round) : 0,
	            polRound: (0, helpers_1.isSet)(object.polRound) ? Number(object.polRound) : 0,
	            blockId: (0, helpers_1.isSet)(object.blockId) ? exports.BlockID.fromJSON(object.blockId) : undefined,
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? (0, helpers_1.fromJsonTimestamp)(object.timestamp) : undefined,
	            signature: (0, helpers_1.isSet)(object.signature) ? (0, helpers_1.bytesFromBase64)(object.signature) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = signedMsgTypeToJSON(message.type));
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.round !== undefined && (obj.round = Math.round(message.round));
	        message.polRound !== undefined && (obj.polRound = Math.round(message.polRound));
	        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
	        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
	        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseProposal();
	        message.type = object.type ?? 0;
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.round = object.round ?? 0;
	        message.polRound = object.polRound ?? 0;
	        message.blockId = object.blockId !== undefined && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : undefined;
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : undefined;
	        message.signature = object.signature ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
	            height: object?.height,
	            round: object?.round,
	            polRound: object?.pol_round,
	            blockId: object.block_id ? exports.BlockID.fromSDK(object.block_id) : undefined,
	            timestamp: object.timestamp ? timestamp_1.Timestamp.fromSDK(object.timestamp) : undefined,
	            signature: object?.signature
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = signedMsgTypeToJSON(message.type));
	        obj.height = message.height;
	        obj.round = message.round;
	        obj.pol_round = message.polRound;
	        message.blockId !== undefined && (obj.block_id = message.blockId ? exports.BlockID.toSDK(message.blockId) : undefined);
	        message.timestamp !== undefined && (obj.timestamp = message.timestamp ? timestamp_1.Timestamp.toSDK(message.timestamp) : undefined);
	        obj.signature = message.signature;
	        return obj;
	    }
	};
	function createBaseSignedHeader() {
	    return {
	        header: undefined,
	        commit: undefined
	    };
	}
	exports.SignedHeader = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.header !== undefined) {
	            exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.commit !== undefined) {
	            exports.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignedHeader();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.header = exports.Header.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.commit = exports.Commit.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            header: (0, helpers_1.isSet)(object.header) ? exports.Header.fromJSON(object.header) : undefined,
	            commit: (0, helpers_1.isSet)(object.commit) ? exports.Commit.fromJSON(object.commit) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.header !== undefined && (obj.header = message.header ? exports.Header.toJSON(message.header) : undefined);
	        message.commit !== undefined && (obj.commit = message.commit ? exports.Commit.toJSON(message.commit) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignedHeader();
	        message.header = object.header !== undefined && object.header !== null ? exports.Header.fromPartial(object.header) : undefined;
	        message.commit = object.commit !== undefined && object.commit !== null ? exports.Commit.fromPartial(object.commit) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            header: object.header ? exports.Header.fromSDK(object.header) : undefined,
	            commit: object.commit ? exports.Commit.fromSDK(object.commit) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.header !== undefined && (obj.header = message.header ? exports.Header.toSDK(message.header) : undefined);
	        message.commit !== undefined && (obj.commit = message.commit ? exports.Commit.toSDK(message.commit) : undefined);
	        return obj;
	    }
	};
	function createBaseLightBlock() {
	    return {
	        signedHeader: undefined,
	        validatorSet: undefined
	    };
	}
	exports.LightBlock = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.signedHeader !== undefined) {
	            exports.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.validatorSet !== undefined) {
	            validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseLightBlock();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.signedHeader = exports.SignedHeader.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            signedHeader: (0, helpers_1.isSet)(object.signedHeader) ? exports.SignedHeader.fromJSON(object.signedHeader) : undefined,
	            validatorSet: (0, helpers_1.isSet)(object.validatorSet) ? validator_1.ValidatorSet.fromJSON(object.validatorSet) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.signedHeader !== undefined && (obj.signedHeader = message.signedHeader ? exports.SignedHeader.toJSON(message.signedHeader) : undefined);
	        message.validatorSet !== undefined && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseLightBlock();
	        message.signedHeader = object.signedHeader !== undefined && object.signedHeader !== null ? exports.SignedHeader.fromPartial(object.signedHeader) : undefined;
	        message.validatorSet = object.validatorSet !== undefined && object.validatorSet !== null ? validator_1.ValidatorSet.fromPartial(object.validatorSet) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            signedHeader: object.signed_header ? exports.SignedHeader.fromSDK(object.signed_header) : undefined,
	            validatorSet: object.validator_set ? validator_1.ValidatorSet.fromSDK(object.validator_set) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.signedHeader !== undefined && (obj.signed_header = message.signedHeader ? exports.SignedHeader.toSDK(message.signedHeader) : undefined);
	        message.validatorSet !== undefined && (obj.validator_set = message.validatorSet ? validator_1.ValidatorSet.toSDK(message.validatorSet) : undefined);
	        return obj;
	    }
	};
	function createBaseBlockMeta() {
	    return {
	        blockId: undefined,
	        blockSize: helpers_1.Long.ZERO,
	        header: undefined,
	        numTxs: helpers_1.Long.ZERO
	    };
	}
	exports.BlockMeta = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.blockId !== undefined) {
	            exports.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
	        }
	        if (!message.blockSize.isZero()) {
	            writer.uint32(16).int64(message.blockSize);
	        }
	        if (message.header !== undefined) {
	            exports.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
	        }
	        if (!message.numTxs.isZero()) {
	            writer.uint32(32).int64(message.numTxs);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBlockMeta();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.blockSize = reader.int64();
	                    break;
	                case 3:
	                    message.header = exports.Header.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.numTxs = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blockId: (0, helpers_1.isSet)(object.blockId) ? exports.BlockID.fromJSON(object.blockId) : undefined,
	            blockSize: (0, helpers_1.isSet)(object.blockSize) ? helpers_1.Long.fromValue(object.blockSize) : helpers_1.Long.ZERO,
	            header: (0, helpers_1.isSet)(object.header) ? exports.Header.fromJSON(object.header) : undefined,
	            numTxs: (0, helpers_1.isSet)(object.numTxs) ? helpers_1.Long.fromValue(object.numTxs) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
	        message.blockSize !== undefined && (obj.blockSize = (message.blockSize || helpers_1.Long.ZERO).toString());
	        message.header !== undefined && (obj.header = message.header ? exports.Header.toJSON(message.header) : undefined);
	        message.numTxs !== undefined && (obj.numTxs = (message.numTxs || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBlockMeta();
	        message.blockId = object.blockId !== undefined && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : undefined;
	        message.blockSize = object.blockSize !== undefined && object.blockSize !== null ? helpers_1.Long.fromValue(object.blockSize) : helpers_1.Long.ZERO;
	        message.header = object.header !== undefined && object.header !== null ? exports.Header.fromPartial(object.header) : undefined;
	        message.numTxs = object.numTxs !== undefined && object.numTxs !== null ? helpers_1.Long.fromValue(object.numTxs) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blockId: object.block_id ? exports.BlockID.fromSDK(object.block_id) : undefined,
	            blockSize: object?.block_size,
	            header: object.header ? exports.Header.fromSDK(object.header) : undefined,
	            numTxs: object?.num_txs
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.blockId !== undefined && (obj.block_id = message.blockId ? exports.BlockID.toSDK(message.blockId) : undefined);
	        obj.block_size = message.blockSize;
	        message.header !== undefined && (obj.header = message.header ? exports.Header.toSDK(message.header) : undefined);
	        obj.num_txs = message.numTxs;
	        return obj;
	    }
	};
	function createBaseTxProof() {
	    return {
	        rootHash: new Uint8Array(),
	        data: new Uint8Array(),
	        proof: undefined
	    };
	}
	exports.TxProof = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.rootHash.length !== 0) {
	            writer.uint32(10).bytes(message.rootHash);
	        }
	        if (message.data.length !== 0) {
	            writer.uint32(18).bytes(message.data);
	        }
	        if (message.proof !== undefined) {
	            proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxProof();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.rootHash = reader.bytes();
	                    break;
	                case 2:
	                    message.data = reader.bytes();
	                    break;
	                case 3:
	                    message.proof = proof_1.Proof.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            rootHash: (0, helpers_1.isSet)(object.rootHash) ? (0, helpers_1.bytesFromBase64)(object.rootHash) : new Uint8Array(),
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array(),
	            proof: (0, helpers_1.isSet)(object.proof) ? proof_1.Proof.fromJSON(object.proof) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.rootHash !== undefined && (obj.rootHash = (0, helpers_1.base64FromBytes)(message.rootHash !== undefined ? message.rootHash : new Uint8Array()));
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        message.proof !== undefined && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxProof();
	        message.rootHash = object.rootHash ?? new Uint8Array();
	        message.data = object.data ?? new Uint8Array();
	        message.proof = object.proof !== undefined && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            rootHash: object?.root_hash,
	            data: object?.data,
	            proof: object.proof ? proof_1.Proof.fromSDK(object.proof) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.root_hash = message.rootHash;
	        obj.data = message.data;
	        message.proof !== undefined && (obj.proof = message.proof ? proof_1.Proof.toSDK(message.proof) : undefined);
	        return obj;
	    }
	};
	function createBaseReveal() {
	    return {
	        height: helpers_1.Long.ZERO,
	        signature: new Uint8Array()
	    };
	}
	exports.Reveal = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        if (message.signature.length !== 0) {
	            writer.uint32(18).bytes(message.signature);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseReveal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                case 2:
	                    message.signature = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            signature: (0, helpers_1.isSet)(object.signature) ? (0, helpers_1.bytesFromBase64)(object.signature) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseReveal();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.signature = object.signature ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            signature: object?.signature
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        obj.signature = message.signature;
	        return obj;
	    }
	};
	
} (types$9));

types$9.default;

var block = {};

var evidence = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.EvidenceList = exports.LightClientAttackEvidence = exports.DuplicateVoteEvidence = exports.Evidence = exports.protobufPackage = void 0;
	/* eslint-disable */
	const types_1 = types$9;
	const timestamp_1 = timestamp;
	const validator_1 = validator;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "tendermint.types";
	function createBaseEvidence() {
	    return {
	        duplicateVoteEvidence: undefined,
	        lightClientAttackEvidence: undefined
	    };
	}
	exports.Evidence = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.duplicateVoteEvidence !== undefined) {
	            exports.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.lightClientAttackEvidence !== undefined) {
	            exports.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseEvidence();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.duplicateVoteEvidence = exports.DuplicateVoteEvidence.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.lightClientAttackEvidence = exports.LightClientAttackEvidence.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            duplicateVoteEvidence: (0, helpers_1.isSet)(object.duplicateVoteEvidence) ? exports.DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence) : undefined,
	            lightClientAttackEvidence: (0, helpers_1.isSet)(object.lightClientAttackEvidence) ? exports.LightClientAttackEvidence.fromJSON(object.lightClientAttackEvidence) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.duplicateVoteEvidence !== undefined && (obj.duplicateVoteEvidence = message.duplicateVoteEvidence ? exports.DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence) : undefined);
	        message.lightClientAttackEvidence !== undefined && (obj.lightClientAttackEvidence = message.lightClientAttackEvidence ? exports.LightClientAttackEvidence.toJSON(message.lightClientAttackEvidence) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseEvidence();
	        message.duplicateVoteEvidence = object.duplicateVoteEvidence !== undefined && object.duplicateVoteEvidence !== null ? exports.DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence) : undefined;
	        message.lightClientAttackEvidence = object.lightClientAttackEvidence !== undefined && object.lightClientAttackEvidence !== null ? exports.LightClientAttackEvidence.fromPartial(object.lightClientAttackEvidence) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            duplicateVoteEvidence: object.duplicate_vote_evidence ? exports.DuplicateVoteEvidence.fromSDK(object.duplicate_vote_evidence) : undefined,
	            lightClientAttackEvidence: object.light_client_attack_evidence ? exports.LightClientAttackEvidence.fromSDK(object.light_client_attack_evidence) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.duplicateVoteEvidence !== undefined && (obj.duplicate_vote_evidence = message.duplicateVoteEvidence ? exports.DuplicateVoteEvidence.toSDK(message.duplicateVoteEvidence) : undefined);
	        message.lightClientAttackEvidence !== undefined && (obj.light_client_attack_evidence = message.lightClientAttackEvidence ? exports.LightClientAttackEvidence.toSDK(message.lightClientAttackEvidence) : undefined);
	        return obj;
	    }
	};
	function createBaseDuplicateVoteEvidence() {
	    return {
	        voteA: undefined,
	        voteB: undefined,
	        totalVotingPower: helpers_1.Long.ZERO,
	        validatorPower: helpers_1.Long.ZERO,
	        timestamp: undefined
	    };
	}
	exports.DuplicateVoteEvidence = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.voteA !== undefined) {
	            types_1.Vote.encode(message.voteA, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.voteB !== undefined) {
	            types_1.Vote.encode(message.voteB, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.totalVotingPower.isZero()) {
	            writer.uint32(24).int64(message.totalVotingPower);
	        }
	        if (!message.validatorPower.isZero()) {
	            writer.uint32(32).int64(message.validatorPower);
	        }
	        if (message.timestamp !== undefined) {
	            timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDuplicateVoteEvidence();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.voteA = types_1.Vote.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.voteB = types_1.Vote.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.totalVotingPower = reader.int64();
	                    break;
	                case 4:
	                    message.validatorPower = reader.int64();
	                    break;
	                case 5:
	                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            voteA: (0, helpers_1.isSet)(object.voteA) ? types_1.Vote.fromJSON(object.voteA) : undefined,
	            voteB: (0, helpers_1.isSet)(object.voteB) ? types_1.Vote.fromJSON(object.voteB) : undefined,
	            totalVotingPower: (0, helpers_1.isSet)(object.totalVotingPower) ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO,
	            validatorPower: (0, helpers_1.isSet)(object.validatorPower) ? helpers_1.Long.fromValue(object.validatorPower) : helpers_1.Long.ZERO,
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? (0, helpers_1.fromJsonTimestamp)(object.timestamp) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.voteA !== undefined && (obj.voteA = message.voteA ? types_1.Vote.toJSON(message.voteA) : undefined);
	        message.voteB !== undefined && (obj.voteB = message.voteB ? types_1.Vote.toJSON(message.voteB) : undefined);
	        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || helpers_1.Long.ZERO).toString());
	        message.validatorPower !== undefined && (obj.validatorPower = (message.validatorPower || helpers_1.Long.ZERO).toString());
	        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDuplicateVoteEvidence();
	        message.voteA = object.voteA !== undefined && object.voteA !== null ? types_1.Vote.fromPartial(object.voteA) : undefined;
	        message.voteB = object.voteB !== undefined && object.voteB !== null ? types_1.Vote.fromPartial(object.voteB) : undefined;
	        message.totalVotingPower = object.totalVotingPower !== undefined && object.totalVotingPower !== null ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO;
	        message.validatorPower = object.validatorPower !== undefined && object.validatorPower !== null ? helpers_1.Long.fromValue(object.validatorPower) : helpers_1.Long.ZERO;
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            voteA: object.vote_a ? types_1.Vote.fromSDK(object.vote_a) : undefined,
	            voteB: object.vote_b ? types_1.Vote.fromSDK(object.vote_b) : undefined,
	            totalVotingPower: object?.total_voting_power,
	            validatorPower: object?.validator_power,
	            timestamp: object.timestamp ? timestamp_1.Timestamp.fromSDK(object.timestamp) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.voteA !== undefined && (obj.vote_a = message.voteA ? types_1.Vote.toSDK(message.voteA) : undefined);
	        message.voteB !== undefined && (obj.vote_b = message.voteB ? types_1.Vote.toSDK(message.voteB) : undefined);
	        obj.total_voting_power = message.totalVotingPower;
	        obj.validator_power = message.validatorPower;
	        message.timestamp !== undefined && (obj.timestamp = message.timestamp ? timestamp_1.Timestamp.toSDK(message.timestamp) : undefined);
	        return obj;
	    }
	};
	function createBaseLightClientAttackEvidence() {
	    return {
	        conflictingBlock: undefined,
	        commonHeight: helpers_1.Long.ZERO,
	        byzantineValidators: [],
	        totalVotingPower: helpers_1.Long.ZERO,
	        timestamp: undefined
	    };
	}
	exports.LightClientAttackEvidence = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.conflictingBlock !== undefined) {
	            types_1.LightBlock.encode(message.conflictingBlock, writer.uint32(10).fork()).ldelim();
	        }
	        if (!message.commonHeight.isZero()) {
	            writer.uint32(16).int64(message.commonHeight);
	        }
	        for (const v of message.byzantineValidators) {
	            validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        if (!message.totalVotingPower.isZero()) {
	            writer.uint32(32).int64(message.totalVotingPower);
	        }
	        if (message.timestamp !== undefined) {
	            timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseLightClientAttackEvidence();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.conflictingBlock = types_1.LightBlock.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.commonHeight = reader.int64();
	                    break;
	                case 3:
	                    message.byzantineValidators.push(validator_1.Validator.decode(reader, reader.uint32()));
	                    break;
	                case 4:
	                    message.totalVotingPower = reader.int64();
	                    break;
	                case 5:
	                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            conflictingBlock: (0, helpers_1.isSet)(object.conflictingBlock) ? types_1.LightBlock.fromJSON(object.conflictingBlock) : undefined,
	            commonHeight: (0, helpers_1.isSet)(object.commonHeight) ? helpers_1.Long.fromValue(object.commonHeight) : helpers_1.Long.ZERO,
	            byzantineValidators: Array.isArray(object?.byzantineValidators) ? object.byzantineValidators.map((e) => validator_1.Validator.fromJSON(e)) : [],
	            totalVotingPower: (0, helpers_1.isSet)(object.totalVotingPower) ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO,
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? (0, helpers_1.fromJsonTimestamp)(object.timestamp) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.conflictingBlock !== undefined && (obj.conflictingBlock = message.conflictingBlock ? types_1.LightBlock.toJSON(message.conflictingBlock) : undefined);
	        message.commonHeight !== undefined && (obj.commonHeight = (message.commonHeight || helpers_1.Long.ZERO).toString());
	        if (message.byzantineValidators) {
	            obj.byzantineValidators = message.byzantineValidators.map(e => e ? validator_1.Validator.toJSON(e) : undefined);
	        }
	        else {
	            obj.byzantineValidators = [];
	        }
	        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || helpers_1.Long.ZERO).toString());
	        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseLightClientAttackEvidence();
	        message.conflictingBlock = object.conflictingBlock !== undefined && object.conflictingBlock !== null ? types_1.LightBlock.fromPartial(object.conflictingBlock) : undefined;
	        message.commonHeight = object.commonHeight !== undefined && object.commonHeight !== null ? helpers_1.Long.fromValue(object.commonHeight) : helpers_1.Long.ZERO;
	        message.byzantineValidators = object.byzantineValidators?.map(e => validator_1.Validator.fromPartial(e)) || [];
	        message.totalVotingPower = object.totalVotingPower !== undefined && object.totalVotingPower !== null ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO;
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            conflictingBlock: object.conflicting_block ? types_1.LightBlock.fromSDK(object.conflicting_block) : undefined,
	            commonHeight: object?.common_height,
	            byzantineValidators: Array.isArray(object?.byzantine_validators) ? object.byzantine_validators.map((e) => validator_1.Validator.fromSDK(e)) : [],
	            totalVotingPower: object?.total_voting_power,
	            timestamp: object.timestamp ? timestamp_1.Timestamp.fromSDK(object.timestamp) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.conflictingBlock !== undefined && (obj.conflicting_block = message.conflictingBlock ? types_1.LightBlock.toSDK(message.conflictingBlock) : undefined);
	        obj.common_height = message.commonHeight;
	        if (message.byzantineValidators) {
	            obj.byzantine_validators = message.byzantineValidators.map(e => e ? validator_1.Validator.toSDK(e) : undefined);
	        }
	        else {
	            obj.byzantine_validators = [];
	        }
	        obj.total_voting_power = message.totalVotingPower;
	        message.timestamp !== undefined && (obj.timestamp = message.timestamp ? timestamp_1.Timestamp.toSDK(message.timestamp) : undefined);
	        return obj;
	    }
	};
	function createBaseEvidenceList() {
	    return {
	        evidence: []
	    };
	}
	exports.EvidenceList = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.evidence) {
	            exports.Evidence.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseEvidenceList();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.evidence.push(exports.Evidence.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            evidence: Array.isArray(object?.evidence) ? object.evidence.map((e) => exports.Evidence.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.evidence) {
	            obj.evidence = message.evidence.map(e => e ? exports.Evidence.toJSON(e) : undefined);
	        }
	        else {
	            obj.evidence = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseEvidenceList();
	        message.evidence = object.evidence?.map(e => exports.Evidence.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            evidence: Array.isArray(object?.evidence) ? object.evidence.map((e) => exports.Evidence.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.evidence) {
	            obj.evidence = message.evidence.map(e => e ? exports.Evidence.toSDK(e) : undefined);
	        }
	        else {
	            obj.evidence = [];
	        }
	        return obj;
	    }
	};
	
} (evidence));

evidence.default;

var __createBinding$9 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$9 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$9 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$9(result, mod, k);
    __setModuleDefault$9(result, mod);
    return result;
};
Object.defineProperty(block, "__esModule", { value: true });
block.Block = block.protobufPackage = void 0;
/* eslint-disable */
const types_1 = types$9;
const evidence_1 = evidence;
const _m0$9 = __importStar$9(minimal$1.exports);
const helpers_1$9 = helpers;
block.protobufPackage = "tendermint.types";
function createBaseBlock() {
    return {
        header: undefined,
        data: undefined,
        evidence: undefined,
        lastCommit: undefined
    };
}
block.Block = {
    encode(message, writer = _m0$9.Writer.create()) {
        if (message.header !== undefined) {
            types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.evidence !== undefined) {
            evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
        }
        if (message.lastCommit !== undefined) {
            types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$9.Reader ? input : new _m0$9.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.header = types_1.Header.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.data = types_1.Data.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            header: (0, helpers_1$9.isSet)(object.header) ? types_1.Header.fromJSON(object.header) : undefined,
            data: (0, helpers_1$9.isSet)(object.data) ? types_1.Data.fromJSON(object.data) : undefined,
            evidence: (0, helpers_1$9.isSet)(object.evidence) ? evidence_1.EvidenceList.fromJSON(object.evidence) : undefined,
            lastCommit: (0, helpers_1$9.isSet)(object.lastCommit) ? types_1.Commit.fromJSON(object.lastCommit) : undefined
        };
    },
    toJSON(message) {
        const obj = {};
        message.header !== undefined && (obj.header = message.header ? types_1.Header.toJSON(message.header) : undefined);
        message.data !== undefined && (obj.data = message.data ? types_1.Data.toJSON(message.data) : undefined);
        message.evidence !== undefined && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : undefined);
        message.lastCommit !== undefined && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlock();
        message.header = object.header !== undefined && object.header !== null ? types_1.Header.fromPartial(object.header) : undefined;
        message.data = object.data !== undefined && object.data !== null ? types_1.Data.fromPartial(object.data) : undefined;
        message.evidence = object.evidence !== undefined && object.evidence !== null ? evidence_1.EvidenceList.fromPartial(object.evidence) : undefined;
        message.lastCommit = object.lastCommit !== undefined && object.lastCommit !== null ? types_1.Commit.fromPartial(object.lastCommit) : undefined;
        return message;
    },
    fromSDK(object) {
        return {
            header: object.header ? types_1.Header.fromSDK(object.header) : undefined,
            data: object.data ? types_1.Data.fromSDK(object.data) : undefined,
            evidence: object.evidence ? evidence_1.EvidenceList.fromSDK(object.evidence) : undefined,
            lastCommit: object.last_commit ? types_1.Commit.fromSDK(object.last_commit) : undefined
        };
    },
    toSDK(message) {
        const obj = {};
        message.header !== undefined && (obj.header = message.header ? types_1.Header.toSDK(message.header) : undefined);
        message.data !== undefined && (obj.data = message.data ? types_1.Data.toSDK(message.data) : undefined);
        message.evidence !== undefined && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toSDK(message.evidence) : undefined);
        message.lastCommit !== undefined && (obj.last_commit = message.lastCommit ? types_1.Commit.toSDK(message.lastCommit) : undefined);
        return obj;
    }
};

var types$7 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Header = exports.Block = exports.protobufPackage = void 0;
	/* eslint-disable */
	const types_1 = types$9;
	const evidence_1 = evidence;
	const types_2 = types$8;
	const timestamp_1 = timestamp;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.base.tendermint.v1beta1";
	function createBaseBlock() {
	    return {
	        header: undefined,
	        data: undefined,
	        evidence: undefined,
	        lastCommit: undefined
	    };
	}
	exports.Block = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.header !== undefined) {
	            exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.data !== undefined) {
	            types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.evidence !== undefined) {
	            evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.lastCommit !== undefined) {
	            types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBlock();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.header = exports.Header.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.data = types_1.Data.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            header: (0, helpers_1.isSet)(object.header) ? exports.Header.fromJSON(object.header) : undefined,
	            data: (0, helpers_1.isSet)(object.data) ? types_1.Data.fromJSON(object.data) : undefined,
	            evidence: (0, helpers_1.isSet)(object.evidence) ? evidence_1.EvidenceList.fromJSON(object.evidence) : undefined,
	            lastCommit: (0, helpers_1.isSet)(object.lastCommit) ? types_1.Commit.fromJSON(object.lastCommit) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.header !== undefined && (obj.header = message.header ? exports.Header.toJSON(message.header) : undefined);
	        message.data !== undefined && (obj.data = message.data ? types_1.Data.toJSON(message.data) : undefined);
	        message.evidence !== undefined && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : undefined);
	        message.lastCommit !== undefined && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBlock();
	        message.header = object.header !== undefined && object.header !== null ? exports.Header.fromPartial(object.header) : undefined;
	        message.data = object.data !== undefined && object.data !== null ? types_1.Data.fromPartial(object.data) : undefined;
	        message.evidence = object.evidence !== undefined && object.evidence !== null ? evidence_1.EvidenceList.fromPartial(object.evidence) : undefined;
	        message.lastCommit = object.lastCommit !== undefined && object.lastCommit !== null ? types_1.Commit.fromPartial(object.lastCommit) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            header: object.header ? exports.Header.fromSDK(object.header) : undefined,
	            data: object.data ? types_1.Data.fromSDK(object.data) : undefined,
	            evidence: object.evidence ? evidence_1.EvidenceList.fromSDK(object.evidence) : undefined,
	            lastCommit: object.last_commit ? types_1.Commit.fromSDK(object.last_commit) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.header !== undefined && (obj.header = message.header ? exports.Header.toSDK(message.header) : undefined);
	        message.data !== undefined && (obj.data = message.data ? types_1.Data.toSDK(message.data) : undefined);
	        message.evidence !== undefined && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toSDK(message.evidence) : undefined);
	        message.lastCommit !== undefined && (obj.last_commit = message.lastCommit ? types_1.Commit.toSDK(message.lastCommit) : undefined);
	        return obj;
	    }
	};
	function createBaseHeader() {
	    return {
	        version: undefined,
	        chainId: "",
	        height: helpers_1.Long.ZERO,
	        time: undefined,
	        lastBlockId: undefined,
	        lastCommitHash: new Uint8Array(),
	        dataHash: new Uint8Array(),
	        validatorsHash: new Uint8Array(),
	        nextValidatorsHash: new Uint8Array(),
	        consensusHash: new Uint8Array(),
	        appHash: new Uint8Array(),
	        lastResultsHash: new Uint8Array(),
	        evidenceHash: new Uint8Array(),
	        proposerAddress: ""
	    };
	}
	exports.Header = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.version !== undefined) {
	            types_2.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.chainId !== "") {
	            writer.uint32(18).string(message.chainId);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(24).int64(message.height);
	        }
	        if (message.time !== undefined) {
	            timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.lastBlockId !== undefined) {
	            types_1.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
	        }
	        if (message.lastCommitHash.length !== 0) {
	            writer.uint32(50).bytes(message.lastCommitHash);
	        }
	        if (message.dataHash.length !== 0) {
	            writer.uint32(58).bytes(message.dataHash);
	        }
	        if (message.validatorsHash.length !== 0) {
	            writer.uint32(66).bytes(message.validatorsHash);
	        }
	        if (message.nextValidatorsHash.length !== 0) {
	            writer.uint32(74).bytes(message.nextValidatorsHash);
	        }
	        if (message.consensusHash.length !== 0) {
	            writer.uint32(82).bytes(message.consensusHash);
	        }
	        if (message.appHash.length !== 0) {
	            writer.uint32(90).bytes(message.appHash);
	        }
	        if (message.lastResultsHash.length !== 0) {
	            writer.uint32(98).bytes(message.lastResultsHash);
	        }
	        if (message.evidenceHash.length !== 0) {
	            writer.uint32(106).bytes(message.evidenceHash);
	        }
	        if (message.proposerAddress !== "") {
	            writer.uint32(114).string(message.proposerAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseHeader();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.version = types_2.Consensus.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.chainId = reader.string();
	                    break;
	                case 3:
	                    message.height = reader.int64();
	                    break;
	                case 4:
	                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 5:
	                    message.lastBlockId = types_1.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 6:
	                    message.lastCommitHash = reader.bytes();
	                    break;
	                case 7:
	                    message.dataHash = reader.bytes();
	                    break;
	                case 8:
	                    message.validatorsHash = reader.bytes();
	                    break;
	                case 9:
	                    message.nextValidatorsHash = reader.bytes();
	                    break;
	                case 10:
	                    message.consensusHash = reader.bytes();
	                    break;
	                case 11:
	                    message.appHash = reader.bytes();
	                    break;
	                case 12:
	                    message.lastResultsHash = reader.bytes();
	                    break;
	                case 13:
	                    message.evidenceHash = reader.bytes();
	                    break;
	                case 14:
	                    message.proposerAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            version: (0, helpers_1.isSet)(object.version) ? types_2.Consensus.fromJSON(object.version) : undefined,
	            chainId: (0, helpers_1.isSet)(object.chainId) ? String(object.chainId) : "",
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            time: (0, helpers_1.isSet)(object.time) ? (0, helpers_1.fromJsonTimestamp)(object.time) : undefined,
	            lastBlockId: (0, helpers_1.isSet)(object.lastBlockId) ? types_1.BlockID.fromJSON(object.lastBlockId) : undefined,
	            lastCommitHash: (0, helpers_1.isSet)(object.lastCommitHash) ? (0, helpers_1.bytesFromBase64)(object.lastCommitHash) : new Uint8Array(),
	            dataHash: (0, helpers_1.isSet)(object.dataHash) ? (0, helpers_1.bytesFromBase64)(object.dataHash) : new Uint8Array(),
	            validatorsHash: (0, helpers_1.isSet)(object.validatorsHash) ? (0, helpers_1.bytesFromBase64)(object.validatorsHash) : new Uint8Array(),
	            nextValidatorsHash: (0, helpers_1.isSet)(object.nextValidatorsHash) ? (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash) : new Uint8Array(),
	            consensusHash: (0, helpers_1.isSet)(object.consensusHash) ? (0, helpers_1.bytesFromBase64)(object.consensusHash) : new Uint8Array(),
	            appHash: (0, helpers_1.isSet)(object.appHash) ? (0, helpers_1.bytesFromBase64)(object.appHash) : new Uint8Array(),
	            lastResultsHash: (0, helpers_1.isSet)(object.lastResultsHash) ? (0, helpers_1.bytesFromBase64)(object.lastResultsHash) : new Uint8Array(),
	            evidenceHash: (0, helpers_1.isSet)(object.evidenceHash) ? (0, helpers_1.bytesFromBase64)(object.evidenceHash) : new Uint8Array(),
	            proposerAddress: (0, helpers_1.isSet)(object.proposerAddress) ? String(object.proposerAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.version !== undefined && (obj.version = message.version ? types_2.Consensus.toJSON(message.version) : undefined);
	        message.chainId !== undefined && (obj.chainId = message.chainId);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
	        message.lastBlockId !== undefined && (obj.lastBlockId = message.lastBlockId ? types_1.BlockID.toJSON(message.lastBlockId) : undefined);
	        message.lastCommitHash !== undefined && (obj.lastCommitHash = (0, helpers_1.base64FromBytes)(message.lastCommitHash !== undefined ? message.lastCommitHash : new Uint8Array()));
	        message.dataHash !== undefined && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== undefined ? message.dataHash : new Uint8Array()));
	        message.validatorsHash !== undefined && (obj.validatorsHash = (0, helpers_1.base64FromBytes)(message.validatorsHash !== undefined ? message.validatorsHash : new Uint8Array()));
	        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
	        message.consensusHash !== undefined && (obj.consensusHash = (0, helpers_1.base64FromBytes)(message.consensusHash !== undefined ? message.consensusHash : new Uint8Array()));
	        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
	        message.lastResultsHash !== undefined && (obj.lastResultsHash = (0, helpers_1.base64FromBytes)(message.lastResultsHash !== undefined ? message.lastResultsHash : new Uint8Array()));
	        message.evidenceHash !== undefined && (obj.evidenceHash = (0, helpers_1.base64FromBytes)(message.evidenceHash !== undefined ? message.evidenceHash : new Uint8Array()));
	        message.proposerAddress !== undefined && (obj.proposerAddress = message.proposerAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseHeader();
	        message.version = object.version !== undefined && object.version !== null ? types_2.Consensus.fromPartial(object.version) : undefined;
	        message.chainId = object.chainId ?? "";
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.time = object.time !== undefined && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : undefined;
	        message.lastBlockId = object.lastBlockId !== undefined && object.lastBlockId !== null ? types_1.BlockID.fromPartial(object.lastBlockId) : undefined;
	        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();
	        message.dataHash = object.dataHash ?? new Uint8Array();
	        message.validatorsHash = object.validatorsHash ?? new Uint8Array();
	        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
	        message.consensusHash = object.consensusHash ?? new Uint8Array();
	        message.appHash = object.appHash ?? new Uint8Array();
	        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();
	        message.evidenceHash = object.evidenceHash ?? new Uint8Array();
	        message.proposerAddress = object.proposerAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            version: object.version ? types_2.Consensus.fromSDK(object.version) : undefined,
	            chainId: object?.chain_id,
	            height: object?.height,
	            time: object.time ? timestamp_1.Timestamp.fromSDK(object.time) : undefined,
	            lastBlockId: object.last_block_id ? types_1.BlockID.fromSDK(object.last_block_id) : undefined,
	            lastCommitHash: object?.last_commit_hash,
	            dataHash: object?.data_hash,
	            validatorsHash: object?.validators_hash,
	            nextValidatorsHash: object?.next_validators_hash,
	            consensusHash: object?.consensus_hash,
	            appHash: object?.app_hash,
	            lastResultsHash: object?.last_results_hash,
	            evidenceHash: object?.evidence_hash,
	            proposerAddress: object?.proposer_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.version !== undefined && (obj.version = message.version ? types_2.Consensus.toSDK(message.version) : undefined);
	        obj.chain_id = message.chainId;
	        obj.height = message.height;
	        message.time !== undefined && (obj.time = message.time ? timestamp_1.Timestamp.toSDK(message.time) : undefined);
	        message.lastBlockId !== undefined && (obj.last_block_id = message.lastBlockId ? types_1.BlockID.toSDK(message.lastBlockId) : undefined);
	        obj.last_commit_hash = message.lastCommitHash;
	        obj.data_hash = message.dataHash;
	        obj.validators_hash = message.validatorsHash;
	        obj.next_validators_hash = message.nextValidatorsHash;
	        obj.consensus_hash = message.consensusHash;
	        obj.app_hash = message.appHash;
	        obj.last_results_hash = message.lastResultsHash;
	        obj.evidence_hash = message.evidenceHash;
	        obj.proposer_address = message.proposerAddress;
	        return obj;
	    }
	};
	
} (types$7));

types$7.default;

var types$6 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DefaultNodeInfoOther = exports.DefaultNodeInfo = exports.ProtocolVersion = exports.NetAddress = exports.protobufPackage = void 0;
	/* eslint-disable */
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "tendermint.p2p";
	function createBaseNetAddress() {
	    return {
	        id: "",
	        ip: "",
	        port: 0
	    };
	}
	exports.NetAddress = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.id !== "") {
	            writer.uint32(10).string(message.id);
	        }
	        if (message.ip !== "") {
	            writer.uint32(18).string(message.ip);
	        }
	        if (message.port !== 0) {
	            writer.uint32(24).uint32(message.port);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseNetAddress();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.id = reader.string();
	                    break;
	                case 2:
	                    message.ip = reader.string();
	                    break;
	                case 3:
	                    message.port = reader.uint32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : "",
	            ip: (0, helpers_1.isSet)(object.ip) ? String(object.ip) : "",
	            port: (0, helpers_1.isSet)(object.port) ? Number(object.port) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.id !== undefined && (obj.id = message.id);
	        message.ip !== undefined && (obj.ip = message.ip);
	        message.port !== undefined && (obj.port = Math.round(message.port));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseNetAddress();
	        message.id = object.id ?? "";
	        message.ip = object.ip ?? "";
	        message.port = object.port ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            id: object?.id,
	            ip: object?.ip,
	            port: object?.port
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.id = message.id;
	        obj.ip = message.ip;
	        obj.port = message.port;
	        return obj;
	    }
	};
	function createBaseProtocolVersion() {
	    return {
	        p2p: helpers_1.Long.UZERO,
	        block: helpers_1.Long.UZERO,
	        app: helpers_1.Long.UZERO
	    };
	}
	exports.ProtocolVersion = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.p2p.isZero()) {
	            writer.uint32(8).uint64(message.p2p);
	        }
	        if (!message.block.isZero()) {
	            writer.uint32(16).uint64(message.block);
	        }
	        if (!message.app.isZero()) {
	            writer.uint32(24).uint64(message.app);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseProtocolVersion();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.p2p = reader.uint64();
	                    break;
	                case 2:
	                    message.block = reader.uint64();
	                    break;
	                case 3:
	                    message.app = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            p2p: (0, helpers_1.isSet)(object.p2p) ? helpers_1.Long.fromValue(object.p2p) : helpers_1.Long.UZERO,
	            block: (0, helpers_1.isSet)(object.block) ? helpers_1.Long.fromValue(object.block) : helpers_1.Long.UZERO,
	            app: (0, helpers_1.isSet)(object.app) ? helpers_1.Long.fromValue(object.app) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.p2p !== undefined && (obj.p2p = (message.p2p || helpers_1.Long.UZERO).toString());
	        message.block !== undefined && (obj.block = (message.block || helpers_1.Long.UZERO).toString());
	        message.app !== undefined && (obj.app = (message.app || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseProtocolVersion();
	        message.p2p = object.p2p !== undefined && object.p2p !== null ? helpers_1.Long.fromValue(object.p2p) : helpers_1.Long.UZERO;
	        message.block = object.block !== undefined && object.block !== null ? helpers_1.Long.fromValue(object.block) : helpers_1.Long.UZERO;
	        message.app = object.app !== undefined && object.app !== null ? helpers_1.Long.fromValue(object.app) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            p2p: object?.p2p,
	            block: object?.block,
	            app: object?.app
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.p2p = message.p2p;
	        obj.block = message.block;
	        obj.app = message.app;
	        return obj;
	    }
	};
	function createBaseDefaultNodeInfo() {
	    return {
	        protocolVersion: undefined,
	        defaultNodeId: "",
	        listenAddr: "",
	        network: "",
	        version: "",
	        channels: new Uint8Array(),
	        moniker: "",
	        other: undefined
	    };
	}
	exports.DefaultNodeInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.protocolVersion !== undefined) {
	            exports.ProtocolVersion.encode(message.protocolVersion, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.defaultNodeId !== "") {
	            writer.uint32(18).string(message.defaultNodeId);
	        }
	        if (message.listenAddr !== "") {
	            writer.uint32(26).string(message.listenAddr);
	        }
	        if (message.network !== "") {
	            writer.uint32(34).string(message.network);
	        }
	        if (message.version !== "") {
	            writer.uint32(42).string(message.version);
	        }
	        if (message.channels.length !== 0) {
	            writer.uint32(50).bytes(message.channels);
	        }
	        if (message.moniker !== "") {
	            writer.uint32(58).string(message.moniker);
	        }
	        if (message.other !== undefined) {
	            exports.DefaultNodeInfoOther.encode(message.other, writer.uint32(66).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDefaultNodeInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.protocolVersion = exports.ProtocolVersion.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.defaultNodeId = reader.string();
	                    break;
	                case 3:
	                    message.listenAddr = reader.string();
	                    break;
	                case 4:
	                    message.network = reader.string();
	                    break;
	                case 5:
	                    message.version = reader.string();
	                    break;
	                case 6:
	                    message.channels = reader.bytes();
	                    break;
	                case 7:
	                    message.moniker = reader.string();
	                    break;
	                case 8:
	                    message.other = exports.DefaultNodeInfoOther.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            protocolVersion: (0, helpers_1.isSet)(object.protocolVersion) ? exports.ProtocolVersion.fromJSON(object.protocolVersion) : undefined,
	            defaultNodeId: (0, helpers_1.isSet)(object.defaultNodeId) ? String(object.defaultNodeId) : "",
	            listenAddr: (0, helpers_1.isSet)(object.listenAddr) ? String(object.listenAddr) : "",
	            network: (0, helpers_1.isSet)(object.network) ? String(object.network) : "",
	            version: (0, helpers_1.isSet)(object.version) ? String(object.version) : "",
	            channels: (0, helpers_1.isSet)(object.channels) ? (0, helpers_1.bytesFromBase64)(object.channels) : new Uint8Array(),
	            moniker: (0, helpers_1.isSet)(object.moniker) ? String(object.moniker) : "",
	            other: (0, helpers_1.isSet)(object.other) ? exports.DefaultNodeInfoOther.fromJSON(object.other) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.protocolVersion !== undefined && (obj.protocolVersion = message.protocolVersion ? exports.ProtocolVersion.toJSON(message.protocolVersion) : undefined);
	        message.defaultNodeId !== undefined && (obj.defaultNodeId = message.defaultNodeId);
	        message.listenAddr !== undefined && (obj.listenAddr = message.listenAddr);
	        message.network !== undefined && (obj.network = message.network);
	        message.version !== undefined && (obj.version = message.version);
	        message.channels !== undefined && (obj.channels = (0, helpers_1.base64FromBytes)(message.channels !== undefined ? message.channels : new Uint8Array()));
	        message.moniker !== undefined && (obj.moniker = message.moniker);
	        message.other !== undefined && (obj.other = message.other ? exports.DefaultNodeInfoOther.toJSON(message.other) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDefaultNodeInfo();
	        message.protocolVersion = object.protocolVersion !== undefined && object.protocolVersion !== null ? exports.ProtocolVersion.fromPartial(object.protocolVersion) : undefined;
	        message.defaultNodeId = object.defaultNodeId ?? "";
	        message.listenAddr = object.listenAddr ?? "";
	        message.network = object.network ?? "";
	        message.version = object.version ?? "";
	        message.channels = object.channels ?? new Uint8Array();
	        message.moniker = object.moniker ?? "";
	        message.other = object.other !== undefined && object.other !== null ? exports.DefaultNodeInfoOther.fromPartial(object.other) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            protocolVersion: object.protocol_version ? exports.ProtocolVersion.fromSDK(object.protocol_version) : undefined,
	            defaultNodeId: object?.default_node_id,
	            listenAddr: object?.listen_addr,
	            network: object?.network,
	            version: object?.version,
	            channels: object?.channels,
	            moniker: object?.moniker,
	            other: object.other ? exports.DefaultNodeInfoOther.fromSDK(object.other) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.protocolVersion !== undefined && (obj.protocol_version = message.protocolVersion ? exports.ProtocolVersion.toSDK(message.protocolVersion) : undefined);
	        obj.default_node_id = message.defaultNodeId;
	        obj.listen_addr = message.listenAddr;
	        obj.network = message.network;
	        obj.version = message.version;
	        obj.channels = message.channels;
	        obj.moniker = message.moniker;
	        message.other !== undefined && (obj.other = message.other ? exports.DefaultNodeInfoOther.toSDK(message.other) : undefined);
	        return obj;
	    }
	};
	function createBaseDefaultNodeInfoOther() {
	    return {
	        txIndex: "",
	        rpcAddress: ""
	    };
	}
	exports.DefaultNodeInfoOther = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.txIndex !== "") {
	            writer.uint32(10).string(message.txIndex);
	        }
	        if (message.rpcAddress !== "") {
	            writer.uint32(18).string(message.rpcAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDefaultNodeInfoOther();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txIndex = reader.string();
	                    break;
	                case 2:
	                    message.rpcAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txIndex: (0, helpers_1.isSet)(object.txIndex) ? String(object.txIndex) : "",
	            rpcAddress: (0, helpers_1.isSet)(object.rpcAddress) ? String(object.rpcAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.txIndex !== undefined && (obj.txIndex = message.txIndex);
	        message.rpcAddress !== undefined && (obj.rpcAddress = message.rpcAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDefaultNodeInfoOther();
	        message.txIndex = object.txIndex ?? "";
	        message.rpcAddress = object.rpcAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txIndex: object?.tx_index,
	            rpcAddress: object?.rpc_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.tx_index = message.txIndex;
	        obj.rpc_address = message.rpcAddress;
	        return obj;
	    }
	};
	
} (types$6));

types$6.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ServiceClientImpl = exports.ProofOps = exports.ProofOp = exports.ABCIQueryResponse = exports.ABCIQueryRequest = exports.Module = exports.VersionInfo = exports.GetNodeInfoResponse = exports.GetNodeInfoRequest = exports.GetSyncingResponse = exports.GetSyncingRequest = exports.GetLatestBlockResponse = exports.GetLatestBlockRequest = exports.GetBlockByHeightResponse = exports.GetBlockByHeightRequest = exports.Validator = exports.GetLatestValidatorSetResponse = exports.GetLatestValidatorSetRequest = exports.GetValidatorSetByHeightResponse = exports.GetValidatorSetByHeightRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const pagination_1 = pagination;
	const any_1 = any;
	const types_1 = types$9;
	const block_1 = block;
	const types_2 = types$7;
	const types_3 = types$6;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "cosmos.base.tendermint.v1beta1";
	function createBaseGetValidatorSetByHeightRequest() {
	    return {
	        height: helpers_1.Long.ZERO,
	        pagination: undefined
	    };
	}
	exports.GetValidatorSetByHeightRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetValidatorSetByHeightRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetValidatorSetByHeightRequest();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseGetValidatorSetByHeightResponse() {
	    return {
	        blockHeight: helpers_1.Long.ZERO,
	        validators: [],
	        pagination: undefined
	    };
	}
	exports.GetValidatorSetByHeightResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.blockHeight.isZero()) {
	            writer.uint32(8).int64(message.blockHeight);
	        }
	        for (const v of message.validators) {
	            exports.Validator.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetValidatorSetByHeightResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blockHeight = reader.int64();
	                    break;
	                case 2:
	                    message.validators.push(exports.Validator.decode(reader, reader.uint32()));
	                    break;
	                case 3:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blockHeight: (0, helpers_1.isSet)(object.blockHeight) ? helpers_1.Long.fromValue(object.blockHeight) : helpers_1.Long.ZERO,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.Validator.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blockHeight !== undefined && (obj.blockHeight = (message.blockHeight || helpers_1.Long.ZERO).toString());
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.Validator.toJSON(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetValidatorSetByHeightResponse();
	        message.blockHeight = object.blockHeight !== undefined && object.blockHeight !== null ? helpers_1.Long.fromValue(object.blockHeight) : helpers_1.Long.ZERO;
	        message.validators = object.validators?.map(e => exports.Validator.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blockHeight: object?.block_height,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.Validator.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.block_height = message.blockHeight;
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.Validator.toSDK(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseGetLatestValidatorSetRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.GetLatestValidatorSetRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetLatestValidatorSetRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetLatestValidatorSetRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseGetLatestValidatorSetResponse() {
	    return {
	        blockHeight: helpers_1.Long.ZERO,
	        validators: [],
	        pagination: undefined
	    };
	}
	exports.GetLatestValidatorSetResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.blockHeight.isZero()) {
	            writer.uint32(8).int64(message.blockHeight);
	        }
	        for (const v of message.validators) {
	            exports.Validator.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetLatestValidatorSetResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blockHeight = reader.int64();
	                    break;
	                case 2:
	                    message.validators.push(exports.Validator.decode(reader, reader.uint32()));
	                    break;
	                case 3:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blockHeight: (0, helpers_1.isSet)(object.blockHeight) ? helpers_1.Long.fromValue(object.blockHeight) : helpers_1.Long.ZERO,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.Validator.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blockHeight !== undefined && (obj.blockHeight = (message.blockHeight || helpers_1.Long.ZERO).toString());
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.Validator.toJSON(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetLatestValidatorSetResponse();
	        message.blockHeight = object.blockHeight !== undefined && object.blockHeight !== null ? helpers_1.Long.fromValue(object.blockHeight) : helpers_1.Long.ZERO;
	        message.validators = object.validators?.map(e => exports.Validator.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blockHeight: object?.block_height,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.Validator.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.block_height = message.blockHeight;
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.Validator.toSDK(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseValidator() {
	    return {
	        address: "",
	        pubKey: undefined,
	        votingPower: helpers_1.Long.ZERO,
	        proposerPriority: helpers_1.Long.ZERO
	    };
	}
	exports.Validator = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.pubKey !== undefined) {
	            any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.votingPower.isZero()) {
	            writer.uint32(24).int64(message.votingPower);
	        }
	        if (!message.proposerPriority.isZero()) {
	            writer.uint32(32).int64(message.proposerPriority);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidator();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.pubKey = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.votingPower = reader.int64();
	                    break;
	                case 4:
	                    message.proposerPriority = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            pubKey: (0, helpers_1.isSet)(object.pubKey) ? any_1.Any.fromJSON(object.pubKey) : undefined,
	            votingPower: (0, helpers_1.isSet)(object.votingPower) ? helpers_1.Long.fromValue(object.votingPower) : helpers_1.Long.ZERO,
	            proposerPriority: (0, helpers_1.isSet)(object.proposerPriority) ? helpers_1.Long.fromValue(object.proposerPriority) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : undefined);
	        message.votingPower !== undefined && (obj.votingPower = (message.votingPower || helpers_1.Long.ZERO).toString());
	        message.proposerPriority !== undefined && (obj.proposerPriority = (message.proposerPriority || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidator();
	        message.address = object.address ?? "";
	        message.pubKey = object.pubKey !== undefined && object.pubKey !== null ? any_1.Any.fromPartial(object.pubKey) : undefined;
	        message.votingPower = object.votingPower !== undefined && object.votingPower !== null ? helpers_1.Long.fromValue(object.votingPower) : helpers_1.Long.ZERO;
	        message.proposerPriority = object.proposerPriority !== undefined && object.proposerPriority !== null ? helpers_1.Long.fromValue(object.proposerPriority) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            pubKey: object.pub_key ? any_1.Any.fromSDK(object.pub_key) : undefined,
	            votingPower: object?.voting_power,
	            proposerPriority: object?.proposer_priority
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.pubKey !== undefined && (obj.pub_key = message.pubKey ? any_1.Any.toSDK(message.pubKey) : undefined);
	        obj.voting_power = message.votingPower;
	        obj.proposer_priority = message.proposerPriority;
	        return obj;
	    }
	};
	function createBaseGetBlockByHeightRequest() {
	    return {
	        height: helpers_1.Long.ZERO
	    };
	}
	exports.GetBlockByHeightRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetBlockByHeightRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetBlockByHeightRequest();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        return obj;
	    }
	};
	function createBaseGetBlockByHeightResponse() {
	    return {
	        blockId: undefined,
	        block: undefined,
	        sdkBlock: undefined
	    };
	}
	exports.GetBlockByHeightResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.blockId !== undefined) {
	            types_1.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.block !== undefined) {
	            block_1.Block.encode(message.block, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.sdkBlock !== undefined) {
	            types_2.Block.encode(message.sdkBlock, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetBlockByHeightResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blockId = types_1.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.block = block_1.Block.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.sdkBlock = types_2.Block.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blockId: (0, helpers_1.isSet)(object.blockId) ? types_1.BlockID.fromJSON(object.blockId) : undefined,
	            block: (0, helpers_1.isSet)(object.block) ? block_1.Block.fromJSON(object.block) : undefined,
	            sdkBlock: (0, helpers_1.isSet)(object.sdkBlock) ? types_2.Block.fromJSON(object.sdkBlock) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blockId !== undefined && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : undefined);
	        message.block !== undefined && (obj.block = message.block ? block_1.Block.toJSON(message.block) : undefined);
	        message.sdkBlock !== undefined && (obj.sdkBlock = message.sdkBlock ? types_2.Block.toJSON(message.sdkBlock) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetBlockByHeightResponse();
	        message.blockId = object.blockId !== undefined && object.blockId !== null ? types_1.BlockID.fromPartial(object.blockId) : undefined;
	        message.block = object.block !== undefined && object.block !== null ? block_1.Block.fromPartial(object.block) : undefined;
	        message.sdkBlock = object.sdkBlock !== undefined && object.sdkBlock !== null ? types_2.Block.fromPartial(object.sdkBlock) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blockId: object.block_id ? types_1.BlockID.fromSDK(object.block_id) : undefined,
	            block: object.block ? block_1.Block.fromSDK(object.block) : undefined,
	            sdkBlock: object.sdk_block ? types_2.Block.fromSDK(object.sdk_block) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.blockId !== undefined && (obj.block_id = message.blockId ? types_1.BlockID.toSDK(message.blockId) : undefined);
	        message.block !== undefined && (obj.block = message.block ? block_1.Block.toSDK(message.block) : undefined);
	        message.sdkBlock !== undefined && (obj.sdk_block = message.sdkBlock ? types_2.Block.toSDK(message.sdkBlock) : undefined);
	        return obj;
	    }
	};
	function createBaseGetLatestBlockRequest() {
	    return {};
	}
	exports.GetLatestBlockRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetLatestBlockRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseGetLatestBlockRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseGetLatestBlockResponse() {
	    return {
	        blockId: undefined,
	        block: undefined,
	        sdkBlock: undefined
	    };
	}
	exports.GetLatestBlockResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.blockId !== undefined) {
	            types_1.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.block !== undefined) {
	            block_1.Block.encode(message.block, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.sdkBlock !== undefined) {
	            types_2.Block.encode(message.sdkBlock, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetLatestBlockResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blockId = types_1.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.block = block_1.Block.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.sdkBlock = types_2.Block.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blockId: (0, helpers_1.isSet)(object.blockId) ? types_1.BlockID.fromJSON(object.blockId) : undefined,
	            block: (0, helpers_1.isSet)(object.block) ? block_1.Block.fromJSON(object.block) : undefined,
	            sdkBlock: (0, helpers_1.isSet)(object.sdkBlock) ? types_2.Block.fromJSON(object.sdkBlock) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blockId !== undefined && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : undefined);
	        message.block !== undefined && (obj.block = message.block ? block_1.Block.toJSON(message.block) : undefined);
	        message.sdkBlock !== undefined && (obj.sdkBlock = message.sdkBlock ? types_2.Block.toJSON(message.sdkBlock) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetLatestBlockResponse();
	        message.blockId = object.blockId !== undefined && object.blockId !== null ? types_1.BlockID.fromPartial(object.blockId) : undefined;
	        message.block = object.block !== undefined && object.block !== null ? block_1.Block.fromPartial(object.block) : undefined;
	        message.sdkBlock = object.sdkBlock !== undefined && object.sdkBlock !== null ? types_2.Block.fromPartial(object.sdkBlock) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blockId: object.block_id ? types_1.BlockID.fromSDK(object.block_id) : undefined,
	            block: object.block ? block_1.Block.fromSDK(object.block) : undefined,
	            sdkBlock: object.sdk_block ? types_2.Block.fromSDK(object.sdk_block) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.blockId !== undefined && (obj.block_id = message.blockId ? types_1.BlockID.toSDK(message.blockId) : undefined);
	        message.block !== undefined && (obj.block = message.block ? block_1.Block.toSDK(message.block) : undefined);
	        message.sdkBlock !== undefined && (obj.sdk_block = message.sdkBlock ? types_2.Block.toSDK(message.sdkBlock) : undefined);
	        return obj;
	    }
	};
	function createBaseGetSyncingRequest() {
	    return {};
	}
	exports.GetSyncingRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetSyncingRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseGetSyncingRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseGetSyncingResponse() {
	    return {
	        syncing: false
	    };
	}
	exports.GetSyncingResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.syncing === true) {
	            writer.uint32(8).bool(message.syncing);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetSyncingResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.syncing = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            syncing: (0, helpers_1.isSet)(object.syncing) ? Boolean(object.syncing) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.syncing !== undefined && (obj.syncing = message.syncing);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetSyncingResponse();
	        message.syncing = object.syncing ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            syncing: object?.syncing
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.syncing = message.syncing;
	        return obj;
	    }
	};
	function createBaseGetNodeInfoRequest() {
	    return {};
	}
	exports.GetNodeInfoRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetNodeInfoRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseGetNodeInfoRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseGetNodeInfoResponse() {
	    return {
	        defaultNodeInfo: undefined,
	        applicationVersion: undefined
	    };
	}
	exports.GetNodeInfoResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.defaultNodeInfo !== undefined) {
	            types_3.DefaultNodeInfo.encode(message.defaultNodeInfo, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.applicationVersion !== undefined) {
	            exports.VersionInfo.encode(message.applicationVersion, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetNodeInfoResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.defaultNodeInfo = types_3.DefaultNodeInfo.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.applicationVersion = exports.VersionInfo.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            defaultNodeInfo: (0, helpers_1.isSet)(object.defaultNodeInfo) ? types_3.DefaultNodeInfo.fromJSON(object.defaultNodeInfo) : undefined,
	            applicationVersion: (0, helpers_1.isSet)(object.applicationVersion) ? exports.VersionInfo.fromJSON(object.applicationVersion) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.defaultNodeInfo !== undefined && (obj.defaultNodeInfo = message.defaultNodeInfo ? types_3.DefaultNodeInfo.toJSON(message.defaultNodeInfo) : undefined);
	        message.applicationVersion !== undefined && (obj.applicationVersion = message.applicationVersion ? exports.VersionInfo.toJSON(message.applicationVersion) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetNodeInfoResponse();
	        message.defaultNodeInfo = object.defaultNodeInfo !== undefined && object.defaultNodeInfo !== null ? types_3.DefaultNodeInfo.fromPartial(object.defaultNodeInfo) : undefined;
	        message.applicationVersion = object.applicationVersion !== undefined && object.applicationVersion !== null ? exports.VersionInfo.fromPartial(object.applicationVersion) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            defaultNodeInfo: object.default_node_info ? types_3.DefaultNodeInfo.fromSDK(object.default_node_info) : undefined,
	            applicationVersion: object.application_version ? exports.VersionInfo.fromSDK(object.application_version) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.defaultNodeInfo !== undefined && (obj.default_node_info = message.defaultNodeInfo ? types_3.DefaultNodeInfo.toSDK(message.defaultNodeInfo) : undefined);
	        message.applicationVersion !== undefined && (obj.application_version = message.applicationVersion ? exports.VersionInfo.toSDK(message.applicationVersion) : undefined);
	        return obj;
	    }
	};
	function createBaseVersionInfo() {
	    return {
	        name: "",
	        appName: "",
	        version: "",
	        gitCommit: "",
	        buildTags: "",
	        goVersion: "",
	        buildDeps: [],
	        cosmosSdkVersion: ""
	    };
	}
	exports.VersionInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.name !== "") {
	            writer.uint32(10).string(message.name);
	        }
	        if (message.appName !== "") {
	            writer.uint32(18).string(message.appName);
	        }
	        if (message.version !== "") {
	            writer.uint32(26).string(message.version);
	        }
	        if (message.gitCommit !== "") {
	            writer.uint32(34).string(message.gitCommit);
	        }
	        if (message.buildTags !== "") {
	            writer.uint32(42).string(message.buildTags);
	        }
	        if (message.goVersion !== "") {
	            writer.uint32(50).string(message.goVersion);
	        }
	        for (const v of message.buildDeps) {
	            exports.Module.encode(v, writer.uint32(58).fork()).ldelim();
	        }
	        if (message.cosmosSdkVersion !== "") {
	            writer.uint32(66).string(message.cosmosSdkVersion);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseVersionInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.name = reader.string();
	                    break;
	                case 2:
	                    message.appName = reader.string();
	                    break;
	                case 3:
	                    message.version = reader.string();
	                    break;
	                case 4:
	                    message.gitCommit = reader.string();
	                    break;
	                case 5:
	                    message.buildTags = reader.string();
	                    break;
	                case 6:
	                    message.goVersion = reader.string();
	                    break;
	                case 7:
	                    message.buildDeps.push(exports.Module.decode(reader, reader.uint32()));
	                    break;
	                case 8:
	                    message.cosmosSdkVersion = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            name: (0, helpers_1.isSet)(object.name) ? String(object.name) : "",
	            appName: (0, helpers_1.isSet)(object.appName) ? String(object.appName) : "",
	            version: (0, helpers_1.isSet)(object.version) ? String(object.version) : "",
	            gitCommit: (0, helpers_1.isSet)(object.gitCommit) ? String(object.gitCommit) : "",
	            buildTags: (0, helpers_1.isSet)(object.buildTags) ? String(object.buildTags) : "",
	            goVersion: (0, helpers_1.isSet)(object.goVersion) ? String(object.goVersion) : "",
	            buildDeps: Array.isArray(object?.buildDeps) ? object.buildDeps.map((e) => exports.Module.fromJSON(e)) : [],
	            cosmosSdkVersion: (0, helpers_1.isSet)(object.cosmosSdkVersion) ? String(object.cosmosSdkVersion) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.name !== undefined && (obj.name = message.name);
	        message.appName !== undefined && (obj.appName = message.appName);
	        message.version !== undefined && (obj.version = message.version);
	        message.gitCommit !== undefined && (obj.gitCommit = message.gitCommit);
	        message.buildTags !== undefined && (obj.buildTags = message.buildTags);
	        message.goVersion !== undefined && (obj.goVersion = message.goVersion);
	        if (message.buildDeps) {
	            obj.buildDeps = message.buildDeps.map(e => e ? exports.Module.toJSON(e) : undefined);
	        }
	        else {
	            obj.buildDeps = [];
	        }
	        message.cosmosSdkVersion !== undefined && (obj.cosmosSdkVersion = message.cosmosSdkVersion);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseVersionInfo();
	        message.name = object.name ?? "";
	        message.appName = object.appName ?? "";
	        message.version = object.version ?? "";
	        message.gitCommit = object.gitCommit ?? "";
	        message.buildTags = object.buildTags ?? "";
	        message.goVersion = object.goVersion ?? "";
	        message.buildDeps = object.buildDeps?.map(e => exports.Module.fromPartial(e)) || [];
	        message.cosmosSdkVersion = object.cosmosSdkVersion ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            name: object?.name,
	            appName: object?.app_name,
	            version: object?.version,
	            gitCommit: object?.git_commit,
	            buildTags: object?.build_tags,
	            goVersion: object?.go_version,
	            buildDeps: Array.isArray(object?.build_deps) ? object.build_deps.map((e) => exports.Module.fromSDK(e)) : [],
	            cosmosSdkVersion: object?.cosmos_sdk_version
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.name = message.name;
	        obj.app_name = message.appName;
	        obj.version = message.version;
	        obj.git_commit = message.gitCommit;
	        obj.build_tags = message.buildTags;
	        obj.go_version = message.goVersion;
	        if (message.buildDeps) {
	            obj.build_deps = message.buildDeps.map(e => e ? exports.Module.toSDK(e) : undefined);
	        }
	        else {
	            obj.build_deps = [];
	        }
	        obj.cosmos_sdk_version = message.cosmosSdkVersion;
	        return obj;
	    }
	};
	function createBaseModule() {
	    return {
	        path: "",
	        version: "",
	        sum: ""
	    };
	}
	exports.Module = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.path !== "") {
	            writer.uint32(10).string(message.path);
	        }
	        if (message.version !== "") {
	            writer.uint32(18).string(message.version);
	        }
	        if (message.sum !== "") {
	            writer.uint32(26).string(message.sum);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseModule();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.path = reader.string();
	                    break;
	                case 2:
	                    message.version = reader.string();
	                    break;
	                case 3:
	                    message.sum = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            path: (0, helpers_1.isSet)(object.path) ? String(object.path) : "",
	            version: (0, helpers_1.isSet)(object.version) ? String(object.version) : "",
	            sum: (0, helpers_1.isSet)(object.sum) ? String(object.sum) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.path !== undefined && (obj.path = message.path);
	        message.version !== undefined && (obj.version = message.version);
	        message.sum !== undefined && (obj.sum = message.sum);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseModule();
	        message.path = object.path ?? "";
	        message.version = object.version ?? "";
	        message.sum = object.sum ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            path: object?.path,
	            version: object?.version,
	            sum: object?.sum
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.path = message.path;
	        obj.version = message.version;
	        obj.sum = message.sum;
	        return obj;
	    }
	};
	function createBaseABCIQueryRequest() {
	    return {
	        data: new Uint8Array(),
	        path: "",
	        height: helpers_1.Long.ZERO,
	        prove: false
	    };
	}
	exports.ABCIQueryRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.data.length !== 0) {
	            writer.uint32(10).bytes(message.data);
	        }
	        if (message.path !== "") {
	            writer.uint32(18).string(message.path);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(24).int64(message.height);
	        }
	        if (message.prove === true) {
	            writer.uint32(32).bool(message.prove);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseABCIQueryRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.data = reader.bytes();
	                    break;
	                case 2:
	                    message.path = reader.string();
	                    break;
	                case 3:
	                    message.height = reader.int64();
	                    break;
	                case 4:
	                    message.prove = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array(),
	            path: (0, helpers_1.isSet)(object.path) ? String(object.path) : "",
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            prove: (0, helpers_1.isSet)(object.prove) ? Boolean(object.prove) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        message.path !== undefined && (obj.path = message.path);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.prove !== undefined && (obj.prove = message.prove);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseABCIQueryRequest();
	        message.data = object.data ?? new Uint8Array();
	        message.path = object.path ?? "";
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.prove = object.prove ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            data: object?.data,
	            path: object?.path,
	            height: object?.height,
	            prove: object?.prove
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.data = message.data;
	        obj.path = message.path;
	        obj.height = message.height;
	        obj.prove = message.prove;
	        return obj;
	    }
	};
	function createBaseABCIQueryResponse() {
	    return {
	        code: 0,
	        log: "",
	        info: "",
	        index: helpers_1.Long.ZERO,
	        key: new Uint8Array(),
	        value: new Uint8Array(),
	        proofOps: undefined,
	        height: helpers_1.Long.ZERO,
	        codespace: ""
	    };
	}
	exports.ABCIQueryResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.code !== 0) {
	            writer.uint32(8).uint32(message.code);
	        }
	        if (message.log !== "") {
	            writer.uint32(26).string(message.log);
	        }
	        if (message.info !== "") {
	            writer.uint32(34).string(message.info);
	        }
	        if (!message.index.isZero()) {
	            writer.uint32(40).int64(message.index);
	        }
	        if (message.key.length !== 0) {
	            writer.uint32(50).bytes(message.key);
	        }
	        if (message.value.length !== 0) {
	            writer.uint32(58).bytes(message.value);
	        }
	        if (message.proofOps !== undefined) {
	            exports.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(72).int64(message.height);
	        }
	        if (message.codespace !== "") {
	            writer.uint32(82).string(message.codespace);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseABCIQueryResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.code = reader.uint32();
	                    break;
	                case 3:
	                    message.log = reader.string();
	                    break;
	                case 4:
	                    message.info = reader.string();
	                    break;
	                case 5:
	                    message.index = reader.int64();
	                    break;
	                case 6:
	                    message.key = reader.bytes();
	                    break;
	                case 7:
	                    message.value = reader.bytes();
	                    break;
	                case 8:
	                    message.proofOps = exports.ProofOps.decode(reader, reader.uint32());
	                    break;
	                case 9:
	                    message.height = reader.int64();
	                    break;
	                case 10:
	                    message.codespace = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            code: (0, helpers_1.isSet)(object.code) ? Number(object.code) : 0,
	            log: (0, helpers_1.isSet)(object.log) ? String(object.log) : "",
	            info: (0, helpers_1.isSet)(object.info) ? String(object.info) : "",
	            index: (0, helpers_1.isSet)(object.index) ? helpers_1.Long.fromValue(object.index) : helpers_1.Long.ZERO,
	            key: (0, helpers_1.isSet)(object.key) ? (0, helpers_1.bytesFromBase64)(object.key) : new Uint8Array(),
	            value: (0, helpers_1.isSet)(object.value) ? (0, helpers_1.bytesFromBase64)(object.value) : new Uint8Array(),
	            proofOps: (0, helpers_1.isSet)(object.proofOps) ? exports.ProofOps.fromJSON(object.proofOps) : undefined,
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            codespace: (0, helpers_1.isSet)(object.codespace) ? String(object.codespace) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.code !== undefined && (obj.code = Math.round(message.code));
	        message.log !== undefined && (obj.log = message.log);
	        message.info !== undefined && (obj.info = message.info);
	        message.index !== undefined && (obj.index = (message.index || helpers_1.Long.ZERO).toString());
	        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
	        message.value !== undefined && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
	        message.proofOps !== undefined && (obj.proofOps = message.proofOps ? exports.ProofOps.toJSON(message.proofOps) : undefined);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.codespace !== undefined && (obj.codespace = message.codespace);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseABCIQueryResponse();
	        message.code = object.code ?? 0;
	        message.log = object.log ?? "";
	        message.info = object.info ?? "";
	        message.index = object.index !== undefined && object.index !== null ? helpers_1.Long.fromValue(object.index) : helpers_1.Long.ZERO;
	        message.key = object.key ?? new Uint8Array();
	        message.value = object.value ?? new Uint8Array();
	        message.proofOps = object.proofOps !== undefined && object.proofOps !== null ? exports.ProofOps.fromPartial(object.proofOps) : undefined;
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.codespace = object.codespace ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            code: object?.code,
	            log: object?.log,
	            info: object?.info,
	            index: object?.index,
	            key: object?.key,
	            value: object?.value,
	            proofOps: object.proof_ops ? exports.ProofOps.fromSDK(object.proof_ops) : undefined,
	            height: object?.height,
	            codespace: object?.codespace
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.code = message.code;
	        obj.log = message.log;
	        obj.info = message.info;
	        obj.index = message.index;
	        obj.key = message.key;
	        obj.value = message.value;
	        message.proofOps !== undefined && (obj.proof_ops = message.proofOps ? exports.ProofOps.toSDK(message.proofOps) : undefined);
	        obj.height = message.height;
	        obj.codespace = message.codespace;
	        return obj;
	    }
	};
	function createBaseProofOp() {
	    return {
	        type: "",
	        key: new Uint8Array(),
	        data: new Uint8Array()
	    };
	}
	exports.ProofOp = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== "") {
	            writer.uint32(10).string(message.type);
	        }
	        if (message.key.length !== 0) {
	            writer.uint32(18).bytes(message.key);
	        }
	        if (message.data.length !== 0) {
	            writer.uint32(26).bytes(message.data);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseProofOp();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.string();
	                    break;
	                case 2:
	                    message.key = reader.bytes();
	                    break;
	                case 3:
	                    message.data = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? String(object.type) : "",
	            key: (0, helpers_1.isSet)(object.key) ? (0, helpers_1.bytesFromBase64)(object.key) : new Uint8Array(),
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = message.type);
	        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseProofOp();
	        message.type = object.type ?? "";
	        message.key = object.key ?? new Uint8Array();
	        message.data = object.data ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: object?.type,
	            key: object?.key,
	            data: object?.data
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.type = message.type;
	        obj.key = message.key;
	        obj.data = message.data;
	        return obj;
	    }
	};
	function createBaseProofOps() {
	    return {
	        ops: []
	    };
	}
	exports.ProofOps = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.ops) {
	            exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseProofOps();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            ops: Array.isArray(object?.ops) ? object.ops.map((e) => exports.ProofOp.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.ops) {
	            obj.ops = message.ops.map(e => e ? exports.ProofOp.toJSON(e) : undefined);
	        }
	        else {
	            obj.ops = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseProofOps();
	        message.ops = object.ops?.map(e => exports.ProofOp.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            ops: Array.isArray(object?.ops) ? object.ops.map((e) => exports.ProofOp.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.ops) {
	            obj.ops = message.ops.map(e => e ? exports.ProofOp.toSDK(e) : undefined);
	        }
	        else {
	            obj.ops = [];
	        }
	        return obj;
	    }
	};
	class ServiceClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.GetNodeInfo = this.GetNodeInfo.bind(this);
	        this.GetSyncing = this.GetSyncing.bind(this);
	        this.GetLatestBlock = this.GetLatestBlock.bind(this);
	        this.GetBlockByHeight = this.GetBlockByHeight.bind(this);
	        this.GetLatestValidatorSet = this.GetLatestValidatorSet.bind(this);
	        this.GetValidatorSetByHeight = this.GetValidatorSetByHeight.bind(this);
	        this.ABCIQuery = this.ABCIQuery.bind(this);
	    }
	    GetNodeInfo(request = {}) {
	        const data = exports.GetNodeInfoRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.base.tendermint.v1beta1.Service", "GetNodeInfo", data);
	        return promise.then(data => exports.GetNodeInfoResponse.decode(new _m0.Reader(data)));
	    }
	    GetSyncing(request = {}) {
	        const data = exports.GetSyncingRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.base.tendermint.v1beta1.Service", "GetSyncing", data);
	        return promise.then(data => exports.GetSyncingResponse.decode(new _m0.Reader(data)));
	    }
	    GetLatestBlock(request = {}) {
	        const data = exports.GetLatestBlockRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.base.tendermint.v1beta1.Service", "GetLatestBlock", data);
	        return promise.then(data => exports.GetLatestBlockResponse.decode(new _m0.Reader(data)));
	    }
	    GetBlockByHeight(request) {
	        const data = exports.GetBlockByHeightRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.base.tendermint.v1beta1.Service", "GetBlockByHeight", data);
	        return promise.then(data => exports.GetBlockByHeightResponse.decode(new _m0.Reader(data)));
	    }
	    GetLatestValidatorSet(request = {
	        pagination: undefined
	    }) {
	        const data = exports.GetLatestValidatorSetRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.base.tendermint.v1beta1.Service", "GetLatestValidatorSet", data);
	        return promise.then(data => exports.GetLatestValidatorSetResponse.decode(new _m0.Reader(data)));
	    }
	    GetValidatorSetByHeight(request) {
	        const data = exports.GetValidatorSetByHeightRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.base.tendermint.v1beta1.Service", "GetValidatorSetByHeight", data);
	        return promise.then(data => exports.GetValidatorSetByHeightResponse.decode(new _m0.Reader(data)));
	    }
	    ABCIQuery(request) {
	        const data = exports.ABCIQueryRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.base.tendermint.v1beta1.Service", "ABCIQuery", data);
	        return promise.then(data => exports.ABCIQueryResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.ServiceClientImpl = ServiceClientImpl;
	
} (query$6));

query$6.default;

var service = {};

var tx$6 = {};

var signing = {};

var multisig = {};

var __createBinding$8 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$8 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$8 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$8(result, mod, k);
    __setModuleDefault$8(result, mod);
    return result;
};
Object.defineProperty(multisig, "__esModule", { value: true });
multisig.CompactBitArray = multisig.MultiSignature = multisig.protobufPackage = void 0;
/* eslint-disable */
const _m0$8 = __importStar$8(minimal$1.exports);
const helpers_1$8 = helpers;
multisig.protobufPackage = "cosmos.crypto.multisig.v1beta1";
function createBaseMultiSignature() {
    return {
        signatures: []
    };
}
multisig.MultiSignature = {
    encode(message, writer = _m0$8.Writer.create()) {
        for (const v of message.signatures) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$8.Reader ? input : new _m0$8.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => (0, helpers_1$8.bytesFromBase64)(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signatures) {
            obj.signatures = message.signatures.map(e => (0, helpers_1$8.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.signatures = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMultiSignature();
        message.signatures = object.signatures?.map(e => e) || [];
        return message;
    },
    fromSDK(object) {
        return {
            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => e) : []
        };
    },
    toSDK(message) {
        const obj = {};
        if (message.signatures) {
            obj.signatures = message.signatures.map(e => e);
        }
        else {
            obj.signatures = [];
        }
        return obj;
    }
};
function createBaseCompactBitArray() {
    return {
        extraBitsStored: 0,
        elems: new Uint8Array()
    };
}
multisig.CompactBitArray = {
    encode(message, writer = _m0$8.Writer.create()) {
        if (message.extraBitsStored !== 0) {
            writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
            writer.uint32(18).bytes(message.elems);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$8.Reader ? input : new _m0$8.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.extraBitsStored = reader.uint32();
                    break;
                case 2:
                    message.elems = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            extraBitsStored: (0, helpers_1$8.isSet)(object.extraBitsStored) ? Number(object.extraBitsStored) : 0,
            elems: (0, helpers_1$8.isSet)(object.elems) ? (0, helpers_1$8.bytesFromBase64)(object.elems) : new Uint8Array()
        };
    },
    toJSON(message) {
        const obj = {};
        message.extraBitsStored !== undefined && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== undefined && (obj.elems = (0, helpers_1$8.base64FromBytes)(message.elems !== undefined ? message.elems : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCompactBitArray();
        message.extraBitsStored = object.extraBitsStored ?? 0;
        message.elems = object.elems ?? new Uint8Array();
        return message;
    },
    fromSDK(object) {
        return {
            extraBitsStored: object?.extra_bits_stored,
            elems: object?.elems
        };
    },
    toSDK(message) {
        const obj = {};
        obj.extra_bits_stored = message.extraBitsStored;
        obj.elems = message.elems;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignModeSDKType = exports.SignMode = exports.protobufPackage = void 0;
	/* eslint-disable */
	const multisig_1 = multisig;
	const any_1 = any;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.tx.signing.v1beta1";
	/**
	 * SignMode represents a signing mode with its own security guarantees.
	 *
	 * This enum should be considered a registry of all known sign modes
	 * in the Cosmos ecosystem. Apps are not expected to support all known
	 * sign modes. Apps that would like to support custom  sign modes are
	 * encouraged to open a small PR against this file to add a new case
	 * to this SignMode enum describing their sign mode so that different
	 * apps have a consistent version of this enum.
	 */
	var SignMode;
	(function (SignMode) {
	    /**
	     * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
	     * rejected.
	     */
	    SignMode[SignMode["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
	    /**
	     * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
	     * verified with raw bytes from Tx.
	     */
	    SignMode[SignMode["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
	    /**
	     * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some
	     * human-readable textual representation on top of the binary representation
	     * from SIGN_MODE_DIRECT. It is currently not supported.
	     */
	    SignMode[SignMode["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
	    /**
	     * SIGN_MODE_DIRECT_AUX - SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
	     * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
	     * require signers signing over other signers' `signer_info`. It also allows
	     * for adding Tips in transactions.
	     *
	     * Since: cosmos-sdk 0.46
	     */
	    SignMode[SignMode["SIGN_MODE_DIRECT_AUX"] = 3] = "SIGN_MODE_DIRECT_AUX";
	    /**
	     * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
	     * Amino JSON and will be removed in the future.
	     */
	    SignMode[SignMode["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
	    /**
	     * SIGN_MODE_EIP_191 - SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
	     * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
	     *
	     * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
	     * but is not implemented on the SDK by default. To enable EIP-191, you need
	     * to pass a custom `TxConfig` that has an implementation of
	     * `SignModeHandler` for EIP-191. The SDK may decide to fully support
	     * EIP-191 in the future.
	     *
	     * Since: cosmos-sdk 0.45.2
	     */
	    SignMode[SignMode["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
	    /**
	     * SIGN_MODE_EIP_712 - SIGN_MODE_EIP_712 specifies the sign mode for EIP 712 signing on the Cosmos
	     * SDK. Ref: https://eips.ethereum.org/EIPS/eip-712
	     */
	    SignMode[SignMode["SIGN_MODE_EIP_712"] = 712] = "SIGN_MODE_EIP_712";
	    SignMode[SignMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(SignMode = exports.SignMode || (exports.SignMode = {}));
	exports.SignModeSDKType = SignMode;
	function signModeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "SIGN_MODE_UNSPECIFIED":
	            return SignMode.SIGN_MODE_UNSPECIFIED;
	        case 1:
	        case "SIGN_MODE_DIRECT":
	            return SignMode.SIGN_MODE_DIRECT;
	        case 2:
	        case "SIGN_MODE_TEXTUAL":
	            return SignMode.SIGN_MODE_TEXTUAL;
	        case 3:
	        case "SIGN_MODE_DIRECT_AUX":
	            return SignMode.SIGN_MODE_DIRECT_AUX;
	        case 127:
	        case "SIGN_MODE_LEGACY_AMINO_JSON":
	            return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
	        case 191:
	        case "SIGN_MODE_EIP_191":
	            return SignMode.SIGN_MODE_EIP_191;
	        case 712:
	        case "SIGN_MODE_EIP_712":
	            return SignMode.SIGN_MODE_EIP_712;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return SignMode.UNRECOGNIZED;
	    }
	}
	exports.signModeFromJSON = signModeFromJSON;
	function signModeToJSON(object) {
	    switch (object) {
	        case SignMode.SIGN_MODE_UNSPECIFIED:
	            return "SIGN_MODE_UNSPECIFIED";
	        case SignMode.SIGN_MODE_DIRECT:
	            return "SIGN_MODE_DIRECT";
	        case SignMode.SIGN_MODE_TEXTUAL:
	            return "SIGN_MODE_TEXTUAL";
	        case SignMode.SIGN_MODE_DIRECT_AUX:
	            return "SIGN_MODE_DIRECT_AUX";
	        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
	            return "SIGN_MODE_LEGACY_AMINO_JSON";
	        case SignMode.SIGN_MODE_EIP_191:
	            return "SIGN_MODE_EIP_191";
	        case SignMode.SIGN_MODE_EIP_712:
	            return "SIGN_MODE_EIP_712";
	        case SignMode.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.signModeToJSON = signModeToJSON;
	function createBaseSignatureDescriptors() {
	    return {
	        signatures: []
	    };
	}
	exports.SignatureDescriptors = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.signatures) {
	            exports.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignatureDescriptors();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => exports.SignatureDescriptor.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e ? exports.SignatureDescriptor.toJSON(e) : undefined);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignatureDescriptors();
	        message.signatures = object.signatures?.map(e => exports.SignatureDescriptor.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => exports.SignatureDescriptor.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e ? exports.SignatureDescriptor.toSDK(e) : undefined);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    }
	};
	function createBaseSignatureDescriptor() {
	    return {
	        publicKey: undefined,
	        data: undefined,
	        sequence: helpers_1.Long.UZERO
	    };
	}
	exports.SignatureDescriptor = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.publicKey !== undefined) {
	            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.data !== undefined) {
	            exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.sequence.isZero()) {
	            writer.uint32(24).uint64(message.sequence);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignatureDescriptor();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.publicKey = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.sequence = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            publicKey: (0, helpers_1.isSet)(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : undefined,
	            data: (0, helpers_1.isSet)(object.data) ? exports.SignatureDescriptor_Data.fromJSON(object.data) : undefined,
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);
	        message.data !== undefined && (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : undefined);
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignatureDescriptor();
	        message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : undefined;
	        message.data = object.data !== undefined && object.data !== null ? exports.SignatureDescriptor_Data.fromPartial(object.data) : undefined;
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            publicKey: object.public_key ? any_1.Any.fromSDK(object.public_key) : undefined,
	            data: object.data ? exports.SignatureDescriptor_Data.fromSDK(object.data) : undefined,
	            sequence: object?.sequence
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.publicKey !== undefined && (obj.public_key = message.publicKey ? any_1.Any.toSDK(message.publicKey) : undefined);
	        message.data !== undefined && (obj.data = message.data ? exports.SignatureDescriptor_Data.toSDK(message.data) : undefined);
	        obj.sequence = message.sequence;
	        return obj;
	    }
	};
	function createBaseSignatureDescriptor_Data() {
	    return {
	        single: undefined,
	        multi: undefined
	    };
	}
	exports.SignatureDescriptor_Data = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.single !== undefined) {
	            exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.multi !== undefined) {
	            exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignatureDescriptor_Data();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            single: (0, helpers_1.isSet)(object.single) ? exports.SignatureDescriptor_Data_Single.fromJSON(object.single) : undefined,
	            multi: (0, helpers_1.isSet)(object.multi) ? exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.single !== undefined && (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : undefined);
	        message.multi !== undefined && (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignatureDescriptor_Data();
	        message.single = object.single !== undefined && object.single !== null ? exports.SignatureDescriptor_Data_Single.fromPartial(object.single) : undefined;
	        message.multi = object.multi !== undefined && object.multi !== null ? exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            single: object.single ? exports.SignatureDescriptor_Data_Single.fromSDK(object.single) : undefined,
	            multi: object.multi ? exports.SignatureDescriptor_Data_Multi.fromSDK(object.multi) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.single !== undefined && (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toSDK(message.single) : undefined);
	        message.multi !== undefined && (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toSDK(message.multi) : undefined);
	        return obj;
	    }
	};
	function createBaseSignatureDescriptor_Data_Single() {
	    return {
	        mode: 0,
	        signature: new Uint8Array()
	    };
	}
	exports.SignatureDescriptor_Data_Single = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.mode !== 0) {
	            writer.uint32(8).int32(message.mode);
	        }
	        if (message.signature.length !== 0) {
	            writer.uint32(18).bytes(message.signature);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignatureDescriptor_Data_Single();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.mode = reader.int32();
	                    break;
	                case 2:
	                    message.signature = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            mode: (0, helpers_1.isSet)(object.mode) ? signModeFromJSON(object.mode) : 0,
	            signature: (0, helpers_1.isSet)(object.signature) ? (0, helpers_1.bytesFromBase64)(object.signature) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));
	        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignatureDescriptor_Data_Single();
	        message.mode = object.mode ?? 0;
	        message.signature = object.signature ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            mode: (0, helpers_1.isSet)(object.mode) ? signModeFromJSON(object.mode) : 0,
	            signature: object?.signature
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));
	        obj.signature = message.signature;
	        return obj;
	    }
	};
	function createBaseSignatureDescriptor_Data_Multi() {
	    return {
	        bitarray: undefined,
	        signatures: []
	    };
	}
	exports.SignatureDescriptor_Data_Multi = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bitarray !== undefined) {
	            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
	        }
	        for (const v of message.signatures) {
	            exports.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignatureDescriptor_Data_Multi();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bitarray: (0, helpers_1.isSet)(object.bitarray) ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : undefined,
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => exports.SignatureDescriptor_Data.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e ? exports.SignatureDescriptor_Data.toJSON(e) : undefined);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignatureDescriptor_Data_Multi();
	        message.bitarray = object.bitarray !== undefined && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : undefined;
	        message.signatures = object.signatures?.map(e => exports.SignatureDescriptor_Data.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bitarray: object.bitarray ? multisig_1.CompactBitArray.fromSDK(object.bitarray) : undefined,
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => exports.SignatureDescriptor_Data.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toSDK(message.bitarray) : undefined);
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e ? exports.SignatureDescriptor_Data.toSDK(e) : undefined);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    }
	};
	
} (signing));

signing.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AuxSignerData = exports.Tip = exports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDocEip712 = exports.SignDocDirectAux = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;
	/* eslint-disable */
	const any_1 = any;
	const signing_1 = signing;
	const multisig_1 = multisig;
	const coin_1 = coin;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.tx.v1beta1";
	function createBaseTx() {
	    return {
	        body: undefined,
	        authInfo: undefined,
	        signatures: []
	    };
	}
	exports.Tx = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.body !== undefined) {
	            exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.authInfo !== undefined) {
	            exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
	        }
	        for (const v of message.signatures) {
	            writer.uint32(26).bytes(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTx();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.body = exports.TxBody.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.signatures.push(reader.bytes());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            body: (0, helpers_1.isSet)(object.body) ? exports.TxBody.fromJSON(object.body) : undefined,
	            authInfo: (0, helpers_1.isSet)(object.authInfo) ? exports.AuthInfo.fromJSON(object.authInfo) : undefined,
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.body !== undefined && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : undefined);
	        message.authInfo !== undefined && (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : undefined);
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTx();
	        message.body = object.body !== undefined && object.body !== null ? exports.TxBody.fromPartial(object.body) : undefined;
	        message.authInfo = object.authInfo !== undefined && object.authInfo !== null ? exports.AuthInfo.fromPartial(object.authInfo) : undefined;
	        message.signatures = object.signatures?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            body: object.body ? exports.TxBody.fromSDK(object.body) : undefined,
	            authInfo: object.auth_info ? exports.AuthInfo.fromSDK(object.auth_info) : undefined,
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.body !== undefined && (obj.body = message.body ? exports.TxBody.toSDK(message.body) : undefined);
	        message.authInfo !== undefined && (obj.auth_info = message.authInfo ? exports.AuthInfo.toSDK(message.authInfo) : undefined);
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    }
	};
	function createBaseTxRaw() {
	    return {
	        bodyBytes: new Uint8Array(),
	        authInfoBytes: new Uint8Array(),
	        signatures: []
	    };
	}
	exports.TxRaw = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bodyBytes.length !== 0) {
	            writer.uint32(10).bytes(message.bodyBytes);
	        }
	        if (message.authInfoBytes.length !== 0) {
	            writer.uint32(18).bytes(message.authInfoBytes);
	        }
	        for (const v of message.signatures) {
	            writer.uint32(26).bytes(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxRaw();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bodyBytes = reader.bytes();
	                    break;
	                case 2:
	                    message.authInfoBytes = reader.bytes();
	                    break;
	                case 3:
	                    message.signatures.push(reader.bytes());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bodyBytes: (0, helpers_1.isSet)(object.bodyBytes) ? (0, helpers_1.bytesFromBase64)(object.bodyBytes) : new Uint8Array(),
	            authInfoBytes: (0, helpers_1.isSet)(object.authInfoBytes) ? (0, helpers_1.bytesFromBase64)(object.authInfoBytes) : new Uint8Array(),
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bodyBytes !== undefined && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
	        message.authInfoBytes !== undefined && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxRaw();
	        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
	        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
	        message.signatures = object.signatures?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bodyBytes: object?.body_bytes,
	            authInfoBytes: object?.auth_info_bytes,
	            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.body_bytes = message.bodyBytes;
	        obj.auth_info_bytes = message.authInfoBytes;
	        if (message.signatures) {
	            obj.signatures = message.signatures.map(e => e);
	        }
	        else {
	            obj.signatures = [];
	        }
	        return obj;
	    }
	};
	function createBaseSignDoc() {
	    return {
	        bodyBytes: new Uint8Array(),
	        authInfoBytes: new Uint8Array(),
	        chainId: "",
	        accountNumber: helpers_1.Long.UZERO
	    };
	}
	exports.SignDoc = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bodyBytes.length !== 0) {
	            writer.uint32(10).bytes(message.bodyBytes);
	        }
	        if (message.authInfoBytes.length !== 0) {
	            writer.uint32(18).bytes(message.authInfoBytes);
	        }
	        if (message.chainId !== "") {
	            writer.uint32(26).string(message.chainId);
	        }
	        if (!message.accountNumber.isZero()) {
	            writer.uint32(32).uint64(message.accountNumber);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignDoc();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bodyBytes = reader.bytes();
	                    break;
	                case 2:
	                    message.authInfoBytes = reader.bytes();
	                    break;
	                case 3:
	                    message.chainId = reader.string();
	                    break;
	                case 4:
	                    message.accountNumber = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bodyBytes: (0, helpers_1.isSet)(object.bodyBytes) ? (0, helpers_1.bytesFromBase64)(object.bodyBytes) : new Uint8Array(),
	            authInfoBytes: (0, helpers_1.isSet)(object.authInfoBytes) ? (0, helpers_1.bytesFromBase64)(object.authInfoBytes) : new Uint8Array(),
	            chainId: (0, helpers_1.isSet)(object.chainId) ? String(object.chainId) : "",
	            accountNumber: (0, helpers_1.isSet)(object.accountNumber) ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bodyBytes !== undefined && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
	        message.authInfoBytes !== undefined && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));
	        message.chainId !== undefined && (obj.chainId = message.chainId);
	        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignDoc();
	        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
	        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
	        message.chainId = object.chainId ?? "";
	        message.accountNumber = object.accountNumber !== undefined && object.accountNumber !== null ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bodyBytes: object?.body_bytes,
	            authInfoBytes: object?.auth_info_bytes,
	            chainId: object?.chain_id,
	            accountNumber: object?.account_number
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.body_bytes = message.bodyBytes;
	        obj.auth_info_bytes = message.authInfoBytes;
	        obj.chain_id = message.chainId;
	        obj.account_number = message.accountNumber;
	        return obj;
	    }
	};
	function createBaseSignDocDirectAux() {
	    return {
	        bodyBytes: new Uint8Array(),
	        publicKey: undefined,
	        chainId: "",
	        accountNumber: helpers_1.Long.UZERO,
	        sequence: helpers_1.Long.UZERO,
	        tip: undefined
	    };
	}
	exports.SignDocDirectAux = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bodyBytes.length !== 0) {
	            writer.uint32(10).bytes(message.bodyBytes);
	        }
	        if (message.publicKey !== undefined) {
	            any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.chainId !== "") {
	            writer.uint32(26).string(message.chainId);
	        }
	        if (!message.accountNumber.isZero()) {
	            writer.uint32(32).uint64(message.accountNumber);
	        }
	        if (!message.sequence.isZero()) {
	            writer.uint32(40).uint64(message.sequence);
	        }
	        if (message.tip !== undefined) {
	            exports.Tip.encode(message.tip, writer.uint32(50).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignDocDirectAux();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bodyBytes = reader.bytes();
	                    break;
	                case 2:
	                    message.publicKey = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.chainId = reader.string();
	                    break;
	                case 4:
	                    message.accountNumber = reader.uint64();
	                    break;
	                case 5:
	                    message.sequence = reader.uint64();
	                    break;
	                case 6:
	                    message.tip = exports.Tip.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bodyBytes: (0, helpers_1.isSet)(object.bodyBytes) ? (0, helpers_1.bytesFromBase64)(object.bodyBytes) : new Uint8Array(),
	            publicKey: (0, helpers_1.isSet)(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : undefined,
	            chainId: (0, helpers_1.isSet)(object.chainId) ? String(object.chainId) : "",
	            accountNumber: (0, helpers_1.isSet)(object.accountNumber) ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO,
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO,
	            tip: (0, helpers_1.isSet)(object.tip) ? exports.Tip.fromJSON(object.tip) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bodyBytes !== undefined && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
	        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);
	        message.chainId !== undefined && (obj.chainId = message.chainId);
	        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || helpers_1.Long.UZERO).toString());
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignDocDirectAux();
	        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
	        message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : undefined;
	        message.chainId = object.chainId ?? "";
	        message.accountNumber = object.accountNumber !== undefined && object.accountNumber !== null ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO;
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        message.tip = object.tip !== undefined && object.tip !== null ? exports.Tip.fromPartial(object.tip) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bodyBytes: object?.body_bytes,
	            publicKey: object.public_key ? any_1.Any.fromSDK(object.public_key) : undefined,
	            chainId: object?.chain_id,
	            accountNumber: object?.account_number,
	            sequence: object?.sequence,
	            tip: object.tip ? exports.Tip.fromSDK(object.tip) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.body_bytes = message.bodyBytes;
	        message.publicKey !== undefined && (obj.public_key = message.publicKey ? any_1.Any.toSDK(message.publicKey) : undefined);
	        obj.chain_id = message.chainId;
	        obj.account_number = message.accountNumber;
	        obj.sequence = message.sequence;
	        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toSDK(message.tip) : undefined);
	        return obj;
	    }
	};
	function createBaseSignDocEip712() {
	    return {
	        chainId: helpers_1.Long.UZERO,
	        accountNumber: helpers_1.Long.UZERO,
	        sequence: helpers_1.Long.UZERO,
	        fee: undefined,
	        msg: undefined,
	        timeoutHeight: helpers_1.Long.UZERO,
	        memo: "",
	        tip: undefined
	    };
	}
	exports.SignDocEip712 = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.chainId.isZero()) {
	            writer.uint32(8).uint64(message.chainId);
	        }
	        if (!message.accountNumber.isZero()) {
	            writer.uint32(16).uint64(message.accountNumber);
	        }
	        if (!message.sequence.isZero()) {
	            writer.uint32(24).uint64(message.sequence);
	        }
	        if (message.fee !== undefined) {
	            exports.Fee.encode(message.fee, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.msg !== undefined) {
	            any_1.Any.encode(message.msg, writer.uint32(42).fork()).ldelim();
	        }
	        if (!message.timeoutHeight.isZero()) {
	            writer.uint32(48).uint64(message.timeoutHeight);
	        }
	        if (message.memo !== "") {
	            writer.uint32(58).string(message.memo);
	        }
	        if (message.tip !== undefined) {
	            exports.Tip.encode(message.tip, writer.uint32(66).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignDocEip712();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.chainId = reader.uint64();
	                    break;
	                case 2:
	                    message.accountNumber = reader.uint64();
	                    break;
	                case 3:
	                    message.sequence = reader.uint64();
	                    break;
	                case 4:
	                    message.fee = exports.Fee.decode(reader, reader.uint32());
	                    break;
	                case 5:
	                    message.msg = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                case 6:
	                    message.timeoutHeight = reader.uint64();
	                    break;
	                case 7:
	                    message.memo = reader.string();
	                    break;
	                case 8:
	                    message.tip = exports.Tip.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            chainId: (0, helpers_1.isSet)(object.chainId) ? helpers_1.Long.fromValue(object.chainId) : helpers_1.Long.UZERO,
	            accountNumber: (0, helpers_1.isSet)(object.accountNumber) ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO,
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO,
	            fee: (0, helpers_1.isSet)(object.fee) ? exports.Fee.fromJSON(object.fee) : undefined,
	            msg: (0, helpers_1.isSet)(object.msg) ? any_1.Any.fromJSON(object.msg) : undefined,
	            timeoutHeight: (0, helpers_1.isSet)(object.timeoutHeight) ? helpers_1.Long.fromValue(object.timeoutHeight) : helpers_1.Long.UZERO,
	            memo: (0, helpers_1.isSet)(object.memo) ? String(object.memo) : "",
	            tip: (0, helpers_1.isSet)(object.tip) ? exports.Tip.fromJSON(object.tip) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.chainId !== undefined && (obj.chainId = (message.chainId || helpers_1.Long.UZERO).toString());
	        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || helpers_1.Long.UZERO).toString());
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : undefined);
	        message.msg !== undefined && (obj.msg = message.msg ? any_1.Any.toJSON(message.msg) : undefined);
	        message.timeoutHeight !== undefined && (obj.timeoutHeight = (message.timeoutHeight || helpers_1.Long.UZERO).toString());
	        message.memo !== undefined && (obj.memo = message.memo);
	        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignDocEip712();
	        message.chainId = object.chainId !== undefined && object.chainId !== null ? helpers_1.Long.fromValue(object.chainId) : helpers_1.Long.UZERO;
	        message.accountNumber = object.accountNumber !== undefined && object.accountNumber !== null ? helpers_1.Long.fromValue(object.accountNumber) : helpers_1.Long.UZERO;
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        message.fee = object.fee !== undefined && object.fee !== null ? exports.Fee.fromPartial(object.fee) : undefined;
	        message.msg = object.msg !== undefined && object.msg !== null ? any_1.Any.fromPartial(object.msg) : undefined;
	        message.timeoutHeight = object.timeoutHeight !== undefined && object.timeoutHeight !== null ? helpers_1.Long.fromValue(object.timeoutHeight) : helpers_1.Long.UZERO;
	        message.memo = object.memo ?? "";
	        message.tip = object.tip !== undefined && object.tip !== null ? exports.Tip.fromPartial(object.tip) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            chainId: object?.chain_id,
	            accountNumber: object?.account_number,
	            sequence: object?.sequence,
	            fee: object.fee ? exports.Fee.fromSDK(object.fee) : undefined,
	            msg: object.msg ? any_1.Any.fromSDK(object.msg) : undefined,
	            timeoutHeight: object?.timeout_height,
	            memo: object?.memo,
	            tip: object.tip ? exports.Tip.fromSDK(object.tip) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.chain_id = message.chainId;
	        obj.account_number = message.accountNumber;
	        obj.sequence = message.sequence;
	        message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toSDK(message.fee) : undefined);
	        message.msg !== undefined && (obj.msg = message.msg ? any_1.Any.toSDK(message.msg) : undefined);
	        obj.timeout_height = message.timeoutHeight;
	        obj.memo = message.memo;
	        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toSDK(message.tip) : undefined);
	        return obj;
	    }
	};
	function createBaseTxBody() {
	    return {
	        messages: [],
	        memo: "",
	        timeoutHeight: helpers_1.Long.UZERO,
	        extensionOptions: [],
	        nonCriticalExtensionOptions: []
	    };
	}
	exports.TxBody = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.messages) {
	            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.memo !== "") {
	            writer.uint32(18).string(message.memo);
	        }
	        if (!message.timeoutHeight.isZero()) {
	            writer.uint32(24).uint64(message.timeoutHeight);
	        }
	        for (const v of message.extensionOptions) {
	            any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();
	        }
	        for (const v of message.nonCriticalExtensionOptions) {
	            any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxBody();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.memo = reader.string();
	                    break;
	                case 3:
	                    message.timeoutHeight = reader.uint64();
	                    break;
	                case 1023:
	                    message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
	                    break;
	                case 2047:
	                    message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            messages: Array.isArray(object?.messages) ? object.messages.map((e) => any_1.Any.fromJSON(e)) : [],
	            memo: (0, helpers_1.isSet)(object.memo) ? String(object.memo) : "",
	            timeoutHeight: (0, helpers_1.isSet)(object.timeoutHeight) ? helpers_1.Long.fromValue(object.timeoutHeight) : helpers_1.Long.UZERO,
	            extensionOptions: Array.isArray(object?.extensionOptions) ? object.extensionOptions.map((e) => any_1.Any.fromJSON(e)) : [],
	            nonCriticalExtensionOptions: Array.isArray(object?.nonCriticalExtensionOptions) ? object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.messages) {
	            obj.messages = message.messages.map(e => e ? any_1.Any.toJSON(e) : undefined);
	        }
	        else {
	            obj.messages = [];
	        }
	        message.memo !== undefined && (obj.memo = message.memo);
	        message.timeoutHeight !== undefined && (obj.timeoutHeight = (message.timeoutHeight || helpers_1.Long.UZERO).toString());
	        if (message.extensionOptions) {
	            obj.extensionOptions = message.extensionOptions.map(e => e ? any_1.Any.toJSON(e) : undefined);
	        }
	        else {
	            obj.extensionOptions = [];
	        }
	        if (message.nonCriticalExtensionOptions) {
	            obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map(e => e ? any_1.Any.toJSON(e) : undefined);
	        }
	        else {
	            obj.nonCriticalExtensionOptions = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxBody();
	        message.messages = object.messages?.map(e => any_1.Any.fromPartial(e)) || [];
	        message.memo = object.memo ?? "";
	        message.timeoutHeight = object.timeoutHeight !== undefined && object.timeoutHeight !== null ? helpers_1.Long.fromValue(object.timeoutHeight) : helpers_1.Long.UZERO;
	        message.extensionOptions = object.extensionOptions?.map(e => any_1.Any.fromPartial(e)) || [];
	        message.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions?.map(e => any_1.Any.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            messages: Array.isArray(object?.messages) ? object.messages.map((e) => any_1.Any.fromSDK(e)) : [],
	            memo: object?.memo,
	            timeoutHeight: object?.timeout_height,
	            extensionOptions: Array.isArray(object?.extension_options) ? object.extension_options.map((e) => any_1.Any.fromSDK(e)) : [],
	            nonCriticalExtensionOptions: Array.isArray(object?.non_critical_extension_options) ? object.non_critical_extension_options.map((e) => any_1.Any.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.messages) {
	            obj.messages = message.messages.map(e => e ? any_1.Any.toSDK(e) : undefined);
	        }
	        else {
	            obj.messages = [];
	        }
	        obj.memo = message.memo;
	        obj.timeout_height = message.timeoutHeight;
	        if (message.extensionOptions) {
	            obj.extension_options = message.extensionOptions.map(e => e ? any_1.Any.toSDK(e) : undefined);
	        }
	        else {
	            obj.extension_options = [];
	        }
	        if (message.nonCriticalExtensionOptions) {
	            obj.non_critical_extension_options = message.nonCriticalExtensionOptions.map(e => e ? any_1.Any.toSDK(e) : undefined);
	        }
	        else {
	            obj.non_critical_extension_options = [];
	        }
	        return obj;
	    }
	};
	function createBaseAuthInfo() {
	    return {
	        signerInfos: [],
	        fee: undefined,
	        tip: undefined
	    };
	}
	exports.AuthInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.signerInfos) {
	            exports.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.fee !== undefined) {
	            exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.tip !== undefined) {
	            exports.Tip.encode(message.tip, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAuthInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.fee = exports.Fee.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.tip = exports.Tip.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            signerInfos: Array.isArray(object?.signerInfos) ? object.signerInfos.map((e) => exports.SignerInfo.fromJSON(e)) : [],
	            fee: (0, helpers_1.isSet)(object.fee) ? exports.Fee.fromJSON(object.fee) : undefined,
	            tip: (0, helpers_1.isSet)(object.tip) ? exports.Tip.fromJSON(object.tip) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.signerInfos) {
	            obj.signerInfos = message.signerInfos.map(e => e ? exports.SignerInfo.toJSON(e) : undefined);
	        }
	        else {
	            obj.signerInfos = [];
	        }
	        message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : undefined);
	        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAuthInfo();
	        message.signerInfos = object.signerInfos?.map(e => exports.SignerInfo.fromPartial(e)) || [];
	        message.fee = object.fee !== undefined && object.fee !== null ? exports.Fee.fromPartial(object.fee) : undefined;
	        message.tip = object.tip !== undefined && object.tip !== null ? exports.Tip.fromPartial(object.tip) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            signerInfos: Array.isArray(object?.signer_infos) ? object.signer_infos.map((e) => exports.SignerInfo.fromSDK(e)) : [],
	            fee: object.fee ? exports.Fee.fromSDK(object.fee) : undefined,
	            tip: object.tip ? exports.Tip.fromSDK(object.tip) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.signerInfos) {
	            obj.signer_infos = message.signerInfos.map(e => e ? exports.SignerInfo.toSDK(e) : undefined);
	        }
	        else {
	            obj.signer_infos = [];
	        }
	        message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toSDK(message.fee) : undefined);
	        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toSDK(message.tip) : undefined);
	        return obj;
	    }
	};
	function createBaseSignerInfo() {
	    return {
	        publicKey: undefined,
	        modeInfo: undefined,
	        sequence: helpers_1.Long.UZERO
	    };
	}
	exports.SignerInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.publicKey !== undefined) {
	            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.modeInfo !== undefined) {
	            exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.sequence.isZero()) {
	            writer.uint32(24).uint64(message.sequence);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSignerInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.publicKey = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.sequence = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            publicKey: (0, helpers_1.isSet)(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : undefined,
	            modeInfo: (0, helpers_1.isSet)(object.modeInfo) ? exports.ModeInfo.fromJSON(object.modeInfo) : undefined,
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);
	        message.modeInfo !== undefined && (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : undefined);
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSignerInfo();
	        message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : undefined;
	        message.modeInfo = object.modeInfo !== undefined && object.modeInfo !== null ? exports.ModeInfo.fromPartial(object.modeInfo) : undefined;
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            publicKey: object.public_key ? any_1.Any.fromSDK(object.public_key) : undefined,
	            modeInfo: object.mode_info ? exports.ModeInfo.fromSDK(object.mode_info) : undefined,
	            sequence: object?.sequence
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.publicKey !== undefined && (obj.public_key = message.publicKey ? any_1.Any.toSDK(message.publicKey) : undefined);
	        message.modeInfo !== undefined && (obj.mode_info = message.modeInfo ? exports.ModeInfo.toSDK(message.modeInfo) : undefined);
	        obj.sequence = message.sequence;
	        return obj;
	    }
	};
	function createBaseModeInfo() {
	    return {
	        single: undefined,
	        multi: undefined
	    };
	}
	exports.ModeInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.single !== undefined) {
	            exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.multi !== undefined) {
	            exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseModeInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            single: (0, helpers_1.isSet)(object.single) ? exports.ModeInfo_Single.fromJSON(object.single) : undefined,
	            multi: (0, helpers_1.isSet)(object.multi) ? exports.ModeInfo_Multi.fromJSON(object.multi) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.single !== undefined && (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : undefined);
	        message.multi !== undefined && (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseModeInfo();
	        message.single = object.single !== undefined && object.single !== null ? exports.ModeInfo_Single.fromPartial(object.single) : undefined;
	        message.multi = object.multi !== undefined && object.multi !== null ? exports.ModeInfo_Multi.fromPartial(object.multi) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            single: object.single ? exports.ModeInfo_Single.fromSDK(object.single) : undefined,
	            multi: object.multi ? exports.ModeInfo_Multi.fromSDK(object.multi) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.single !== undefined && (obj.single = message.single ? exports.ModeInfo_Single.toSDK(message.single) : undefined);
	        message.multi !== undefined && (obj.multi = message.multi ? exports.ModeInfo_Multi.toSDK(message.multi) : undefined);
	        return obj;
	    }
	};
	function createBaseModeInfo_Single() {
	    return {
	        mode: 0
	    };
	}
	exports.ModeInfo_Single = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.mode !== 0) {
	            writer.uint32(8).int32(message.mode);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseModeInfo_Single();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.mode = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            mode: (0, helpers_1.isSet)(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseModeInfo_Single();
	        message.mode = object.mode ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            mode: (0, helpers_1.isSet)(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
	        return obj;
	    }
	};
	function createBaseModeInfo_Multi() {
	    return {
	        bitarray: undefined,
	        modeInfos: []
	    };
	}
	exports.ModeInfo_Multi = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bitarray !== undefined) {
	            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
	        }
	        for (const v of message.modeInfos) {
	            exports.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseModeInfo_Multi();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bitarray: (0, helpers_1.isSet)(object.bitarray) ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : undefined,
	            modeInfos: Array.isArray(object?.modeInfos) ? object.modeInfos.map((e) => exports.ModeInfo.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);
	        if (message.modeInfos) {
	            obj.modeInfos = message.modeInfos.map(e => e ? exports.ModeInfo.toJSON(e) : undefined);
	        }
	        else {
	            obj.modeInfos = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseModeInfo_Multi();
	        message.bitarray = object.bitarray !== undefined && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : undefined;
	        message.modeInfos = object.modeInfos?.map(e => exports.ModeInfo.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bitarray: object.bitarray ? multisig_1.CompactBitArray.fromSDK(object.bitarray) : undefined,
	            modeInfos: Array.isArray(object?.mode_infos) ? object.mode_infos.map((e) => exports.ModeInfo.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toSDK(message.bitarray) : undefined);
	        if (message.modeInfos) {
	            obj.mode_infos = message.modeInfos.map(e => e ? exports.ModeInfo.toSDK(e) : undefined);
	        }
	        else {
	            obj.mode_infos = [];
	        }
	        return obj;
	    }
	};
	function createBaseFee() {
	    return {
	        amount: [],
	        gasLimit: helpers_1.Long.UZERO,
	        payer: "",
	        granter: ""
	    };
	}
	exports.Fee = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (!message.gasLimit.isZero()) {
	            writer.uint32(16).uint64(message.gasLimit);
	        }
	        if (message.payer !== "") {
	            writer.uint32(26).string(message.payer);
	        }
	        if (message.granter !== "") {
	            writer.uint32(34).string(message.granter);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseFee();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.gasLimit = reader.uint64();
	                    break;
	                case 3:
	                    message.payer = reader.string();
	                    break;
	                case 4:
	                    message.granter = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
	            gasLimit: (0, helpers_1.isSet)(object.gasLimit) ? helpers_1.Long.fromValue(object.gasLimit) : helpers_1.Long.UZERO,
	            payer: (0, helpers_1.isSet)(object.payer) ? String(object.payer) : "",
	            granter: (0, helpers_1.isSet)(object.granter) ? String(object.granter) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        message.gasLimit !== undefined && (obj.gasLimit = (message.gasLimit || helpers_1.Long.UZERO).toString());
	        message.payer !== undefined && (obj.payer = message.payer);
	        message.granter !== undefined && (obj.granter = message.granter);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseFee();
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        message.gasLimit = object.gasLimit !== undefined && object.gasLimit !== null ? helpers_1.Long.fromValue(object.gasLimit) : helpers_1.Long.UZERO;
	        message.payer = object.payer ?? "";
	        message.granter = object.granter ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : [],
	            gasLimit: object?.gas_limit,
	            payer: object?.payer,
	            granter: object?.granter
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        obj.gas_limit = message.gasLimit;
	        obj.payer = message.payer;
	        obj.granter = message.granter;
	        return obj;
	    }
	};
	function createBaseTip() {
	    return {
	        amount: [],
	        tipper: ""
	    };
	}
	exports.Tip = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.tipper !== "") {
	            writer.uint32(18).string(message.tipper);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTip();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.tipper = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
	            tipper: (0, helpers_1.isSet)(object.tipper) ? String(object.tipper) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        message.tipper !== undefined && (obj.tipper = message.tipper);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTip();
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        message.tipper = object.tipper ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : [],
	            tipper: object?.tipper
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        obj.tipper = message.tipper;
	        return obj;
	    }
	};
	function createBaseAuxSignerData() {
	    return {
	        address: "",
	        signDoc: undefined,
	        mode: 0,
	        sig: new Uint8Array()
	    };
	}
	exports.AuxSignerData = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.signDoc !== undefined) {
	            exports.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.mode !== 0) {
	            writer.uint32(24).int32(message.mode);
	        }
	        if (message.sig.length !== 0) {
	            writer.uint32(34).bytes(message.sig);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAuxSignerData();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.signDoc = exports.SignDocDirectAux.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.mode = reader.int32();
	                    break;
	                case 4:
	                    message.sig = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            signDoc: (0, helpers_1.isSet)(object.signDoc) ? exports.SignDocDirectAux.fromJSON(object.signDoc) : undefined,
	            mode: (0, helpers_1.isSet)(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0,
	            sig: (0, helpers_1.isSet)(object.sig) ? (0, helpers_1.bytesFromBase64)(object.sig) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.signDoc !== undefined && (obj.signDoc = message.signDoc ? exports.SignDocDirectAux.toJSON(message.signDoc) : undefined);
	        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
	        message.sig !== undefined && (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== undefined ? message.sig : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAuxSignerData();
	        message.address = object.address ?? "";
	        message.signDoc = object.signDoc !== undefined && object.signDoc !== null ? exports.SignDocDirectAux.fromPartial(object.signDoc) : undefined;
	        message.mode = object.mode ?? 0;
	        message.sig = object.sig ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            signDoc: object.sign_doc ? exports.SignDocDirectAux.fromSDK(object.sign_doc) : undefined,
	            mode: (0, helpers_1.isSet)(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0,
	            sig: object?.sig
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.signDoc !== undefined && (obj.sign_doc = message.signDoc ? exports.SignDocDirectAux.toSDK(message.signDoc) : undefined);
	        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
	        obj.sig = message.sig;
	        return obj;
	    }
	};
	
} (tx$6));

tx$6.default;

var abci = {};

var types$5 = {};

var params$4 = {};

var duration = {};

var __createBinding$7 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$7 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$7 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$7(result, mod, k);
    __setModuleDefault$7(result, mod);
    return result;
};
Object.defineProperty(duration, "__esModule", { value: true });
duration.Duration = duration.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$7 = helpers;
const _m0$7 = __importStar$7(minimal$1.exports);
duration.protobufPackage = "google.protobuf";
function createBaseDuration() {
    return {
        seconds: helpers_1$7.Long.ZERO,
        nanos: 0
    };
}
duration.Duration = {
    encode(message, writer = _m0$7.Writer.create()) {
        if (!message.seconds.isZero()) {
            writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
            writer.uint32(16).int32(message.nanos);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$7.Reader ? input : new _m0$7.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.int64();
                    break;
                case 2:
                    message.nanos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            seconds: (0, helpers_1$7.isSet)(object.seconds) ? helpers_1$7.Long.fromValue(object.seconds) : helpers_1$7.Long.ZERO,
            nanos: (0, helpers_1$7.isSet)(object.nanos) ? Number(object.nanos) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.seconds !== undefined && (obj.seconds = (message.seconds || helpers_1$7.Long.ZERO).toString());
        message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDuration();
        message.seconds = object.seconds !== undefined && object.seconds !== null ? helpers_1$7.Long.fromValue(object.seconds) : helpers_1$7.Long.ZERO;
        message.nanos = object.nanos ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            seconds: object?.seconds,
            nanos: object?.nanos
        };
    },
    toSDK(message) {
        const obj = {};
        obj.seconds = message.seconds;
        obj.nanos = message.nanos;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HashedParams = exports.VersionParams = exports.ValidatorParams = exports.EvidenceParams = exports.BlockParams = exports.ConsensusParams = exports.protobufPackage = void 0;
	/* eslint-disable */
	const duration_1 = duration;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "tendermint.types";
	function createBaseConsensusParams() {
	    return {
	        block: undefined,
	        evidence: undefined,
	        validator: undefined,
	        version: undefined
	    };
	}
	exports.ConsensusParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.block !== undefined) {
	            exports.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.evidence !== undefined) {
	            exports.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.validator !== undefined) {
	            exports.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.version !== undefined) {
	            exports.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseConsensusParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.block = exports.BlockParams.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.evidence = exports.EvidenceParams.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.validator = exports.ValidatorParams.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.version = exports.VersionParams.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            block: (0, helpers_1.isSet)(object.block) ? exports.BlockParams.fromJSON(object.block) : undefined,
	            evidence: (0, helpers_1.isSet)(object.evidence) ? exports.EvidenceParams.fromJSON(object.evidence) : undefined,
	            validator: (0, helpers_1.isSet)(object.validator) ? exports.ValidatorParams.fromJSON(object.validator) : undefined,
	            version: (0, helpers_1.isSet)(object.version) ? exports.VersionParams.fromJSON(object.version) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.block !== undefined && (obj.block = message.block ? exports.BlockParams.toJSON(message.block) : undefined);
	        message.evidence !== undefined && (obj.evidence = message.evidence ? exports.EvidenceParams.toJSON(message.evidence) : undefined);
	        message.validator !== undefined && (obj.validator = message.validator ? exports.ValidatorParams.toJSON(message.validator) : undefined);
	        message.version !== undefined && (obj.version = message.version ? exports.VersionParams.toJSON(message.version) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseConsensusParams();
	        message.block = object.block !== undefined && object.block !== null ? exports.BlockParams.fromPartial(object.block) : undefined;
	        message.evidence = object.evidence !== undefined && object.evidence !== null ? exports.EvidenceParams.fromPartial(object.evidence) : undefined;
	        message.validator = object.validator !== undefined && object.validator !== null ? exports.ValidatorParams.fromPartial(object.validator) : undefined;
	        message.version = object.version !== undefined && object.version !== null ? exports.VersionParams.fromPartial(object.version) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            block: object.block ? exports.BlockParams.fromSDK(object.block) : undefined,
	            evidence: object.evidence ? exports.EvidenceParams.fromSDK(object.evidence) : undefined,
	            validator: object.validator ? exports.ValidatorParams.fromSDK(object.validator) : undefined,
	            version: object.version ? exports.VersionParams.fromSDK(object.version) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.block !== undefined && (obj.block = message.block ? exports.BlockParams.toSDK(message.block) : undefined);
	        message.evidence !== undefined && (obj.evidence = message.evidence ? exports.EvidenceParams.toSDK(message.evidence) : undefined);
	        message.validator !== undefined && (obj.validator = message.validator ? exports.ValidatorParams.toSDK(message.validator) : undefined);
	        message.version !== undefined && (obj.version = message.version ? exports.VersionParams.toSDK(message.version) : undefined);
	        return obj;
	    }
	};
	function createBaseBlockParams() {
	    return {
	        maxBytes: helpers_1.Long.ZERO,
	        maxGas: helpers_1.Long.ZERO
	    };
	}
	exports.BlockParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.maxBytes.isZero()) {
	            writer.uint32(8).int64(message.maxBytes);
	        }
	        if (!message.maxGas.isZero()) {
	            writer.uint32(16).int64(message.maxGas);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBlockParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.maxBytes = reader.int64();
	                    break;
	                case 2:
	                    message.maxGas = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            maxBytes: (0, helpers_1.isSet)(object.maxBytes) ? helpers_1.Long.fromValue(object.maxBytes) : helpers_1.Long.ZERO,
	            maxGas: (0, helpers_1.isSet)(object.maxGas) ? helpers_1.Long.fromValue(object.maxGas) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.maxBytes !== undefined && (obj.maxBytes = (message.maxBytes || helpers_1.Long.ZERO).toString());
	        message.maxGas !== undefined && (obj.maxGas = (message.maxGas || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBlockParams();
	        message.maxBytes = object.maxBytes !== undefined && object.maxBytes !== null ? helpers_1.Long.fromValue(object.maxBytes) : helpers_1.Long.ZERO;
	        message.maxGas = object.maxGas !== undefined && object.maxGas !== null ? helpers_1.Long.fromValue(object.maxGas) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            maxBytes: object?.max_bytes,
	            maxGas: object?.max_gas
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.max_bytes = message.maxBytes;
	        obj.max_gas = message.maxGas;
	        return obj;
	    }
	};
	function createBaseEvidenceParams() {
	    return {
	        maxAgeNumBlocks: helpers_1.Long.ZERO,
	        maxAgeDuration: undefined,
	        maxBytes: helpers_1.Long.ZERO
	    };
	}
	exports.EvidenceParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.maxAgeNumBlocks.isZero()) {
	            writer.uint32(8).int64(message.maxAgeNumBlocks);
	        }
	        if (message.maxAgeDuration !== undefined) {
	            duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.maxBytes.isZero()) {
	            writer.uint32(24).int64(message.maxBytes);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseEvidenceParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.maxAgeNumBlocks = reader.int64();
	                    break;
	                case 2:
	                    message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.maxBytes = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            maxAgeNumBlocks: (0, helpers_1.isSet)(object.maxAgeNumBlocks) ? helpers_1.Long.fromValue(object.maxAgeNumBlocks) : helpers_1.Long.ZERO,
	            maxAgeDuration: (0, helpers_1.isSet)(object.maxAgeDuration) ? duration_1.Duration.fromJSON(object.maxAgeDuration) : undefined,
	            maxBytes: (0, helpers_1.isSet)(object.maxBytes) ? helpers_1.Long.fromValue(object.maxBytes) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.maxAgeNumBlocks !== undefined && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || helpers_1.Long.ZERO).toString());
	        message.maxAgeDuration !== undefined && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : undefined);
	        message.maxBytes !== undefined && (obj.maxBytes = (message.maxBytes || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseEvidenceParams();
	        message.maxAgeNumBlocks = object.maxAgeNumBlocks !== undefined && object.maxAgeNumBlocks !== null ? helpers_1.Long.fromValue(object.maxAgeNumBlocks) : helpers_1.Long.ZERO;
	        message.maxAgeDuration = object.maxAgeDuration !== undefined && object.maxAgeDuration !== null ? duration_1.Duration.fromPartial(object.maxAgeDuration) : undefined;
	        message.maxBytes = object.maxBytes !== undefined && object.maxBytes !== null ? helpers_1.Long.fromValue(object.maxBytes) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            maxAgeNumBlocks: object?.max_age_num_blocks,
	            maxAgeDuration: object.max_age_duration ? duration_1.Duration.fromSDK(object.max_age_duration) : undefined,
	            maxBytes: object?.max_bytes
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.max_age_num_blocks = message.maxAgeNumBlocks;
	        message.maxAgeDuration !== undefined && (obj.max_age_duration = message.maxAgeDuration ? duration_1.Duration.toSDK(message.maxAgeDuration) : undefined);
	        obj.max_bytes = message.maxBytes;
	        return obj;
	    }
	};
	function createBaseValidatorParams() {
	    return {
	        pubKeyTypes: []
	    };
	}
	exports.ValidatorParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.pubKeyTypes) {
	            writer.uint32(10).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pubKeyTypes.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pubKeyTypes: Array.isArray(object?.pubKeyTypes) ? object.pubKeyTypes.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.pubKeyTypes) {
	            obj.pubKeyTypes = message.pubKeyTypes.map(e => e);
	        }
	        else {
	            obj.pubKeyTypes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorParams();
	        message.pubKeyTypes = object.pubKeyTypes?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pubKeyTypes: Array.isArray(object?.pub_key_types) ? object.pub_key_types.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.pubKeyTypes) {
	            obj.pub_key_types = message.pubKeyTypes.map(e => e);
	        }
	        else {
	            obj.pub_key_types = [];
	        }
	        return obj;
	    }
	};
	function createBaseVersionParams() {
	    return {
	        app: helpers_1.Long.UZERO
	    };
	}
	exports.VersionParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.app.isZero()) {
	            writer.uint32(8).uint64(message.app);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseVersionParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.app = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            app: (0, helpers_1.isSet)(object.app) ? helpers_1.Long.fromValue(object.app) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.app !== undefined && (obj.app = (message.app || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseVersionParams();
	        message.app = object.app !== undefined && object.app !== null ? helpers_1.Long.fromValue(object.app) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            app: object?.app
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.app = message.app;
	        return obj;
	    }
	};
	function createBaseHashedParams() {
	    return {
	        blockMaxBytes: helpers_1.Long.ZERO,
	        blockMaxGas: helpers_1.Long.ZERO
	    };
	}
	exports.HashedParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.blockMaxBytes.isZero()) {
	            writer.uint32(8).int64(message.blockMaxBytes);
	        }
	        if (!message.blockMaxGas.isZero()) {
	            writer.uint32(16).int64(message.blockMaxGas);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseHashedParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blockMaxBytes = reader.int64();
	                    break;
	                case 2:
	                    message.blockMaxGas = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blockMaxBytes: (0, helpers_1.isSet)(object.blockMaxBytes) ? helpers_1.Long.fromValue(object.blockMaxBytes) : helpers_1.Long.ZERO,
	            blockMaxGas: (0, helpers_1.isSet)(object.blockMaxGas) ? helpers_1.Long.fromValue(object.blockMaxGas) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blockMaxBytes !== undefined && (obj.blockMaxBytes = (message.blockMaxBytes || helpers_1.Long.ZERO).toString());
	        message.blockMaxGas !== undefined && (obj.blockMaxGas = (message.blockMaxGas || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseHashedParams();
	        message.blockMaxBytes = object.blockMaxBytes !== undefined && object.blockMaxBytes !== null ? helpers_1.Long.fromValue(object.blockMaxBytes) : helpers_1.Long.ZERO;
	        message.blockMaxGas = object.blockMaxGas !== undefined && object.blockMaxGas !== null ? helpers_1.Long.fromValue(object.blockMaxGas) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blockMaxBytes: object?.block_max_bytes,
	            blockMaxGas: object?.block_max_gas
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.block_max_bytes = message.blockMaxBytes;
	        obj.block_max_gas = message.blockMaxGas;
	        return obj;
	    }
	};
	
} (params$4));

params$4.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ResponseEndBlock = exports.ResponseDeliverTx = exports.ResponseCheckTx = exports.ResponseBeginBlock = exports.ResponseQuery = exports.ResponseInitChain = exports.ResponseInfo = exports.ResponseFlush = exports.ResponseEcho = exports.ResponseException = exports.Response = exports.RequestEthQuery = exports.RequestProcessProposal = exports.RequestPrepareProposal = exports.RequestApplySnapshotChunk = exports.RequestLoadSnapshotChunk = exports.RequestOfferSnapshot = exports.RequestListSnapshots = exports.RequestCommit = exports.RequestEndBlock = exports.RequestDeliverTx = exports.RequestCheckTx = exports.RequestBeginBlock = exports.RequestQuery = exports.RequestInitChain = exports.RequestInfo = exports.RequestFlush = exports.RequestEcho = exports.Request = exports.misbehaviorTypeToJSON = exports.misbehaviorTypeFromJSON = exports.MisbehaviorTypeSDKType = exports.MisbehaviorType = exports.responseProcessProposal_ProposalStatusToJSON = exports.responseProcessProposal_ProposalStatusFromJSON = exports.ResponseProcessProposal_ProposalStatusSDKType = exports.ResponseProcessProposal_ProposalStatus = exports.responseApplySnapshotChunk_ResultToJSON = exports.responseApplySnapshotChunk_ResultFromJSON = exports.ResponseApplySnapshotChunk_ResultSDKType = exports.ResponseApplySnapshotChunk_Result = exports.responseOfferSnapshot_ResultToJSON = exports.responseOfferSnapshot_ResultFromJSON = exports.ResponseOfferSnapshot_ResultSDKType = exports.ResponseOfferSnapshot_Result = exports.checkTxTypeToJSON = exports.checkTxTypeFromJSON = exports.CheckTxTypeSDKType = exports.CheckTxType = exports.protobufPackage = void 0;
	exports.ABCIApplicationClientImpl = exports.Snapshot = exports.Misbehavior = exports.ExtendedVoteInfo = exports.VoteInfo = exports.ValidatorUpdate = exports.Validator = exports.TxResult = exports.EventAttribute = exports.Event = exports.ExtendedCommitInfo = exports.CommitInfo = exports.ResponseEthQuery = exports.ResponseProcessProposal = exports.ResponsePrepareProposal = exports.ResponseApplySnapshotChunk = exports.ResponseLoadSnapshotChunk = exports.ResponseOfferSnapshot = exports.ResponseListSnapshots = exports.ResponseCommit = void 0;
	/* eslint-disable */
	const timestamp_1 = timestamp;
	const params_1 = params$4;
	const types_1 = types$9;
	const proof_1 = proof;
	const keys_1 = keys$1;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "tendermint.abci";
	var CheckTxType;
	(function (CheckTxType) {
	    CheckTxType[CheckTxType["NEW"] = 0] = "NEW";
	    CheckTxType[CheckTxType["RECHECK"] = 1] = "RECHECK";
	    CheckTxType[CheckTxType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(CheckTxType = exports.CheckTxType || (exports.CheckTxType = {}));
	exports.CheckTxTypeSDKType = CheckTxType;
	function checkTxTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "NEW":
	            return CheckTxType.NEW;
	        case 1:
	        case "RECHECK":
	            return CheckTxType.RECHECK;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return CheckTxType.UNRECOGNIZED;
	    }
	}
	exports.checkTxTypeFromJSON = checkTxTypeFromJSON;
	function checkTxTypeToJSON(object) {
	    switch (object) {
	        case CheckTxType.NEW:
	            return "NEW";
	        case CheckTxType.RECHECK:
	            return "RECHECK";
	        case CheckTxType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.checkTxTypeToJSON = checkTxTypeToJSON;
	var ResponseOfferSnapshot_Result;
	(function (ResponseOfferSnapshot_Result) {
	    /** UNKNOWN - Unknown result, abort all snapshot restoration */
	    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["UNKNOWN"] = 0] = "UNKNOWN";
	    /** ACCEPT - Snapshot accepted, apply chunks */
	    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ACCEPT"] = 1] = "ACCEPT";
	    /** ABORT - Abort all snapshot restoration */
	    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ABORT"] = 2] = "ABORT";
	    /** REJECT - Reject this specific snapshot, try others */
	    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT"] = 3] = "REJECT";
	    /** REJECT_FORMAT - Reject all snapshots of this format, try others */
	    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
	    /** REJECT_SENDER - Reject all snapshots from the sender(s), try others */
	    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_SENDER"] = 5] = "REJECT_SENDER";
	    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(ResponseOfferSnapshot_Result = exports.ResponseOfferSnapshot_Result || (exports.ResponseOfferSnapshot_Result = {}));
	exports.ResponseOfferSnapshot_ResultSDKType = ResponseOfferSnapshot_Result;
	function responseOfferSnapshot_ResultFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "UNKNOWN":
	            return ResponseOfferSnapshot_Result.UNKNOWN;
	        case 1:
	        case "ACCEPT":
	            return ResponseOfferSnapshot_Result.ACCEPT;
	        case 2:
	        case "ABORT":
	            return ResponseOfferSnapshot_Result.ABORT;
	        case 3:
	        case "REJECT":
	            return ResponseOfferSnapshot_Result.REJECT;
	        case 4:
	        case "REJECT_FORMAT":
	            return ResponseOfferSnapshot_Result.REJECT_FORMAT;
	        case 5:
	        case "REJECT_SENDER":
	            return ResponseOfferSnapshot_Result.REJECT_SENDER;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return ResponseOfferSnapshot_Result.UNRECOGNIZED;
	    }
	}
	exports.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;
	function responseOfferSnapshot_ResultToJSON(object) {
	    switch (object) {
	        case ResponseOfferSnapshot_Result.UNKNOWN:
	            return "UNKNOWN";
	        case ResponseOfferSnapshot_Result.ACCEPT:
	            return "ACCEPT";
	        case ResponseOfferSnapshot_Result.ABORT:
	            return "ABORT";
	        case ResponseOfferSnapshot_Result.REJECT:
	            return "REJECT";
	        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
	            return "REJECT_FORMAT";
	        case ResponseOfferSnapshot_Result.REJECT_SENDER:
	            return "REJECT_SENDER";
	        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;
	var ResponseApplySnapshotChunk_Result;
	(function (ResponseApplySnapshotChunk_Result) {
	    /** UNKNOWN - Unknown result, abort all snapshot restoration */
	    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["UNKNOWN"] = 0] = "UNKNOWN";
	    /** ACCEPT - Chunk successfully accepted */
	    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ACCEPT"] = 1] = "ACCEPT";
	    /** ABORT - Abort all snapshot restoration */
	    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ABORT"] = 2] = "ABORT";
	    /** RETRY - Retry chunk (combine with refetch and reject) */
	    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY"] = 3] = "RETRY";
	    /** RETRY_SNAPSHOT - Retry snapshot (combine with refetch and reject) */
	    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
	    /** REJECT_SNAPSHOT - Reject this snapshot, try others */
	    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
	    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(ResponseApplySnapshotChunk_Result = exports.ResponseApplySnapshotChunk_Result || (exports.ResponseApplySnapshotChunk_Result = {}));
	exports.ResponseApplySnapshotChunk_ResultSDKType = ResponseApplySnapshotChunk_Result;
	function responseApplySnapshotChunk_ResultFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "UNKNOWN":
	            return ResponseApplySnapshotChunk_Result.UNKNOWN;
	        case 1:
	        case "ACCEPT":
	            return ResponseApplySnapshotChunk_Result.ACCEPT;
	        case 2:
	        case "ABORT":
	            return ResponseApplySnapshotChunk_Result.ABORT;
	        case 3:
	        case "RETRY":
	            return ResponseApplySnapshotChunk_Result.RETRY;
	        case 4:
	        case "RETRY_SNAPSHOT":
	            return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
	        case 5:
	        case "REJECT_SNAPSHOT":
	            return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
	    }
	}
	exports.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;
	function responseApplySnapshotChunk_ResultToJSON(object) {
	    switch (object) {
	        case ResponseApplySnapshotChunk_Result.UNKNOWN:
	            return "UNKNOWN";
	        case ResponseApplySnapshotChunk_Result.ACCEPT:
	            return "ACCEPT";
	        case ResponseApplySnapshotChunk_Result.ABORT:
	            return "ABORT";
	        case ResponseApplySnapshotChunk_Result.RETRY:
	            return "RETRY";
	        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
	            return "RETRY_SNAPSHOT";
	        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
	            return "REJECT_SNAPSHOT";
	        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;
	var ResponseProcessProposal_ProposalStatus;
	(function (ResponseProcessProposal_ProposalStatus) {
	    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["UNKNOWN"] = 0] = "UNKNOWN";
	    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["ACCEPT"] = 1] = "ACCEPT";
	    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["REJECT"] = 2] = "REJECT";
	    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(ResponseProcessProposal_ProposalStatus = exports.ResponseProcessProposal_ProposalStatus || (exports.ResponseProcessProposal_ProposalStatus = {}));
	exports.ResponseProcessProposal_ProposalStatusSDKType = ResponseProcessProposal_ProposalStatus;
	function responseProcessProposal_ProposalStatusFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "UNKNOWN":
	            return ResponseProcessProposal_ProposalStatus.UNKNOWN;
	        case 1:
	        case "ACCEPT":
	            return ResponseProcessProposal_ProposalStatus.ACCEPT;
	        case 2:
	        case "REJECT":
	            return ResponseProcessProposal_ProposalStatus.REJECT;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return ResponseProcessProposal_ProposalStatus.UNRECOGNIZED;
	    }
	}
	exports.responseProcessProposal_ProposalStatusFromJSON = responseProcessProposal_ProposalStatusFromJSON;
	function responseProcessProposal_ProposalStatusToJSON(object) {
	    switch (object) {
	        case ResponseProcessProposal_ProposalStatus.UNKNOWN:
	            return "UNKNOWN";
	        case ResponseProcessProposal_ProposalStatus.ACCEPT:
	            return "ACCEPT";
	        case ResponseProcessProposal_ProposalStatus.REJECT:
	            return "REJECT";
	        case ResponseProcessProposal_ProposalStatus.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.responseProcessProposal_ProposalStatusToJSON = responseProcessProposal_ProposalStatusToJSON;
	var MisbehaviorType;
	(function (MisbehaviorType) {
	    MisbehaviorType[MisbehaviorType["UNKNOWN"] = 0] = "UNKNOWN";
	    MisbehaviorType[MisbehaviorType["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
	    MisbehaviorType[MisbehaviorType["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
	    MisbehaviorType[MisbehaviorType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(MisbehaviorType = exports.MisbehaviorType || (exports.MisbehaviorType = {}));
	exports.MisbehaviorTypeSDKType = MisbehaviorType;
	function misbehaviorTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "UNKNOWN":
	            return MisbehaviorType.UNKNOWN;
	        case 1:
	        case "DUPLICATE_VOTE":
	            return MisbehaviorType.DUPLICATE_VOTE;
	        case 2:
	        case "LIGHT_CLIENT_ATTACK":
	            return MisbehaviorType.LIGHT_CLIENT_ATTACK;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return MisbehaviorType.UNRECOGNIZED;
	    }
	}
	exports.misbehaviorTypeFromJSON = misbehaviorTypeFromJSON;
	function misbehaviorTypeToJSON(object) {
	    switch (object) {
	        case MisbehaviorType.UNKNOWN:
	            return "UNKNOWN";
	        case MisbehaviorType.DUPLICATE_VOTE:
	            return "DUPLICATE_VOTE";
	        case MisbehaviorType.LIGHT_CLIENT_ATTACK:
	            return "LIGHT_CLIENT_ATTACK";
	        case MisbehaviorType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.misbehaviorTypeToJSON = misbehaviorTypeToJSON;
	function createBaseRequest() {
	    return {
	        echo: undefined,
	        flush: undefined,
	        info: undefined,
	        initChain: undefined,
	        query: undefined,
	        beginBlock: undefined,
	        checkTx: undefined,
	        deliverTx: undefined,
	        endBlock: undefined,
	        commit: undefined,
	        listSnapshots: undefined,
	        offerSnapshot: undefined,
	        loadSnapshotChunk: undefined,
	        applySnapshotChunk: undefined,
	        prepareProposal: undefined,
	        processProposal: undefined,
	        ethQuery: undefined
	    };
	}
	exports.Request = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.echo !== undefined) {
	            exports.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.flush !== undefined) {
	            exports.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.info !== undefined) {
	            exports.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.initChain !== undefined) {
	            exports.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
	        }
	        if (message.query !== undefined) {
	            exports.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
	        }
	        if (message.beginBlock !== undefined) {
	            exports.RequestBeginBlock.encode(message.beginBlock, writer.uint32(58).fork()).ldelim();
	        }
	        if (message.checkTx !== undefined) {
	            exports.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
	        }
	        if (message.deliverTx !== undefined) {
	            exports.RequestDeliverTx.encode(message.deliverTx, writer.uint32(74).fork()).ldelim();
	        }
	        if (message.endBlock !== undefined) {
	            exports.RequestEndBlock.encode(message.endBlock, writer.uint32(82).fork()).ldelim();
	        }
	        if (message.commit !== undefined) {
	            exports.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
	        }
	        if (message.listSnapshots !== undefined) {
	            exports.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
	        }
	        if (message.offerSnapshot !== undefined) {
	            exports.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
	        }
	        if (message.loadSnapshotChunk !== undefined) {
	            exports.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
	        }
	        if (message.applySnapshotChunk !== undefined) {
	            exports.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
	        }
	        if (message.prepareProposal !== undefined) {
	            exports.RequestPrepareProposal.encode(message.prepareProposal, writer.uint32(130).fork()).ldelim();
	        }
	        if (message.processProposal !== undefined) {
	            exports.RequestProcessProposal.encode(message.processProposal, writer.uint32(138).fork()).ldelim();
	        }
	        if (message.ethQuery !== undefined) {
	            exports.RequestEthQuery.encode(message.ethQuery, writer.uint32(146).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.echo = exports.RequestEcho.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.flush = exports.RequestFlush.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.info = exports.RequestInfo.decode(reader, reader.uint32());
	                    break;
	                case 5:
	                    message.initChain = exports.RequestInitChain.decode(reader, reader.uint32());
	                    break;
	                case 6:
	                    message.query = exports.RequestQuery.decode(reader, reader.uint32());
	                    break;
	                case 7:
	                    message.beginBlock = exports.RequestBeginBlock.decode(reader, reader.uint32());
	                    break;
	                case 8:
	                    message.checkTx = exports.RequestCheckTx.decode(reader, reader.uint32());
	                    break;
	                case 9:
	                    message.deliverTx = exports.RequestDeliverTx.decode(reader, reader.uint32());
	                    break;
	                case 10:
	                    message.endBlock = exports.RequestEndBlock.decode(reader, reader.uint32());
	                    break;
	                case 11:
	                    message.commit = exports.RequestCommit.decode(reader, reader.uint32());
	                    break;
	                case 12:
	                    message.listSnapshots = exports.RequestListSnapshots.decode(reader, reader.uint32());
	                    break;
	                case 13:
	                    message.offerSnapshot = exports.RequestOfferSnapshot.decode(reader, reader.uint32());
	                    break;
	                case 14:
	                    message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
	                    break;
	                case 15:
	                    message.applySnapshotChunk = exports.RequestApplySnapshotChunk.decode(reader, reader.uint32());
	                    break;
	                case 16:
	                    message.prepareProposal = exports.RequestPrepareProposal.decode(reader, reader.uint32());
	                    break;
	                case 17:
	                    message.processProposal = exports.RequestProcessProposal.decode(reader, reader.uint32());
	                    break;
	                case 18:
	                    message.ethQuery = exports.RequestEthQuery.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            echo: (0, helpers_1.isSet)(object.echo) ? exports.RequestEcho.fromJSON(object.echo) : undefined,
	            flush: (0, helpers_1.isSet)(object.flush) ? exports.RequestFlush.fromJSON(object.flush) : undefined,
	            info: (0, helpers_1.isSet)(object.info) ? exports.RequestInfo.fromJSON(object.info) : undefined,
	            initChain: (0, helpers_1.isSet)(object.initChain) ? exports.RequestInitChain.fromJSON(object.initChain) : undefined,
	            query: (0, helpers_1.isSet)(object.query) ? exports.RequestQuery.fromJSON(object.query) : undefined,
	            beginBlock: (0, helpers_1.isSet)(object.beginBlock) ? exports.RequestBeginBlock.fromJSON(object.beginBlock) : undefined,
	            checkTx: (0, helpers_1.isSet)(object.checkTx) ? exports.RequestCheckTx.fromJSON(object.checkTx) : undefined,
	            deliverTx: (0, helpers_1.isSet)(object.deliverTx) ? exports.RequestDeliverTx.fromJSON(object.deliverTx) : undefined,
	            endBlock: (0, helpers_1.isSet)(object.endBlock) ? exports.RequestEndBlock.fromJSON(object.endBlock) : undefined,
	            commit: (0, helpers_1.isSet)(object.commit) ? exports.RequestCommit.fromJSON(object.commit) : undefined,
	            listSnapshots: (0, helpers_1.isSet)(object.listSnapshots) ? exports.RequestListSnapshots.fromJSON(object.listSnapshots) : undefined,
	            offerSnapshot: (0, helpers_1.isSet)(object.offerSnapshot) ? exports.RequestOfferSnapshot.fromJSON(object.offerSnapshot) : undefined,
	            loadSnapshotChunk: (0, helpers_1.isSet)(object.loadSnapshotChunk) ? exports.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk) : undefined,
	            applySnapshotChunk: (0, helpers_1.isSet)(object.applySnapshotChunk) ? exports.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk) : undefined,
	            prepareProposal: (0, helpers_1.isSet)(object.prepareProposal) ? exports.RequestPrepareProposal.fromJSON(object.prepareProposal) : undefined,
	            processProposal: (0, helpers_1.isSet)(object.processProposal) ? exports.RequestProcessProposal.fromJSON(object.processProposal) : undefined,
	            ethQuery: (0, helpers_1.isSet)(object.ethQuery) ? exports.RequestEthQuery.fromJSON(object.ethQuery) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.echo !== undefined && (obj.echo = message.echo ? exports.RequestEcho.toJSON(message.echo) : undefined);
	        message.flush !== undefined && (obj.flush = message.flush ? exports.RequestFlush.toJSON(message.flush) : undefined);
	        message.info !== undefined && (obj.info = message.info ? exports.RequestInfo.toJSON(message.info) : undefined);
	        message.initChain !== undefined && (obj.initChain = message.initChain ? exports.RequestInitChain.toJSON(message.initChain) : undefined);
	        message.query !== undefined && (obj.query = message.query ? exports.RequestQuery.toJSON(message.query) : undefined);
	        message.beginBlock !== undefined && (obj.beginBlock = message.beginBlock ? exports.RequestBeginBlock.toJSON(message.beginBlock) : undefined);
	        message.checkTx !== undefined && (obj.checkTx = message.checkTx ? exports.RequestCheckTx.toJSON(message.checkTx) : undefined);
	        message.deliverTx !== undefined && (obj.deliverTx = message.deliverTx ? exports.RequestDeliverTx.toJSON(message.deliverTx) : undefined);
	        message.endBlock !== undefined && (obj.endBlock = message.endBlock ? exports.RequestEndBlock.toJSON(message.endBlock) : undefined);
	        message.commit !== undefined && (obj.commit = message.commit ? exports.RequestCommit.toJSON(message.commit) : undefined);
	        message.listSnapshots !== undefined && (obj.listSnapshots = message.listSnapshots ? exports.RequestListSnapshots.toJSON(message.listSnapshots) : undefined);
	        message.offerSnapshot !== undefined && (obj.offerSnapshot = message.offerSnapshot ? exports.RequestOfferSnapshot.toJSON(message.offerSnapshot) : undefined);
	        message.loadSnapshotChunk !== undefined && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : undefined);
	        message.applySnapshotChunk !== undefined && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : undefined);
	        message.prepareProposal !== undefined && (obj.prepareProposal = message.prepareProposal ? exports.RequestPrepareProposal.toJSON(message.prepareProposal) : undefined);
	        message.processProposal !== undefined && (obj.processProposal = message.processProposal ? exports.RequestProcessProposal.toJSON(message.processProposal) : undefined);
	        message.ethQuery !== undefined && (obj.ethQuery = message.ethQuery ? exports.RequestEthQuery.toJSON(message.ethQuery) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequest();
	        message.echo = object.echo !== undefined && object.echo !== null ? exports.RequestEcho.fromPartial(object.echo) : undefined;
	        message.flush = object.flush !== undefined && object.flush !== null ? exports.RequestFlush.fromPartial(object.flush) : undefined;
	        message.info = object.info !== undefined && object.info !== null ? exports.RequestInfo.fromPartial(object.info) : undefined;
	        message.initChain = object.initChain !== undefined && object.initChain !== null ? exports.RequestInitChain.fromPartial(object.initChain) : undefined;
	        message.query = object.query !== undefined && object.query !== null ? exports.RequestQuery.fromPartial(object.query) : undefined;
	        message.beginBlock = object.beginBlock !== undefined && object.beginBlock !== null ? exports.RequestBeginBlock.fromPartial(object.beginBlock) : undefined;
	        message.checkTx = object.checkTx !== undefined && object.checkTx !== null ? exports.RequestCheckTx.fromPartial(object.checkTx) : undefined;
	        message.deliverTx = object.deliverTx !== undefined && object.deliverTx !== null ? exports.RequestDeliverTx.fromPartial(object.deliverTx) : undefined;
	        message.endBlock = object.endBlock !== undefined && object.endBlock !== null ? exports.RequestEndBlock.fromPartial(object.endBlock) : undefined;
	        message.commit = object.commit !== undefined && object.commit !== null ? exports.RequestCommit.fromPartial(object.commit) : undefined;
	        message.listSnapshots = object.listSnapshots !== undefined && object.listSnapshots !== null ? exports.RequestListSnapshots.fromPartial(object.listSnapshots) : undefined;
	        message.offerSnapshot = object.offerSnapshot !== undefined && object.offerSnapshot !== null ? exports.RequestOfferSnapshot.fromPartial(object.offerSnapshot) : undefined;
	        message.loadSnapshotChunk = object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null ? exports.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : undefined;
	        message.applySnapshotChunk = object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null ? exports.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : undefined;
	        message.prepareProposal = object.prepareProposal !== undefined && object.prepareProposal !== null ? exports.RequestPrepareProposal.fromPartial(object.prepareProposal) : undefined;
	        message.processProposal = object.processProposal !== undefined && object.processProposal !== null ? exports.RequestProcessProposal.fromPartial(object.processProposal) : undefined;
	        message.ethQuery = object.ethQuery !== undefined && object.ethQuery !== null ? exports.RequestEthQuery.fromPartial(object.ethQuery) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            echo: object.echo ? exports.RequestEcho.fromSDK(object.echo) : undefined,
	            flush: object.flush ? exports.RequestFlush.fromSDK(object.flush) : undefined,
	            info: object.info ? exports.RequestInfo.fromSDK(object.info) : undefined,
	            initChain: object.init_chain ? exports.RequestInitChain.fromSDK(object.init_chain) : undefined,
	            query: object.query ? exports.RequestQuery.fromSDK(object.query) : undefined,
	            beginBlock: object.begin_block ? exports.RequestBeginBlock.fromSDK(object.begin_block) : undefined,
	            checkTx: object.check_tx ? exports.RequestCheckTx.fromSDK(object.check_tx) : undefined,
	            deliverTx: object.deliver_tx ? exports.RequestDeliverTx.fromSDK(object.deliver_tx) : undefined,
	            endBlock: object.end_block ? exports.RequestEndBlock.fromSDK(object.end_block) : undefined,
	            commit: object.commit ? exports.RequestCommit.fromSDK(object.commit) : undefined,
	            listSnapshots: object.list_snapshots ? exports.RequestListSnapshots.fromSDK(object.list_snapshots) : undefined,
	            offerSnapshot: object.offer_snapshot ? exports.RequestOfferSnapshot.fromSDK(object.offer_snapshot) : undefined,
	            loadSnapshotChunk: object.load_snapshot_chunk ? exports.RequestLoadSnapshotChunk.fromSDK(object.load_snapshot_chunk) : undefined,
	            applySnapshotChunk: object.apply_snapshot_chunk ? exports.RequestApplySnapshotChunk.fromSDK(object.apply_snapshot_chunk) : undefined,
	            prepareProposal: object.prepare_proposal ? exports.RequestPrepareProposal.fromSDK(object.prepare_proposal) : undefined,
	            processProposal: object.process_proposal ? exports.RequestProcessProposal.fromSDK(object.process_proposal) : undefined,
	            ethQuery: object.eth_query ? exports.RequestEthQuery.fromSDK(object.eth_query) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.echo !== undefined && (obj.echo = message.echo ? exports.RequestEcho.toSDK(message.echo) : undefined);
	        message.flush !== undefined && (obj.flush = message.flush ? exports.RequestFlush.toSDK(message.flush) : undefined);
	        message.info !== undefined && (obj.info = message.info ? exports.RequestInfo.toSDK(message.info) : undefined);
	        message.initChain !== undefined && (obj.init_chain = message.initChain ? exports.RequestInitChain.toSDK(message.initChain) : undefined);
	        message.query !== undefined && (obj.query = message.query ? exports.RequestQuery.toSDK(message.query) : undefined);
	        message.beginBlock !== undefined && (obj.begin_block = message.beginBlock ? exports.RequestBeginBlock.toSDK(message.beginBlock) : undefined);
	        message.checkTx !== undefined && (obj.check_tx = message.checkTx ? exports.RequestCheckTx.toSDK(message.checkTx) : undefined);
	        message.deliverTx !== undefined && (obj.deliver_tx = message.deliverTx ? exports.RequestDeliverTx.toSDK(message.deliverTx) : undefined);
	        message.endBlock !== undefined && (obj.end_block = message.endBlock ? exports.RequestEndBlock.toSDK(message.endBlock) : undefined);
	        message.commit !== undefined && (obj.commit = message.commit ? exports.RequestCommit.toSDK(message.commit) : undefined);
	        message.listSnapshots !== undefined && (obj.list_snapshots = message.listSnapshots ? exports.RequestListSnapshots.toSDK(message.listSnapshots) : undefined);
	        message.offerSnapshot !== undefined && (obj.offer_snapshot = message.offerSnapshot ? exports.RequestOfferSnapshot.toSDK(message.offerSnapshot) : undefined);
	        message.loadSnapshotChunk !== undefined && (obj.load_snapshot_chunk = message.loadSnapshotChunk ? exports.RequestLoadSnapshotChunk.toSDK(message.loadSnapshotChunk) : undefined);
	        message.applySnapshotChunk !== undefined && (obj.apply_snapshot_chunk = message.applySnapshotChunk ? exports.RequestApplySnapshotChunk.toSDK(message.applySnapshotChunk) : undefined);
	        message.prepareProposal !== undefined && (obj.prepare_proposal = message.prepareProposal ? exports.RequestPrepareProposal.toSDK(message.prepareProposal) : undefined);
	        message.processProposal !== undefined && (obj.process_proposal = message.processProposal ? exports.RequestProcessProposal.toSDK(message.processProposal) : undefined);
	        message.ethQuery !== undefined && (obj.eth_query = message.ethQuery ? exports.RequestEthQuery.toSDK(message.ethQuery) : undefined);
	        return obj;
	    }
	};
	function createBaseRequestEcho() {
	    return {
	        message: ""
	    };
	}
	exports.RequestEcho = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.message !== "") {
	            writer.uint32(10).string(message.message);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestEcho();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.message = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            message: (0, helpers_1.isSet)(object.message) ? String(object.message) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.message !== undefined && (obj.message = message.message);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestEcho();
	        message.message = object.message ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            message: object?.message
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.message = message.message;
	        return obj;
	    }
	};
	function createBaseRequestFlush() {
	    return {};
	}
	exports.RequestFlush = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestFlush();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseRequestFlush();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseRequestInfo() {
	    return {
	        version: "",
	        blockVersion: helpers_1.Long.UZERO,
	        p2pVersion: helpers_1.Long.UZERO,
	        abciVersion: ""
	    };
	}
	exports.RequestInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.version !== "") {
	            writer.uint32(10).string(message.version);
	        }
	        if (!message.blockVersion.isZero()) {
	            writer.uint32(16).uint64(message.blockVersion);
	        }
	        if (!message.p2pVersion.isZero()) {
	            writer.uint32(24).uint64(message.p2pVersion);
	        }
	        if (message.abciVersion !== "") {
	            writer.uint32(34).string(message.abciVersion);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.version = reader.string();
	                    break;
	                case 2:
	                    message.blockVersion = reader.uint64();
	                    break;
	                case 3:
	                    message.p2pVersion = reader.uint64();
	                    break;
	                case 4:
	                    message.abciVersion = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            version: (0, helpers_1.isSet)(object.version) ? String(object.version) : "",
	            blockVersion: (0, helpers_1.isSet)(object.blockVersion) ? helpers_1.Long.fromValue(object.blockVersion) : helpers_1.Long.UZERO,
	            p2pVersion: (0, helpers_1.isSet)(object.p2pVersion) ? helpers_1.Long.fromValue(object.p2pVersion) : helpers_1.Long.UZERO,
	            abciVersion: (0, helpers_1.isSet)(object.abciVersion) ? String(object.abciVersion) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.version !== undefined && (obj.version = message.version);
	        message.blockVersion !== undefined && (obj.blockVersion = (message.blockVersion || helpers_1.Long.UZERO).toString());
	        message.p2pVersion !== undefined && (obj.p2pVersion = (message.p2pVersion || helpers_1.Long.UZERO).toString());
	        message.abciVersion !== undefined && (obj.abciVersion = message.abciVersion);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestInfo();
	        message.version = object.version ?? "";
	        message.blockVersion = object.blockVersion !== undefined && object.blockVersion !== null ? helpers_1.Long.fromValue(object.blockVersion) : helpers_1.Long.UZERO;
	        message.p2pVersion = object.p2pVersion !== undefined && object.p2pVersion !== null ? helpers_1.Long.fromValue(object.p2pVersion) : helpers_1.Long.UZERO;
	        message.abciVersion = object.abciVersion ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            version: object?.version,
	            blockVersion: object?.block_version,
	            p2pVersion: object?.p2p_version,
	            abciVersion: object?.abci_version
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.version = message.version;
	        obj.block_version = message.blockVersion;
	        obj.p2p_version = message.p2pVersion;
	        obj.abci_version = message.abciVersion;
	        return obj;
	    }
	};
	function createBaseRequestInitChain() {
	    return {
	        time: undefined,
	        chainId: "",
	        consensusParams: undefined,
	        validators: [],
	        appStateBytes: new Uint8Array(),
	        initialHeight: helpers_1.Long.ZERO
	    };
	}
	exports.RequestInitChain = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.time !== undefined) {
	            timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.chainId !== "") {
	            writer.uint32(18).string(message.chainId);
	        }
	        if (message.consensusParams !== undefined) {
	            params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
	        }
	        for (const v of message.validators) {
	            exports.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.appStateBytes.length !== 0) {
	            writer.uint32(42).bytes(message.appStateBytes);
	        }
	        if (!message.initialHeight.isZero()) {
	            writer.uint32(48).int64(message.initialHeight);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestInitChain();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.chainId = reader.string();
	                    break;
	                case 3:
	                    message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
	                    break;
	                case 5:
	                    message.appStateBytes = reader.bytes();
	                    break;
	                case 6:
	                    message.initialHeight = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            time: (0, helpers_1.isSet)(object.time) ? (0, helpers_1.fromJsonTimestamp)(object.time) : undefined,
	            chainId: (0, helpers_1.isSet)(object.chainId) ? String(object.chainId) : "",
	            consensusParams: (0, helpers_1.isSet)(object.consensusParams) ? params_1.ConsensusParams.fromJSON(object.consensusParams) : undefined,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.ValidatorUpdate.fromJSON(e)) : [],
	            appStateBytes: (0, helpers_1.isSet)(object.appStateBytes) ? (0, helpers_1.bytesFromBase64)(object.appStateBytes) : new Uint8Array(),
	            initialHeight: (0, helpers_1.isSet)(object.initialHeight) ? helpers_1.Long.fromValue(object.initialHeight) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
	        message.chainId !== undefined && (obj.chainId = message.chainId);
	        message.consensusParams !== undefined && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : undefined);
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.ValidatorUpdate.toJSON(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.appStateBytes !== undefined && (obj.appStateBytes = (0, helpers_1.base64FromBytes)(message.appStateBytes !== undefined ? message.appStateBytes : new Uint8Array()));
	        message.initialHeight !== undefined && (obj.initialHeight = (message.initialHeight || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestInitChain();
	        message.time = object.time !== undefined && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : undefined;
	        message.chainId = object.chainId ?? "";
	        message.consensusParams = object.consensusParams !== undefined && object.consensusParams !== null ? params_1.ConsensusParams.fromPartial(object.consensusParams) : undefined;
	        message.validators = object.validators?.map(e => exports.ValidatorUpdate.fromPartial(e)) || [];
	        message.appStateBytes = object.appStateBytes ?? new Uint8Array();
	        message.initialHeight = object.initialHeight !== undefined && object.initialHeight !== null ? helpers_1.Long.fromValue(object.initialHeight) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            time: object.time ? timestamp_1.Timestamp.fromSDK(object.time) : undefined,
	            chainId: object?.chain_id,
	            consensusParams: object.consensus_params ? params_1.ConsensusParams.fromSDK(object.consensus_params) : undefined,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.ValidatorUpdate.fromSDK(e)) : [],
	            appStateBytes: object?.app_state_bytes,
	            initialHeight: object?.initial_height
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.time !== undefined && (obj.time = message.time ? timestamp_1.Timestamp.toSDK(message.time) : undefined);
	        obj.chain_id = message.chainId;
	        message.consensusParams !== undefined && (obj.consensus_params = message.consensusParams ? params_1.ConsensusParams.toSDK(message.consensusParams) : undefined);
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.ValidatorUpdate.toSDK(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        obj.app_state_bytes = message.appStateBytes;
	        obj.initial_height = message.initialHeight;
	        return obj;
	    }
	};
	function createBaseRequestQuery() {
	    return {
	        data: new Uint8Array(),
	        path: "",
	        height: helpers_1.Long.ZERO,
	        prove: false
	    };
	}
	exports.RequestQuery = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.data.length !== 0) {
	            writer.uint32(10).bytes(message.data);
	        }
	        if (message.path !== "") {
	            writer.uint32(18).string(message.path);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(24).int64(message.height);
	        }
	        if (message.prove === true) {
	            writer.uint32(32).bool(message.prove);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestQuery();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.data = reader.bytes();
	                    break;
	                case 2:
	                    message.path = reader.string();
	                    break;
	                case 3:
	                    message.height = reader.int64();
	                    break;
	                case 4:
	                    message.prove = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array(),
	            path: (0, helpers_1.isSet)(object.path) ? String(object.path) : "",
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            prove: (0, helpers_1.isSet)(object.prove) ? Boolean(object.prove) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        message.path !== undefined && (obj.path = message.path);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.prove !== undefined && (obj.prove = message.prove);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestQuery();
	        message.data = object.data ?? new Uint8Array();
	        message.path = object.path ?? "";
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.prove = object.prove ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            data: object?.data,
	            path: object?.path,
	            height: object?.height,
	            prove: object?.prove
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.data = message.data;
	        obj.path = message.path;
	        obj.height = message.height;
	        obj.prove = message.prove;
	        return obj;
	    }
	};
	function createBaseRequestBeginBlock() {
	    return {
	        hash: new Uint8Array(),
	        header: undefined,
	        lastCommitInfo: undefined,
	        byzantineValidators: []
	    };
	}
	exports.RequestBeginBlock = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.hash.length !== 0) {
	            writer.uint32(10).bytes(message.hash);
	        }
	        if (message.header !== undefined) {
	            types_1.Header.encode(message.header, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.lastCommitInfo !== undefined) {
	            exports.CommitInfo.encode(message.lastCommitInfo, writer.uint32(26).fork()).ldelim();
	        }
	        for (const v of message.byzantineValidators) {
	            exports.Misbehavior.encode(v, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestBeginBlock();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.hash = reader.bytes();
	                    break;
	                case 2:
	                    message.header = types_1.Header.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.lastCommitInfo = exports.CommitInfo.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.byzantineValidators.push(exports.Misbehavior.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            hash: (0, helpers_1.isSet)(object.hash) ? (0, helpers_1.bytesFromBase64)(object.hash) : new Uint8Array(),
	            header: (0, helpers_1.isSet)(object.header) ? types_1.Header.fromJSON(object.header) : undefined,
	            lastCommitInfo: (0, helpers_1.isSet)(object.lastCommitInfo) ? exports.CommitInfo.fromJSON(object.lastCommitInfo) : undefined,
	            byzantineValidators: Array.isArray(object?.byzantineValidators) ? object.byzantineValidators.map((e) => exports.Misbehavior.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
	        message.header !== undefined && (obj.header = message.header ? types_1.Header.toJSON(message.header) : undefined);
	        message.lastCommitInfo !== undefined && (obj.lastCommitInfo = message.lastCommitInfo ? exports.CommitInfo.toJSON(message.lastCommitInfo) : undefined);
	        if (message.byzantineValidators) {
	            obj.byzantineValidators = message.byzantineValidators.map(e => e ? exports.Misbehavior.toJSON(e) : undefined);
	        }
	        else {
	            obj.byzantineValidators = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestBeginBlock();
	        message.hash = object.hash ?? new Uint8Array();
	        message.header = object.header !== undefined && object.header !== null ? types_1.Header.fromPartial(object.header) : undefined;
	        message.lastCommitInfo = object.lastCommitInfo !== undefined && object.lastCommitInfo !== null ? exports.CommitInfo.fromPartial(object.lastCommitInfo) : undefined;
	        message.byzantineValidators = object.byzantineValidators?.map(e => exports.Misbehavior.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            hash: object?.hash,
	            header: object.header ? types_1.Header.fromSDK(object.header) : undefined,
	            lastCommitInfo: object.last_commit_info ? exports.CommitInfo.fromSDK(object.last_commit_info) : undefined,
	            byzantineValidators: Array.isArray(object?.byzantine_validators) ? object.byzantine_validators.map((e) => exports.Misbehavior.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.hash = message.hash;
	        message.header !== undefined && (obj.header = message.header ? types_1.Header.toSDK(message.header) : undefined);
	        message.lastCommitInfo !== undefined && (obj.last_commit_info = message.lastCommitInfo ? exports.CommitInfo.toSDK(message.lastCommitInfo) : undefined);
	        if (message.byzantineValidators) {
	            obj.byzantine_validators = message.byzantineValidators.map(e => e ? exports.Misbehavior.toSDK(e) : undefined);
	        }
	        else {
	            obj.byzantine_validators = [];
	        }
	        return obj;
	    }
	};
	function createBaseRequestCheckTx() {
	    return {
	        tx: new Uint8Array(),
	        type: 0
	    };
	}
	exports.RequestCheckTx = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.tx.length !== 0) {
	            writer.uint32(10).bytes(message.tx);
	        }
	        if (message.type !== 0) {
	            writer.uint32(16).int32(message.type);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestCheckTx();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.tx = reader.bytes();
	                    break;
	                case 2:
	                    message.type = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            tx: (0, helpers_1.isSet)(object.tx) ? (0, helpers_1.bytesFromBase64)(object.tx) : new Uint8Array(),
	            type: (0, helpers_1.isSet)(object.type) ? checkTxTypeFromJSON(object.type) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== undefined ? message.tx : new Uint8Array()));
	        message.type !== undefined && (obj.type = checkTxTypeToJSON(message.type));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestCheckTx();
	        message.tx = object.tx ?? new Uint8Array();
	        message.type = object.type ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            tx: object?.tx,
	            type: (0, helpers_1.isSet)(object.type) ? checkTxTypeFromJSON(object.type) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.tx = message.tx;
	        message.type !== undefined && (obj.type = checkTxTypeToJSON(message.type));
	        return obj;
	    }
	};
	function createBaseRequestDeliverTx() {
	    return {
	        tx: new Uint8Array()
	    };
	}
	exports.RequestDeliverTx = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.tx.length !== 0) {
	            writer.uint32(10).bytes(message.tx);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestDeliverTx();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.tx = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            tx: (0, helpers_1.isSet)(object.tx) ? (0, helpers_1.bytesFromBase64)(object.tx) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== undefined ? message.tx : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestDeliverTx();
	        message.tx = object.tx ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            tx: object?.tx
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.tx = message.tx;
	        return obj;
	    }
	};
	function createBaseRequestEndBlock() {
	    return {
	        height: helpers_1.Long.ZERO
	    };
	}
	exports.RequestEndBlock = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestEndBlock();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestEndBlock();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        return obj;
	    }
	};
	function createBaseRequestCommit() {
	    return {};
	}
	exports.RequestCommit = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestCommit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseRequestCommit();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseRequestListSnapshots() {
	    return {};
	}
	exports.RequestListSnapshots = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestListSnapshots();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseRequestListSnapshots();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseRequestOfferSnapshot() {
	    return {
	        snapshot: undefined,
	        appHash: new Uint8Array()
	    };
	}
	exports.RequestOfferSnapshot = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.snapshot !== undefined) {
	            exports.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.appHash.length !== 0) {
	            writer.uint32(18).bytes(message.appHash);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestOfferSnapshot();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.snapshot = exports.Snapshot.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.appHash = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            snapshot: (0, helpers_1.isSet)(object.snapshot) ? exports.Snapshot.fromJSON(object.snapshot) : undefined,
	            appHash: (0, helpers_1.isSet)(object.appHash) ? (0, helpers_1.bytesFromBase64)(object.appHash) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.snapshot !== undefined && (obj.snapshot = message.snapshot ? exports.Snapshot.toJSON(message.snapshot) : undefined);
	        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestOfferSnapshot();
	        message.snapshot = object.snapshot !== undefined && object.snapshot !== null ? exports.Snapshot.fromPartial(object.snapshot) : undefined;
	        message.appHash = object.appHash ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            snapshot: object.snapshot ? exports.Snapshot.fromSDK(object.snapshot) : undefined,
	            appHash: object?.app_hash
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.snapshot !== undefined && (obj.snapshot = message.snapshot ? exports.Snapshot.toSDK(message.snapshot) : undefined);
	        obj.app_hash = message.appHash;
	        return obj;
	    }
	};
	function createBaseRequestLoadSnapshotChunk() {
	    return {
	        height: helpers_1.Long.UZERO,
	        format: 0,
	        chunk: 0
	    };
	}
	exports.RequestLoadSnapshotChunk = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).uint64(message.height);
	        }
	        if (message.format !== 0) {
	            writer.uint32(16).uint32(message.format);
	        }
	        if (message.chunk !== 0) {
	            writer.uint32(24).uint32(message.chunk);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestLoadSnapshotChunk();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.uint64();
	                    break;
	                case 2:
	                    message.format = reader.uint32();
	                    break;
	                case 3:
	                    message.chunk = reader.uint32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO,
	            format: (0, helpers_1.isSet)(object.format) ? Number(object.format) : 0,
	            chunk: (0, helpers_1.isSet)(object.chunk) ? Number(object.chunk) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.UZERO).toString());
	        message.format !== undefined && (obj.format = Math.round(message.format));
	        message.chunk !== undefined && (obj.chunk = Math.round(message.chunk));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestLoadSnapshotChunk();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO;
	        message.format = object.format ?? 0;
	        message.chunk = object.chunk ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            format: object?.format,
	            chunk: object?.chunk
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        obj.format = message.format;
	        obj.chunk = message.chunk;
	        return obj;
	    }
	};
	function createBaseRequestApplySnapshotChunk() {
	    return {
	        index: 0,
	        chunk: new Uint8Array(),
	        sender: ""
	    };
	}
	exports.RequestApplySnapshotChunk = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.index !== 0) {
	            writer.uint32(8).uint32(message.index);
	        }
	        if (message.chunk.length !== 0) {
	            writer.uint32(18).bytes(message.chunk);
	        }
	        if (message.sender !== "") {
	            writer.uint32(26).string(message.sender);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestApplySnapshotChunk();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.index = reader.uint32();
	                    break;
	                case 2:
	                    message.chunk = reader.bytes();
	                    break;
	                case 3:
	                    message.sender = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            index: (0, helpers_1.isSet)(object.index) ? Number(object.index) : 0,
	            chunk: (0, helpers_1.isSet)(object.chunk) ? (0, helpers_1.bytesFromBase64)(object.chunk) : new Uint8Array(),
	            sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.index !== undefined && (obj.index = Math.round(message.index));
	        message.chunk !== undefined && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== undefined ? message.chunk : new Uint8Array()));
	        message.sender !== undefined && (obj.sender = message.sender);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestApplySnapshotChunk();
	        message.index = object.index ?? 0;
	        message.chunk = object.chunk ?? new Uint8Array();
	        message.sender = object.sender ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            index: object?.index,
	            chunk: object?.chunk,
	            sender: object?.sender
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.index = message.index;
	        obj.chunk = message.chunk;
	        obj.sender = message.sender;
	        return obj;
	    }
	};
	function createBaseRequestPrepareProposal() {
	    return {
	        maxTxBytes: helpers_1.Long.ZERO,
	        txs: [],
	        localLastCommit: undefined,
	        misbehavior: [],
	        height: helpers_1.Long.ZERO,
	        time: undefined,
	        nextValidatorsHash: new Uint8Array(),
	        proposerAddress: new Uint8Array()
	    };
	}
	exports.RequestPrepareProposal = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.maxTxBytes.isZero()) {
	            writer.uint32(8).int64(message.maxTxBytes);
	        }
	        for (const v of message.txs) {
	            writer.uint32(18).bytes(v);
	        }
	        if (message.localLastCommit !== undefined) {
	            exports.ExtendedCommitInfo.encode(message.localLastCommit, writer.uint32(26).fork()).ldelim();
	        }
	        for (const v of message.misbehavior) {
	            exports.Misbehavior.encode(v, writer.uint32(34).fork()).ldelim();
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(40).int64(message.height);
	        }
	        if (message.time !== undefined) {
	            timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
	        }
	        if (message.nextValidatorsHash.length !== 0) {
	            writer.uint32(58).bytes(message.nextValidatorsHash);
	        }
	        if (message.proposerAddress.length !== 0) {
	            writer.uint32(66).bytes(message.proposerAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestPrepareProposal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.maxTxBytes = reader.int64();
	                    break;
	                case 2:
	                    message.txs.push(reader.bytes());
	                    break;
	                case 3:
	                    message.localLastCommit = exports.ExtendedCommitInfo.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
	                    break;
	                case 5:
	                    message.height = reader.int64();
	                    break;
	                case 6:
	                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 7:
	                    message.nextValidatorsHash = reader.bytes();
	                    break;
	                case 8:
	                    message.proposerAddress = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            maxTxBytes: (0, helpers_1.isSet)(object.maxTxBytes) ? helpers_1.Long.fromValue(object.maxTxBytes) : helpers_1.Long.ZERO,
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e)) : [],
	            localLastCommit: (0, helpers_1.isSet)(object.localLastCommit) ? exports.ExtendedCommitInfo.fromJSON(object.localLastCommit) : undefined,
	            misbehavior: Array.isArray(object?.misbehavior) ? object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e)) : [],
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            time: (0, helpers_1.isSet)(object.time) ? (0, helpers_1.fromJsonTimestamp)(object.time) : undefined,
	            nextValidatorsHash: (0, helpers_1.isSet)(object.nextValidatorsHash) ? (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash) : new Uint8Array(),
	            proposerAddress: (0, helpers_1.isSet)(object.proposerAddress) ? (0, helpers_1.bytesFromBase64)(object.proposerAddress) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.maxTxBytes !== undefined && (obj.maxTxBytes = (message.maxTxBytes || helpers_1.Long.ZERO).toString());
	        if (message.txs) {
	            obj.txs = message.txs.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.txs = [];
	        }
	        message.localLastCommit !== undefined && (obj.localLastCommit = message.localLastCommit ? exports.ExtendedCommitInfo.toJSON(message.localLastCommit) : undefined);
	        if (message.misbehavior) {
	            obj.misbehavior = message.misbehavior.map(e => e ? exports.Misbehavior.toJSON(e) : undefined);
	        }
	        else {
	            obj.misbehavior = [];
	        }
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
	        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
	        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestPrepareProposal();
	        message.maxTxBytes = object.maxTxBytes !== undefined && object.maxTxBytes !== null ? helpers_1.Long.fromValue(object.maxTxBytes) : helpers_1.Long.ZERO;
	        message.txs = object.txs?.map(e => e) || [];
	        message.localLastCommit = object.localLastCommit !== undefined && object.localLastCommit !== null ? exports.ExtendedCommitInfo.fromPartial(object.localLastCommit) : undefined;
	        message.misbehavior = object.misbehavior?.map(e => exports.Misbehavior.fromPartial(e)) || [];
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.time = object.time !== undefined && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : undefined;
	        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
	        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            maxTxBytes: object?.max_tx_bytes,
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => e) : [],
	            localLastCommit: object.local_last_commit ? exports.ExtendedCommitInfo.fromSDK(object.local_last_commit) : undefined,
	            misbehavior: Array.isArray(object?.misbehavior) ? object.misbehavior.map((e) => exports.Misbehavior.fromSDK(e)) : [],
	            height: object?.height,
	            time: object.time ? timestamp_1.Timestamp.fromSDK(object.time) : undefined,
	            nextValidatorsHash: object?.next_validators_hash,
	            proposerAddress: object?.proposer_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.max_tx_bytes = message.maxTxBytes;
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e);
	        }
	        else {
	            obj.txs = [];
	        }
	        message.localLastCommit !== undefined && (obj.local_last_commit = message.localLastCommit ? exports.ExtendedCommitInfo.toSDK(message.localLastCommit) : undefined);
	        if (message.misbehavior) {
	            obj.misbehavior = message.misbehavior.map(e => e ? exports.Misbehavior.toSDK(e) : undefined);
	        }
	        else {
	            obj.misbehavior = [];
	        }
	        obj.height = message.height;
	        message.time !== undefined && (obj.time = message.time ? timestamp_1.Timestamp.toSDK(message.time) : undefined);
	        obj.next_validators_hash = message.nextValidatorsHash;
	        obj.proposer_address = message.proposerAddress;
	        return obj;
	    }
	};
	function createBaseRequestProcessProposal() {
	    return {
	        txs: [],
	        proposedLastCommit: undefined,
	        misbehavior: [],
	        hash: new Uint8Array(),
	        height: helpers_1.Long.ZERO,
	        time: undefined,
	        nextValidatorsHash: new Uint8Array(),
	        proposerAddress: new Uint8Array()
	    };
	}
	exports.RequestProcessProposal = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.txs) {
	            writer.uint32(10).bytes(v);
	        }
	        if (message.proposedLastCommit !== undefined) {
	            exports.CommitInfo.encode(message.proposedLastCommit, writer.uint32(18).fork()).ldelim();
	        }
	        for (const v of message.misbehavior) {
	            exports.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.hash.length !== 0) {
	            writer.uint32(34).bytes(message.hash);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(40).int64(message.height);
	        }
	        if (message.time !== undefined) {
	            timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
	        }
	        if (message.nextValidatorsHash.length !== 0) {
	            writer.uint32(58).bytes(message.nextValidatorsHash);
	        }
	        if (message.proposerAddress.length !== 0) {
	            writer.uint32(66).bytes(message.proposerAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestProcessProposal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txs.push(reader.bytes());
	                    break;
	                case 2:
	                    message.proposedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
	                    break;
	                case 4:
	                    message.hash = reader.bytes();
	                    break;
	                case 5:
	                    message.height = reader.int64();
	                    break;
	                case 6:
	                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 7:
	                    message.nextValidatorsHash = reader.bytes();
	                    break;
	                case 8:
	                    message.proposerAddress = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e)) : [],
	            proposedLastCommit: (0, helpers_1.isSet)(object.proposedLastCommit) ? exports.CommitInfo.fromJSON(object.proposedLastCommit) : undefined,
	            misbehavior: Array.isArray(object?.misbehavior) ? object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e)) : [],
	            hash: (0, helpers_1.isSet)(object.hash) ? (0, helpers_1.bytesFromBase64)(object.hash) : new Uint8Array(),
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            time: (0, helpers_1.isSet)(object.time) ? (0, helpers_1.fromJsonTimestamp)(object.time) : undefined,
	            nextValidatorsHash: (0, helpers_1.isSet)(object.nextValidatorsHash) ? (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash) : new Uint8Array(),
	            proposerAddress: (0, helpers_1.isSet)(object.proposerAddress) ? (0, helpers_1.bytesFromBase64)(object.proposerAddress) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.txs = [];
	        }
	        message.proposedLastCommit !== undefined && (obj.proposedLastCommit = message.proposedLastCommit ? exports.CommitInfo.toJSON(message.proposedLastCommit) : undefined);
	        if (message.misbehavior) {
	            obj.misbehavior = message.misbehavior.map(e => e ? exports.Misbehavior.toJSON(e) : undefined);
	        }
	        else {
	            obj.misbehavior = [];
	        }
	        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
	        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
	        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestProcessProposal();
	        message.txs = object.txs?.map(e => e) || [];
	        message.proposedLastCommit = object.proposedLastCommit !== undefined && object.proposedLastCommit !== null ? exports.CommitInfo.fromPartial(object.proposedLastCommit) : undefined;
	        message.misbehavior = object.misbehavior?.map(e => exports.Misbehavior.fromPartial(e)) || [];
	        message.hash = object.hash ?? new Uint8Array();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.time = object.time !== undefined && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : undefined;
	        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
	        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => e) : [],
	            proposedLastCommit: object.proposed_last_commit ? exports.CommitInfo.fromSDK(object.proposed_last_commit) : undefined,
	            misbehavior: Array.isArray(object?.misbehavior) ? object.misbehavior.map((e) => exports.Misbehavior.fromSDK(e)) : [],
	            hash: object?.hash,
	            height: object?.height,
	            time: object.time ? timestamp_1.Timestamp.fromSDK(object.time) : undefined,
	            nextValidatorsHash: object?.next_validators_hash,
	            proposerAddress: object?.proposer_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e);
	        }
	        else {
	            obj.txs = [];
	        }
	        message.proposedLastCommit !== undefined && (obj.proposed_last_commit = message.proposedLastCommit ? exports.CommitInfo.toSDK(message.proposedLastCommit) : undefined);
	        if (message.misbehavior) {
	            obj.misbehavior = message.misbehavior.map(e => e ? exports.Misbehavior.toSDK(e) : undefined);
	        }
	        else {
	            obj.misbehavior = [];
	        }
	        obj.hash = message.hash;
	        obj.height = message.height;
	        message.time !== undefined && (obj.time = message.time ? timestamp_1.Timestamp.toSDK(message.time) : undefined);
	        obj.next_validators_hash = message.nextValidatorsHash;
	        obj.proposer_address = message.proposerAddress;
	        return obj;
	    }
	};
	function createBaseRequestEthQuery() {
	    return {
	        request: new Uint8Array()
	    };
	}
	exports.RequestEthQuery = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.request.length !== 0) {
	            writer.uint32(10).bytes(message.request);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRequestEthQuery();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.request = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            request: (0, helpers_1.isSet)(object.request) ? (0, helpers_1.bytesFromBase64)(object.request) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.request !== undefined && (obj.request = (0, helpers_1.base64FromBytes)(message.request !== undefined ? message.request : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRequestEthQuery();
	        message.request = object.request ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            request: object?.request
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.request = message.request;
	        return obj;
	    }
	};
	function createBaseResponse() {
	    return {
	        exception: undefined,
	        echo: undefined,
	        flush: undefined,
	        info: undefined,
	        initChain: undefined,
	        query: undefined,
	        beginBlock: undefined,
	        checkTx: undefined,
	        deliverTx: undefined,
	        endBlock: undefined,
	        commit: undefined,
	        listSnapshots: undefined,
	        offerSnapshot: undefined,
	        loadSnapshotChunk: undefined,
	        applySnapshotChunk: undefined,
	        prepareProposal: undefined,
	        processProposal: undefined,
	        ethQuery: undefined
	    };
	}
	exports.Response = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.exception !== undefined) {
	            exports.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.echo !== undefined) {
	            exports.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.flush !== undefined) {
	            exports.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.info !== undefined) {
	            exports.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.initChain !== undefined) {
	            exports.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
	        }
	        if (message.query !== undefined) {
	            exports.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
	        }
	        if (message.beginBlock !== undefined) {
	            exports.ResponseBeginBlock.encode(message.beginBlock, writer.uint32(66).fork()).ldelim();
	        }
	        if (message.checkTx !== undefined) {
	            exports.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
	        }
	        if (message.deliverTx !== undefined) {
	            exports.ResponseDeliverTx.encode(message.deliverTx, writer.uint32(82).fork()).ldelim();
	        }
	        if (message.endBlock !== undefined) {
	            exports.ResponseEndBlock.encode(message.endBlock, writer.uint32(90).fork()).ldelim();
	        }
	        if (message.commit !== undefined) {
	            exports.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
	        }
	        if (message.listSnapshots !== undefined) {
	            exports.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
	        }
	        if (message.offerSnapshot !== undefined) {
	            exports.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
	        }
	        if (message.loadSnapshotChunk !== undefined) {
	            exports.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
	        }
	        if (message.applySnapshotChunk !== undefined) {
	            exports.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
	        }
	        if (message.prepareProposal !== undefined) {
	            exports.ResponsePrepareProposal.encode(message.prepareProposal, writer.uint32(138).fork()).ldelim();
	        }
	        if (message.processProposal !== undefined) {
	            exports.ResponseProcessProposal.encode(message.processProposal, writer.uint32(146).fork()).ldelim();
	        }
	        if (message.ethQuery !== undefined) {
	            exports.ResponseEthQuery.encode(message.ethQuery, writer.uint32(154).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.exception = exports.ResponseException.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.echo = exports.ResponseEcho.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.flush = exports.ResponseFlush.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.info = exports.ResponseInfo.decode(reader, reader.uint32());
	                    break;
	                case 6:
	                    message.initChain = exports.ResponseInitChain.decode(reader, reader.uint32());
	                    break;
	                case 7:
	                    message.query = exports.ResponseQuery.decode(reader, reader.uint32());
	                    break;
	                case 8:
	                    message.beginBlock = exports.ResponseBeginBlock.decode(reader, reader.uint32());
	                    break;
	                case 9:
	                    message.checkTx = exports.ResponseCheckTx.decode(reader, reader.uint32());
	                    break;
	                case 10:
	                    message.deliverTx = exports.ResponseDeliverTx.decode(reader, reader.uint32());
	                    break;
	                case 11:
	                    message.endBlock = exports.ResponseEndBlock.decode(reader, reader.uint32());
	                    break;
	                case 12:
	                    message.commit = exports.ResponseCommit.decode(reader, reader.uint32());
	                    break;
	                case 13:
	                    message.listSnapshots = exports.ResponseListSnapshots.decode(reader, reader.uint32());
	                    break;
	                case 14:
	                    message.offerSnapshot = exports.ResponseOfferSnapshot.decode(reader, reader.uint32());
	                    break;
	                case 15:
	                    message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
	                    break;
	                case 16:
	                    message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
	                    break;
	                case 17:
	                    message.prepareProposal = exports.ResponsePrepareProposal.decode(reader, reader.uint32());
	                    break;
	                case 18:
	                    message.processProposal = exports.ResponseProcessProposal.decode(reader, reader.uint32());
	                    break;
	                case 19:
	                    message.ethQuery = exports.ResponseEthQuery.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            exception: (0, helpers_1.isSet)(object.exception) ? exports.ResponseException.fromJSON(object.exception) : undefined,
	            echo: (0, helpers_1.isSet)(object.echo) ? exports.ResponseEcho.fromJSON(object.echo) : undefined,
	            flush: (0, helpers_1.isSet)(object.flush) ? exports.ResponseFlush.fromJSON(object.flush) : undefined,
	            info: (0, helpers_1.isSet)(object.info) ? exports.ResponseInfo.fromJSON(object.info) : undefined,
	            initChain: (0, helpers_1.isSet)(object.initChain) ? exports.ResponseInitChain.fromJSON(object.initChain) : undefined,
	            query: (0, helpers_1.isSet)(object.query) ? exports.ResponseQuery.fromJSON(object.query) : undefined,
	            beginBlock: (0, helpers_1.isSet)(object.beginBlock) ? exports.ResponseBeginBlock.fromJSON(object.beginBlock) : undefined,
	            checkTx: (0, helpers_1.isSet)(object.checkTx) ? exports.ResponseCheckTx.fromJSON(object.checkTx) : undefined,
	            deliverTx: (0, helpers_1.isSet)(object.deliverTx) ? exports.ResponseDeliverTx.fromJSON(object.deliverTx) : undefined,
	            endBlock: (0, helpers_1.isSet)(object.endBlock) ? exports.ResponseEndBlock.fromJSON(object.endBlock) : undefined,
	            commit: (0, helpers_1.isSet)(object.commit) ? exports.ResponseCommit.fromJSON(object.commit) : undefined,
	            listSnapshots: (0, helpers_1.isSet)(object.listSnapshots) ? exports.ResponseListSnapshots.fromJSON(object.listSnapshots) : undefined,
	            offerSnapshot: (0, helpers_1.isSet)(object.offerSnapshot) ? exports.ResponseOfferSnapshot.fromJSON(object.offerSnapshot) : undefined,
	            loadSnapshotChunk: (0, helpers_1.isSet)(object.loadSnapshotChunk) ? exports.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk) : undefined,
	            applySnapshotChunk: (0, helpers_1.isSet)(object.applySnapshotChunk) ? exports.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk) : undefined,
	            prepareProposal: (0, helpers_1.isSet)(object.prepareProposal) ? exports.ResponsePrepareProposal.fromJSON(object.prepareProposal) : undefined,
	            processProposal: (0, helpers_1.isSet)(object.processProposal) ? exports.ResponseProcessProposal.fromJSON(object.processProposal) : undefined,
	            ethQuery: (0, helpers_1.isSet)(object.ethQuery) ? exports.ResponseEthQuery.fromJSON(object.ethQuery) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.exception !== undefined && (obj.exception = message.exception ? exports.ResponseException.toJSON(message.exception) : undefined);
	        message.echo !== undefined && (obj.echo = message.echo ? exports.ResponseEcho.toJSON(message.echo) : undefined);
	        message.flush !== undefined && (obj.flush = message.flush ? exports.ResponseFlush.toJSON(message.flush) : undefined);
	        message.info !== undefined && (obj.info = message.info ? exports.ResponseInfo.toJSON(message.info) : undefined);
	        message.initChain !== undefined && (obj.initChain = message.initChain ? exports.ResponseInitChain.toJSON(message.initChain) : undefined);
	        message.query !== undefined && (obj.query = message.query ? exports.ResponseQuery.toJSON(message.query) : undefined);
	        message.beginBlock !== undefined && (obj.beginBlock = message.beginBlock ? exports.ResponseBeginBlock.toJSON(message.beginBlock) : undefined);
	        message.checkTx !== undefined && (obj.checkTx = message.checkTx ? exports.ResponseCheckTx.toJSON(message.checkTx) : undefined);
	        message.deliverTx !== undefined && (obj.deliverTx = message.deliverTx ? exports.ResponseDeliverTx.toJSON(message.deliverTx) : undefined);
	        message.endBlock !== undefined && (obj.endBlock = message.endBlock ? exports.ResponseEndBlock.toJSON(message.endBlock) : undefined);
	        message.commit !== undefined && (obj.commit = message.commit ? exports.ResponseCommit.toJSON(message.commit) : undefined);
	        message.listSnapshots !== undefined && (obj.listSnapshots = message.listSnapshots ? exports.ResponseListSnapshots.toJSON(message.listSnapshots) : undefined);
	        message.offerSnapshot !== undefined && (obj.offerSnapshot = message.offerSnapshot ? exports.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : undefined);
	        message.loadSnapshotChunk !== undefined && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : undefined);
	        message.applySnapshotChunk !== undefined && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : undefined);
	        message.prepareProposal !== undefined && (obj.prepareProposal = message.prepareProposal ? exports.ResponsePrepareProposal.toJSON(message.prepareProposal) : undefined);
	        message.processProposal !== undefined && (obj.processProposal = message.processProposal ? exports.ResponseProcessProposal.toJSON(message.processProposal) : undefined);
	        message.ethQuery !== undefined && (obj.ethQuery = message.ethQuery ? exports.ResponseEthQuery.toJSON(message.ethQuery) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponse();
	        message.exception = object.exception !== undefined && object.exception !== null ? exports.ResponseException.fromPartial(object.exception) : undefined;
	        message.echo = object.echo !== undefined && object.echo !== null ? exports.ResponseEcho.fromPartial(object.echo) : undefined;
	        message.flush = object.flush !== undefined && object.flush !== null ? exports.ResponseFlush.fromPartial(object.flush) : undefined;
	        message.info = object.info !== undefined && object.info !== null ? exports.ResponseInfo.fromPartial(object.info) : undefined;
	        message.initChain = object.initChain !== undefined && object.initChain !== null ? exports.ResponseInitChain.fromPartial(object.initChain) : undefined;
	        message.query = object.query !== undefined && object.query !== null ? exports.ResponseQuery.fromPartial(object.query) : undefined;
	        message.beginBlock = object.beginBlock !== undefined && object.beginBlock !== null ? exports.ResponseBeginBlock.fromPartial(object.beginBlock) : undefined;
	        message.checkTx = object.checkTx !== undefined && object.checkTx !== null ? exports.ResponseCheckTx.fromPartial(object.checkTx) : undefined;
	        message.deliverTx = object.deliverTx !== undefined && object.deliverTx !== null ? exports.ResponseDeliverTx.fromPartial(object.deliverTx) : undefined;
	        message.endBlock = object.endBlock !== undefined && object.endBlock !== null ? exports.ResponseEndBlock.fromPartial(object.endBlock) : undefined;
	        message.commit = object.commit !== undefined && object.commit !== null ? exports.ResponseCommit.fromPartial(object.commit) : undefined;
	        message.listSnapshots = object.listSnapshots !== undefined && object.listSnapshots !== null ? exports.ResponseListSnapshots.fromPartial(object.listSnapshots) : undefined;
	        message.offerSnapshot = object.offerSnapshot !== undefined && object.offerSnapshot !== null ? exports.ResponseOfferSnapshot.fromPartial(object.offerSnapshot) : undefined;
	        message.loadSnapshotChunk = object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null ? exports.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : undefined;
	        message.applySnapshotChunk = object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null ? exports.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : undefined;
	        message.prepareProposal = object.prepareProposal !== undefined && object.prepareProposal !== null ? exports.ResponsePrepareProposal.fromPartial(object.prepareProposal) : undefined;
	        message.processProposal = object.processProposal !== undefined && object.processProposal !== null ? exports.ResponseProcessProposal.fromPartial(object.processProposal) : undefined;
	        message.ethQuery = object.ethQuery !== undefined && object.ethQuery !== null ? exports.ResponseEthQuery.fromPartial(object.ethQuery) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            exception: object.exception ? exports.ResponseException.fromSDK(object.exception) : undefined,
	            echo: object.echo ? exports.ResponseEcho.fromSDK(object.echo) : undefined,
	            flush: object.flush ? exports.ResponseFlush.fromSDK(object.flush) : undefined,
	            info: object.info ? exports.ResponseInfo.fromSDK(object.info) : undefined,
	            initChain: object.init_chain ? exports.ResponseInitChain.fromSDK(object.init_chain) : undefined,
	            query: object.query ? exports.ResponseQuery.fromSDK(object.query) : undefined,
	            beginBlock: object.begin_block ? exports.ResponseBeginBlock.fromSDK(object.begin_block) : undefined,
	            checkTx: object.check_tx ? exports.ResponseCheckTx.fromSDK(object.check_tx) : undefined,
	            deliverTx: object.deliver_tx ? exports.ResponseDeliverTx.fromSDK(object.deliver_tx) : undefined,
	            endBlock: object.end_block ? exports.ResponseEndBlock.fromSDK(object.end_block) : undefined,
	            commit: object.commit ? exports.ResponseCommit.fromSDK(object.commit) : undefined,
	            listSnapshots: object.list_snapshots ? exports.ResponseListSnapshots.fromSDK(object.list_snapshots) : undefined,
	            offerSnapshot: object.offer_snapshot ? exports.ResponseOfferSnapshot.fromSDK(object.offer_snapshot) : undefined,
	            loadSnapshotChunk: object.load_snapshot_chunk ? exports.ResponseLoadSnapshotChunk.fromSDK(object.load_snapshot_chunk) : undefined,
	            applySnapshotChunk: object.apply_snapshot_chunk ? exports.ResponseApplySnapshotChunk.fromSDK(object.apply_snapshot_chunk) : undefined,
	            prepareProposal: object.prepare_proposal ? exports.ResponsePrepareProposal.fromSDK(object.prepare_proposal) : undefined,
	            processProposal: object.process_proposal ? exports.ResponseProcessProposal.fromSDK(object.process_proposal) : undefined,
	            ethQuery: object.eth_query ? exports.ResponseEthQuery.fromSDK(object.eth_query) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.exception !== undefined && (obj.exception = message.exception ? exports.ResponseException.toSDK(message.exception) : undefined);
	        message.echo !== undefined && (obj.echo = message.echo ? exports.ResponseEcho.toSDK(message.echo) : undefined);
	        message.flush !== undefined && (obj.flush = message.flush ? exports.ResponseFlush.toSDK(message.flush) : undefined);
	        message.info !== undefined && (obj.info = message.info ? exports.ResponseInfo.toSDK(message.info) : undefined);
	        message.initChain !== undefined && (obj.init_chain = message.initChain ? exports.ResponseInitChain.toSDK(message.initChain) : undefined);
	        message.query !== undefined && (obj.query = message.query ? exports.ResponseQuery.toSDK(message.query) : undefined);
	        message.beginBlock !== undefined && (obj.begin_block = message.beginBlock ? exports.ResponseBeginBlock.toSDK(message.beginBlock) : undefined);
	        message.checkTx !== undefined && (obj.check_tx = message.checkTx ? exports.ResponseCheckTx.toSDK(message.checkTx) : undefined);
	        message.deliverTx !== undefined && (obj.deliver_tx = message.deliverTx ? exports.ResponseDeliverTx.toSDK(message.deliverTx) : undefined);
	        message.endBlock !== undefined && (obj.end_block = message.endBlock ? exports.ResponseEndBlock.toSDK(message.endBlock) : undefined);
	        message.commit !== undefined && (obj.commit = message.commit ? exports.ResponseCommit.toSDK(message.commit) : undefined);
	        message.listSnapshots !== undefined && (obj.list_snapshots = message.listSnapshots ? exports.ResponseListSnapshots.toSDK(message.listSnapshots) : undefined);
	        message.offerSnapshot !== undefined && (obj.offer_snapshot = message.offerSnapshot ? exports.ResponseOfferSnapshot.toSDK(message.offerSnapshot) : undefined);
	        message.loadSnapshotChunk !== undefined && (obj.load_snapshot_chunk = message.loadSnapshotChunk ? exports.ResponseLoadSnapshotChunk.toSDK(message.loadSnapshotChunk) : undefined);
	        message.applySnapshotChunk !== undefined && (obj.apply_snapshot_chunk = message.applySnapshotChunk ? exports.ResponseApplySnapshotChunk.toSDK(message.applySnapshotChunk) : undefined);
	        message.prepareProposal !== undefined && (obj.prepare_proposal = message.prepareProposal ? exports.ResponsePrepareProposal.toSDK(message.prepareProposal) : undefined);
	        message.processProposal !== undefined && (obj.process_proposal = message.processProposal ? exports.ResponseProcessProposal.toSDK(message.processProposal) : undefined);
	        message.ethQuery !== undefined && (obj.eth_query = message.ethQuery ? exports.ResponseEthQuery.toSDK(message.ethQuery) : undefined);
	        return obj;
	    }
	};
	function createBaseResponseException() {
	    return {
	        error: ""
	    };
	}
	exports.ResponseException = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.error !== "") {
	            writer.uint32(10).string(message.error);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseException();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.error = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            error: (0, helpers_1.isSet)(object.error) ? String(object.error) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.error !== undefined && (obj.error = message.error);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseException();
	        message.error = object.error ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            error: object?.error
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.error = message.error;
	        return obj;
	    }
	};
	function createBaseResponseEcho() {
	    return {
	        message: ""
	    };
	}
	exports.ResponseEcho = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.message !== "") {
	            writer.uint32(10).string(message.message);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseEcho();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.message = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            message: (0, helpers_1.isSet)(object.message) ? String(object.message) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.message !== undefined && (obj.message = message.message);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseEcho();
	        message.message = object.message ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            message: object?.message
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.message = message.message;
	        return obj;
	    }
	};
	function createBaseResponseFlush() {
	    return {};
	}
	exports.ResponseFlush = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseFlush();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseResponseFlush();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseResponseInfo() {
	    return {
	        data: "",
	        version: "",
	        appVersion: helpers_1.Long.UZERO,
	        lastBlockHeight: helpers_1.Long.ZERO,
	        lastBlockAppHash: new Uint8Array()
	    };
	}
	exports.ResponseInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.data !== "") {
	            writer.uint32(10).string(message.data);
	        }
	        if (message.version !== "") {
	            writer.uint32(18).string(message.version);
	        }
	        if (!message.appVersion.isZero()) {
	            writer.uint32(24).uint64(message.appVersion);
	        }
	        if (!message.lastBlockHeight.isZero()) {
	            writer.uint32(32).int64(message.lastBlockHeight);
	        }
	        if (message.lastBlockAppHash.length !== 0) {
	            writer.uint32(42).bytes(message.lastBlockAppHash);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.data = reader.string();
	                    break;
	                case 2:
	                    message.version = reader.string();
	                    break;
	                case 3:
	                    message.appVersion = reader.uint64();
	                    break;
	                case 4:
	                    message.lastBlockHeight = reader.int64();
	                    break;
	                case 5:
	                    message.lastBlockAppHash = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            data: (0, helpers_1.isSet)(object.data) ? String(object.data) : "",
	            version: (0, helpers_1.isSet)(object.version) ? String(object.version) : "",
	            appVersion: (0, helpers_1.isSet)(object.appVersion) ? helpers_1.Long.fromValue(object.appVersion) : helpers_1.Long.UZERO,
	            lastBlockHeight: (0, helpers_1.isSet)(object.lastBlockHeight) ? helpers_1.Long.fromValue(object.lastBlockHeight) : helpers_1.Long.ZERO,
	            lastBlockAppHash: (0, helpers_1.isSet)(object.lastBlockAppHash) ? (0, helpers_1.bytesFromBase64)(object.lastBlockAppHash) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.data !== undefined && (obj.data = message.data);
	        message.version !== undefined && (obj.version = message.version);
	        message.appVersion !== undefined && (obj.appVersion = (message.appVersion || helpers_1.Long.UZERO).toString());
	        message.lastBlockHeight !== undefined && (obj.lastBlockHeight = (message.lastBlockHeight || helpers_1.Long.ZERO).toString());
	        message.lastBlockAppHash !== undefined && (obj.lastBlockAppHash = (0, helpers_1.base64FromBytes)(message.lastBlockAppHash !== undefined ? message.lastBlockAppHash : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseInfo();
	        message.data = object.data ?? "";
	        message.version = object.version ?? "";
	        message.appVersion = object.appVersion !== undefined && object.appVersion !== null ? helpers_1.Long.fromValue(object.appVersion) : helpers_1.Long.UZERO;
	        message.lastBlockHeight = object.lastBlockHeight !== undefined && object.lastBlockHeight !== null ? helpers_1.Long.fromValue(object.lastBlockHeight) : helpers_1.Long.ZERO;
	        message.lastBlockAppHash = object.lastBlockAppHash ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            data: object?.data,
	            version: object?.version,
	            appVersion: object?.app_version,
	            lastBlockHeight: object?.last_block_height,
	            lastBlockAppHash: object?.last_block_app_hash
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.data = message.data;
	        obj.version = message.version;
	        obj.app_version = message.appVersion;
	        obj.last_block_height = message.lastBlockHeight;
	        obj.last_block_app_hash = message.lastBlockAppHash;
	        return obj;
	    }
	};
	function createBaseResponseInitChain() {
	    return {
	        consensusParams: undefined,
	        validators: [],
	        appHash: new Uint8Array()
	    };
	}
	exports.ResponseInitChain = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.consensusParams !== undefined) {
	            params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
	        }
	        for (const v of message.validators) {
	            exports.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.appHash.length !== 0) {
	            writer.uint32(26).bytes(message.appHash);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseInitChain();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
	                    break;
	                case 3:
	                    message.appHash = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            consensusParams: (0, helpers_1.isSet)(object.consensusParams) ? params_1.ConsensusParams.fromJSON(object.consensusParams) : undefined,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.ValidatorUpdate.fromJSON(e)) : [],
	            appHash: (0, helpers_1.isSet)(object.appHash) ? (0, helpers_1.bytesFromBase64)(object.appHash) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.consensusParams !== undefined && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : undefined);
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.ValidatorUpdate.toJSON(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseInitChain();
	        message.consensusParams = object.consensusParams !== undefined && object.consensusParams !== null ? params_1.ConsensusParams.fromPartial(object.consensusParams) : undefined;
	        message.validators = object.validators?.map(e => exports.ValidatorUpdate.fromPartial(e)) || [];
	        message.appHash = object.appHash ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            consensusParams: object.consensus_params ? params_1.ConsensusParams.fromSDK(object.consensus_params) : undefined,
	            validators: Array.isArray(object?.validators) ? object.validators.map((e) => exports.ValidatorUpdate.fromSDK(e)) : [],
	            appHash: object?.app_hash
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.consensusParams !== undefined && (obj.consensus_params = message.consensusParams ? params_1.ConsensusParams.toSDK(message.consensusParams) : undefined);
	        if (message.validators) {
	            obj.validators = message.validators.map(e => e ? exports.ValidatorUpdate.toSDK(e) : undefined);
	        }
	        else {
	            obj.validators = [];
	        }
	        obj.app_hash = message.appHash;
	        return obj;
	    }
	};
	function createBaseResponseQuery() {
	    return {
	        code: 0,
	        log: "",
	        info: "",
	        index: helpers_1.Long.ZERO,
	        key: new Uint8Array(),
	        value: new Uint8Array(),
	        proofOps: undefined,
	        height: helpers_1.Long.ZERO,
	        codespace: ""
	    };
	}
	exports.ResponseQuery = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.code !== 0) {
	            writer.uint32(8).uint32(message.code);
	        }
	        if (message.log !== "") {
	            writer.uint32(26).string(message.log);
	        }
	        if (message.info !== "") {
	            writer.uint32(34).string(message.info);
	        }
	        if (!message.index.isZero()) {
	            writer.uint32(40).int64(message.index);
	        }
	        if (message.key.length !== 0) {
	            writer.uint32(50).bytes(message.key);
	        }
	        if (message.value.length !== 0) {
	            writer.uint32(58).bytes(message.value);
	        }
	        if (message.proofOps !== undefined) {
	            proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(72).int64(message.height);
	        }
	        if (message.codespace !== "") {
	            writer.uint32(82).string(message.codespace);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseQuery();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.code = reader.uint32();
	                    break;
	                case 3:
	                    message.log = reader.string();
	                    break;
	                case 4:
	                    message.info = reader.string();
	                    break;
	                case 5:
	                    message.index = reader.int64();
	                    break;
	                case 6:
	                    message.key = reader.bytes();
	                    break;
	                case 7:
	                    message.value = reader.bytes();
	                    break;
	                case 8:
	                    message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
	                    break;
	                case 9:
	                    message.height = reader.int64();
	                    break;
	                case 10:
	                    message.codespace = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            code: (0, helpers_1.isSet)(object.code) ? Number(object.code) : 0,
	            log: (0, helpers_1.isSet)(object.log) ? String(object.log) : "",
	            info: (0, helpers_1.isSet)(object.info) ? String(object.info) : "",
	            index: (0, helpers_1.isSet)(object.index) ? helpers_1.Long.fromValue(object.index) : helpers_1.Long.ZERO,
	            key: (0, helpers_1.isSet)(object.key) ? (0, helpers_1.bytesFromBase64)(object.key) : new Uint8Array(),
	            value: (0, helpers_1.isSet)(object.value) ? (0, helpers_1.bytesFromBase64)(object.value) : new Uint8Array(),
	            proofOps: (0, helpers_1.isSet)(object.proofOps) ? proof_1.ProofOps.fromJSON(object.proofOps) : undefined,
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            codespace: (0, helpers_1.isSet)(object.codespace) ? String(object.codespace) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.code !== undefined && (obj.code = Math.round(message.code));
	        message.log !== undefined && (obj.log = message.log);
	        message.info !== undefined && (obj.info = message.info);
	        message.index !== undefined && (obj.index = (message.index || helpers_1.Long.ZERO).toString());
	        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
	        message.value !== undefined && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
	        message.proofOps !== undefined && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : undefined);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.codespace !== undefined && (obj.codespace = message.codespace);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseQuery();
	        message.code = object.code ?? 0;
	        message.log = object.log ?? "";
	        message.info = object.info ?? "";
	        message.index = object.index !== undefined && object.index !== null ? helpers_1.Long.fromValue(object.index) : helpers_1.Long.ZERO;
	        message.key = object.key ?? new Uint8Array();
	        message.value = object.value ?? new Uint8Array();
	        message.proofOps = object.proofOps !== undefined && object.proofOps !== null ? proof_1.ProofOps.fromPartial(object.proofOps) : undefined;
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.codespace = object.codespace ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            code: object?.code,
	            log: object?.log,
	            info: object?.info,
	            index: object?.index,
	            key: object?.key,
	            value: object?.value,
	            proofOps: object.proof_ops ? proof_1.ProofOps.fromSDK(object.proof_ops) : undefined,
	            height: object?.height,
	            codespace: object?.codespace
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.code = message.code;
	        obj.log = message.log;
	        obj.info = message.info;
	        obj.index = message.index;
	        obj.key = message.key;
	        obj.value = message.value;
	        message.proofOps !== undefined && (obj.proof_ops = message.proofOps ? proof_1.ProofOps.toSDK(message.proofOps) : undefined);
	        obj.height = message.height;
	        obj.codespace = message.codespace;
	        return obj;
	    }
	};
	function createBaseResponseBeginBlock() {
	    return {
	        events: []
	    };
	}
	exports.ResponseBeginBlock = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.events) {
	            exports.Event.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseBeginBlock();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.events.push(exports.Event.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseBeginBlock();
	        message.events = object.events?.map(e => exports.Event.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toSDK(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    }
	};
	function createBaseResponseCheckTx() {
	    return {
	        code: 0,
	        data: new Uint8Array(),
	        log: "",
	        info: "",
	        gasWanted: helpers_1.Long.ZERO,
	        gasUsed: helpers_1.Long.ZERO,
	        events: [],
	        codespace: "",
	        sender: "",
	        priority: helpers_1.Long.ZERO,
	        mempoolError: ""
	    };
	}
	exports.ResponseCheckTx = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.code !== 0) {
	            writer.uint32(8).uint32(message.code);
	        }
	        if (message.data.length !== 0) {
	            writer.uint32(18).bytes(message.data);
	        }
	        if (message.log !== "") {
	            writer.uint32(26).string(message.log);
	        }
	        if (message.info !== "") {
	            writer.uint32(34).string(message.info);
	        }
	        if (!message.gasWanted.isZero()) {
	            writer.uint32(40).int64(message.gasWanted);
	        }
	        if (!message.gasUsed.isZero()) {
	            writer.uint32(48).int64(message.gasUsed);
	        }
	        for (const v of message.events) {
	            exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
	        }
	        if (message.codespace !== "") {
	            writer.uint32(66).string(message.codespace);
	        }
	        if (message.sender !== "") {
	            writer.uint32(74).string(message.sender);
	        }
	        if (!message.priority.isZero()) {
	            writer.uint32(80).int64(message.priority);
	        }
	        if (message.mempoolError !== "") {
	            writer.uint32(90).string(message.mempoolError);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseCheckTx();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.code = reader.uint32();
	                    break;
	                case 2:
	                    message.data = reader.bytes();
	                    break;
	                case 3:
	                    message.log = reader.string();
	                    break;
	                case 4:
	                    message.info = reader.string();
	                    break;
	                case 5:
	                    message.gasWanted = reader.int64();
	                    break;
	                case 6:
	                    message.gasUsed = reader.int64();
	                    break;
	                case 7:
	                    message.events.push(exports.Event.decode(reader, reader.uint32()));
	                    break;
	                case 8:
	                    message.codespace = reader.string();
	                    break;
	                case 9:
	                    message.sender = reader.string();
	                    break;
	                case 10:
	                    message.priority = reader.int64();
	                    break;
	                case 11:
	                    message.mempoolError = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            code: (0, helpers_1.isSet)(object.code) ? Number(object.code) : 0,
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array(),
	            log: (0, helpers_1.isSet)(object.log) ? String(object.log) : "",
	            info: (0, helpers_1.isSet)(object.info) ? String(object.info) : "",
	            gasWanted: (0, helpers_1.isSet)(object.gas_wanted) ? helpers_1.Long.fromValue(object.gas_wanted) : helpers_1.Long.ZERO,
	            gasUsed: (0, helpers_1.isSet)(object.gas_used) ? helpers_1.Long.fromValue(object.gas_used) : helpers_1.Long.ZERO,
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromJSON(e)) : [],
	            codespace: (0, helpers_1.isSet)(object.codespace) ? String(object.codespace) : "",
	            sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
	            priority: (0, helpers_1.isSet)(object.priority) ? helpers_1.Long.fromValue(object.priority) : helpers_1.Long.ZERO,
	            mempoolError: (0, helpers_1.isSet)(object.mempoolError) ? String(object.mempoolError) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.code !== undefined && (obj.code = Math.round(message.code));
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        message.log !== undefined && (obj.log = message.log);
	        message.info !== undefined && (obj.info = message.info);
	        message.gasWanted !== undefined && (obj.gas_wanted = (message.gasWanted || helpers_1.Long.ZERO).toString());
	        message.gasUsed !== undefined && (obj.gas_used = (message.gasUsed || helpers_1.Long.ZERO).toString());
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        message.codespace !== undefined && (obj.codespace = message.codespace);
	        message.sender !== undefined && (obj.sender = message.sender);
	        message.priority !== undefined && (obj.priority = (message.priority || helpers_1.Long.ZERO).toString());
	        message.mempoolError !== undefined && (obj.mempoolError = message.mempoolError);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseCheckTx();
	        message.code = object.code ?? 0;
	        message.data = object.data ?? new Uint8Array();
	        message.log = object.log ?? "";
	        message.info = object.info ?? "";
	        message.gasWanted = object.gasWanted !== undefined && object.gasWanted !== null ? helpers_1.Long.fromValue(object.gasWanted) : helpers_1.Long.ZERO;
	        message.gasUsed = object.gasUsed !== undefined && object.gasUsed !== null ? helpers_1.Long.fromValue(object.gasUsed) : helpers_1.Long.ZERO;
	        message.events = object.events?.map(e => exports.Event.fromPartial(e)) || [];
	        message.codespace = object.codespace ?? "";
	        message.sender = object.sender ?? "";
	        message.priority = object.priority !== undefined && object.priority !== null ? helpers_1.Long.fromValue(object.priority) : helpers_1.Long.ZERO;
	        message.mempoolError = object.mempoolError ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            code: object?.code,
	            data: object?.data,
	            log: object?.log,
	            info: object?.info,
	            gasWanted: object?.gas_wanted,
	            gasUsed: object?.gas_used,
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromSDK(e)) : [],
	            codespace: object?.codespace,
	            sender: object?.sender,
	            priority: object?.priority,
	            mempoolError: object?.mempool_error
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.code = message.code;
	        obj.data = message.data;
	        obj.log = message.log;
	        obj.info = message.info;
	        obj.gas_wanted = message.gasWanted;
	        obj.gas_used = message.gasUsed;
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toSDK(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        obj.codespace = message.codespace;
	        obj.sender = message.sender;
	        obj.priority = message.priority;
	        obj.mempool_error = message.mempoolError;
	        return obj;
	    }
	};
	function createBaseResponseDeliverTx() {
	    return {
	        code: 0,
	        data: new Uint8Array(),
	        log: "",
	        info: "",
	        gasWanted: helpers_1.Long.ZERO,
	        gasUsed: helpers_1.Long.ZERO,
	        events: [],
	        codespace: ""
	    };
	}
	exports.ResponseDeliverTx = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.code !== 0) {
	            writer.uint32(8).uint32(message.code);
	        }
	        if (message.data.length !== 0) {
	            writer.uint32(18).bytes(message.data);
	        }
	        if (message.log !== "") {
	            writer.uint32(26).string(message.log);
	        }
	        if (message.info !== "") {
	            writer.uint32(34).string(message.info);
	        }
	        if (!message.gasWanted.isZero()) {
	            writer.uint32(40).int64(message.gasWanted);
	        }
	        if (!message.gasUsed.isZero()) {
	            writer.uint32(48).int64(message.gasUsed);
	        }
	        for (const v of message.events) {
	            exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
	        }
	        if (message.codespace !== "") {
	            writer.uint32(66).string(message.codespace);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseDeliverTx();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.code = reader.uint32();
	                    break;
	                case 2:
	                    message.data = reader.bytes();
	                    break;
	                case 3:
	                    message.log = reader.string();
	                    break;
	                case 4:
	                    message.info = reader.string();
	                    break;
	                case 5:
	                    message.gasWanted = reader.int64();
	                    break;
	                case 6:
	                    message.gasUsed = reader.int64();
	                    break;
	                case 7:
	                    message.events.push(exports.Event.decode(reader, reader.uint32()));
	                    break;
	                case 8:
	                    message.codespace = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            code: (0, helpers_1.isSet)(object.code) ? Number(object.code) : 0,
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array(),
	            log: (0, helpers_1.isSet)(object.log) ? String(object.log) : "",
	            info: (0, helpers_1.isSet)(object.info) ? String(object.info) : "",
	            gasWanted: (0, helpers_1.isSet)(object.gas_wanted) ? helpers_1.Long.fromValue(object.gas_wanted) : helpers_1.Long.ZERO,
	            gasUsed: (0, helpers_1.isSet)(object.gas_used) ? helpers_1.Long.fromValue(object.gas_used) : helpers_1.Long.ZERO,
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromJSON(e)) : [],
	            codespace: (0, helpers_1.isSet)(object.codespace) ? String(object.codespace) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.code !== undefined && (obj.code = Math.round(message.code));
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        message.log !== undefined && (obj.log = message.log);
	        message.info !== undefined && (obj.info = message.info);
	        message.gasWanted !== undefined && (obj.gas_wanted = (message.gasWanted || helpers_1.Long.ZERO).toString());
	        message.gasUsed !== undefined && (obj.gas_used = (message.gasUsed || helpers_1.Long.ZERO).toString());
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        message.codespace !== undefined && (obj.codespace = message.codespace);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseDeliverTx();
	        message.code = object.code ?? 0;
	        message.data = object.data ?? new Uint8Array();
	        message.log = object.log ?? "";
	        message.info = object.info ?? "";
	        message.gasWanted = object.gasWanted !== undefined && object.gasWanted !== null ? helpers_1.Long.fromValue(object.gasWanted) : helpers_1.Long.ZERO;
	        message.gasUsed = object.gasUsed !== undefined && object.gasUsed !== null ? helpers_1.Long.fromValue(object.gasUsed) : helpers_1.Long.ZERO;
	        message.events = object.events?.map(e => exports.Event.fromPartial(e)) || [];
	        message.codespace = object.codespace ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            code: object?.code,
	            data: object?.data,
	            log: object?.log,
	            info: object?.info,
	            gasWanted: object?.gas_wanted,
	            gasUsed: object?.gas_used,
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromSDK(e)) : [],
	            codespace: object?.codespace
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.code = message.code;
	        obj.data = message.data;
	        obj.log = message.log;
	        obj.info = message.info;
	        obj.gas_wanted = message.gasWanted;
	        obj.gas_used = message.gasUsed;
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toSDK(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        obj.codespace = message.codespace;
	        return obj;
	    }
	};
	function createBaseResponseEndBlock() {
	    return {
	        validatorUpdates: [],
	        consensusParamUpdates: undefined,
	        events: []
	    };
	}
	exports.ResponseEndBlock = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.validatorUpdates) {
	            exports.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.consensusParamUpdates !== undefined) {
	            params_1.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(18).fork()).ldelim();
	        }
	        for (const v of message.events) {
	            exports.Event.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseEndBlock();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validatorUpdates.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.consensusParamUpdates = params_1.ConsensusParams.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.events.push(exports.Event.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validatorUpdates: Array.isArray(object?.validatorUpdates) ? object.validatorUpdates.map((e) => exports.ValidatorUpdate.fromJSON(e)) : [],
	            consensusParamUpdates: (0, helpers_1.isSet)(object.consensusParamUpdates) ? params_1.ConsensusParams.fromJSON(object.consensusParamUpdates) : undefined,
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.validatorUpdates) {
	            obj.validatorUpdates = message.validatorUpdates.map(e => e ? exports.ValidatorUpdate.toJSON(e) : undefined);
	        }
	        else {
	            obj.validatorUpdates = [];
	        }
	        message.consensusParamUpdates !== undefined && (obj.consensusParamUpdates = message.consensusParamUpdates ? params_1.ConsensusParams.toJSON(message.consensusParamUpdates) : undefined);
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseEndBlock();
	        message.validatorUpdates = object.validatorUpdates?.map(e => exports.ValidatorUpdate.fromPartial(e)) || [];
	        message.consensusParamUpdates = object.consensusParamUpdates !== undefined && object.consensusParamUpdates !== null ? params_1.ConsensusParams.fromPartial(object.consensusParamUpdates) : undefined;
	        message.events = object.events?.map(e => exports.Event.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validatorUpdates: Array.isArray(object?.validator_updates) ? object.validator_updates.map((e) => exports.ValidatorUpdate.fromSDK(e)) : [],
	            consensusParamUpdates: object.consensus_param_updates ? params_1.ConsensusParams.fromSDK(object.consensus_param_updates) : undefined,
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.validatorUpdates) {
	            obj.validator_updates = message.validatorUpdates.map(e => e ? exports.ValidatorUpdate.toSDK(e) : undefined);
	        }
	        else {
	            obj.validator_updates = [];
	        }
	        message.consensusParamUpdates !== undefined && (obj.consensus_param_updates = message.consensusParamUpdates ? params_1.ConsensusParams.toSDK(message.consensusParamUpdates) : undefined);
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.Event.toSDK(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    }
	};
	function createBaseResponseCommit() {
	    return {
	        data: new Uint8Array(),
	        retainHeight: helpers_1.Long.ZERO
	    };
	}
	exports.ResponseCommit = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.data.length !== 0) {
	            writer.uint32(18).bytes(message.data);
	        }
	        if (!message.retainHeight.isZero()) {
	            writer.uint32(24).int64(message.retainHeight);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseCommit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 2:
	                    message.data = reader.bytes();
	                    break;
	                case 3:
	                    message.retainHeight = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array(),
	            retainHeight: (0, helpers_1.isSet)(object.retainHeight) ? helpers_1.Long.fromValue(object.retainHeight) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        message.retainHeight !== undefined && (obj.retainHeight = (message.retainHeight || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseCommit();
	        message.data = object.data ?? new Uint8Array();
	        message.retainHeight = object.retainHeight !== undefined && object.retainHeight !== null ? helpers_1.Long.fromValue(object.retainHeight) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            data: object?.data,
	            retainHeight: object?.retain_height
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.data = message.data;
	        obj.retain_height = message.retainHeight;
	        return obj;
	    }
	};
	function createBaseResponseListSnapshots() {
	    return {
	        snapshots: []
	    };
	}
	exports.ResponseListSnapshots = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.snapshots) {
	            exports.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseListSnapshots();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.snapshots.push(exports.Snapshot.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            snapshots: Array.isArray(object?.snapshots) ? object.snapshots.map((e) => exports.Snapshot.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.snapshots) {
	            obj.snapshots = message.snapshots.map(e => e ? exports.Snapshot.toJSON(e) : undefined);
	        }
	        else {
	            obj.snapshots = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseListSnapshots();
	        message.snapshots = object.snapshots?.map(e => exports.Snapshot.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            snapshots: Array.isArray(object?.snapshots) ? object.snapshots.map((e) => exports.Snapshot.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.snapshots) {
	            obj.snapshots = message.snapshots.map(e => e ? exports.Snapshot.toSDK(e) : undefined);
	        }
	        else {
	            obj.snapshots = [];
	        }
	        return obj;
	    }
	};
	function createBaseResponseOfferSnapshot() {
	    return {
	        result: 0
	    };
	}
	exports.ResponseOfferSnapshot = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.result !== 0) {
	            writer.uint32(8).int32(message.result);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseOfferSnapshot();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.result = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            result: (0, helpers_1.isSet)(object.result) ? responseOfferSnapshot_ResultFromJSON(object.result) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.result !== undefined && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseOfferSnapshot();
	        message.result = object.result ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            result: (0, helpers_1.isSet)(object.result) ? responseOfferSnapshot_ResultFromJSON(object.result) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.result !== undefined && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
	        return obj;
	    }
	};
	function createBaseResponseLoadSnapshotChunk() {
	    return {
	        chunk: new Uint8Array()
	    };
	}
	exports.ResponseLoadSnapshotChunk = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.chunk.length !== 0) {
	            writer.uint32(10).bytes(message.chunk);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseLoadSnapshotChunk();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.chunk = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            chunk: (0, helpers_1.isSet)(object.chunk) ? (0, helpers_1.bytesFromBase64)(object.chunk) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.chunk !== undefined && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== undefined ? message.chunk : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseLoadSnapshotChunk();
	        message.chunk = object.chunk ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            chunk: object?.chunk
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.chunk = message.chunk;
	        return obj;
	    }
	};
	function createBaseResponseApplySnapshotChunk() {
	    return {
	        result: 0,
	        refetchChunks: [],
	        rejectSenders: []
	    };
	}
	exports.ResponseApplySnapshotChunk = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.result !== 0) {
	            writer.uint32(8).int32(message.result);
	        }
	        writer.uint32(18).fork();
	        for (const v of message.refetchChunks) {
	            writer.uint32(v);
	        }
	        writer.ldelim();
	        for (const v of message.rejectSenders) {
	            writer.uint32(26).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseApplySnapshotChunk();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.result = reader.int32();
	                    break;
	                case 2:
	                    if ((tag & 7) === 2) {
	                        const end2 = reader.uint32() + reader.pos;
	                        while (reader.pos < end2) {
	                            message.refetchChunks.push(reader.uint32());
	                        }
	                    }
	                    else {
	                        message.refetchChunks.push(reader.uint32());
	                    }
	                    break;
	                case 3:
	                    message.rejectSenders.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            result: (0, helpers_1.isSet)(object.result) ? responseApplySnapshotChunk_ResultFromJSON(object.result) : 0,
	            refetchChunks: Array.isArray(object?.refetchChunks) ? object.refetchChunks.map((e) => Number(e)) : [],
	            rejectSenders: Array.isArray(object?.rejectSenders) ? object.rejectSenders.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.result !== undefined && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
	        if (message.refetchChunks) {
	            obj.refetchChunks = message.refetchChunks.map(e => Math.round(e));
	        }
	        else {
	            obj.refetchChunks = [];
	        }
	        if (message.rejectSenders) {
	            obj.rejectSenders = message.rejectSenders.map(e => e);
	        }
	        else {
	            obj.rejectSenders = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseApplySnapshotChunk();
	        message.result = object.result ?? 0;
	        message.refetchChunks = object.refetchChunks?.map(e => e) || [];
	        message.rejectSenders = object.rejectSenders?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            result: (0, helpers_1.isSet)(object.result) ? responseApplySnapshotChunk_ResultFromJSON(object.result) : 0,
	            refetchChunks: Array.isArray(object?.refetch_chunks) ? object.refetch_chunks.map((e) => e) : [],
	            rejectSenders: Array.isArray(object?.reject_senders) ? object.reject_senders.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.result !== undefined && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
	        if (message.refetchChunks) {
	            obj.refetch_chunks = message.refetchChunks.map(e => e);
	        }
	        else {
	            obj.refetch_chunks = [];
	        }
	        if (message.rejectSenders) {
	            obj.reject_senders = message.rejectSenders.map(e => e);
	        }
	        else {
	            obj.reject_senders = [];
	        }
	        return obj;
	    }
	};
	function createBaseResponsePrepareProposal() {
	    return {
	        txs: []
	    };
	}
	exports.ResponsePrepareProposal = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.txs) {
	            writer.uint32(10).bytes(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponsePrepareProposal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txs.push(reader.bytes());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.txs = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponsePrepareProposal();
	        message.txs = object.txs?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e);
	        }
	        else {
	            obj.txs = [];
	        }
	        return obj;
	    }
	};
	function createBaseResponseProcessProposal() {
	    return {
	        status: 0
	    };
	}
	exports.ResponseProcessProposal = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.status !== 0) {
	            writer.uint32(8).int32(message.status);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseProcessProposal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.status = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            status: (0, helpers_1.isSet)(object.status) ? responseProcessProposal_ProposalStatusFromJSON(object.status) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.status !== undefined && (obj.status = responseProcessProposal_ProposalStatusToJSON(message.status));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseProcessProposal();
	        message.status = object.status ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            status: (0, helpers_1.isSet)(object.status) ? responseProcessProposal_ProposalStatusFromJSON(object.status) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.status !== undefined && (obj.status = responseProcessProposal_ProposalStatusToJSON(message.status));
	        return obj;
	    }
	};
	function createBaseResponseEthQuery() {
	    return {
	        code: 0,
	        log: "",
	        codespace: "",
	        response: new Uint8Array()
	    };
	}
	exports.ResponseEthQuery = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.code !== 0) {
	            writer.uint32(8).uint32(message.code);
	        }
	        if (message.log !== "") {
	            writer.uint32(18).string(message.log);
	        }
	        if (message.codespace !== "") {
	            writer.uint32(26).string(message.codespace);
	        }
	        if (message.response.length !== 0) {
	            writer.uint32(34).bytes(message.response);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResponseEthQuery();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.code = reader.uint32();
	                    break;
	                case 2:
	                    message.log = reader.string();
	                    break;
	                case 3:
	                    message.codespace = reader.string();
	                    break;
	                case 4:
	                    message.response = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            code: (0, helpers_1.isSet)(object.code) ? Number(object.code) : 0,
	            log: (0, helpers_1.isSet)(object.log) ? String(object.log) : "",
	            codespace: (0, helpers_1.isSet)(object.codespace) ? String(object.codespace) : "",
	            response: (0, helpers_1.isSet)(object.response) ? (0, helpers_1.bytesFromBase64)(object.response) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.code !== undefined && (obj.code = Math.round(message.code));
	        message.log !== undefined && (obj.log = message.log);
	        message.codespace !== undefined && (obj.codespace = message.codespace);
	        message.response !== undefined && (obj.response = (0, helpers_1.base64FromBytes)(message.response !== undefined ? message.response : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResponseEthQuery();
	        message.code = object.code ?? 0;
	        message.log = object.log ?? "";
	        message.codespace = object.codespace ?? "";
	        message.response = object.response ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            code: object?.code,
	            log: object?.log,
	            codespace: object?.codespace,
	            response: object?.response
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.code = message.code;
	        obj.log = message.log;
	        obj.codespace = message.codespace;
	        obj.response = message.response;
	        return obj;
	    }
	};
	function createBaseCommitInfo() {
	    return {
	        round: 0,
	        votes: []
	    };
	}
	exports.CommitInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.round !== 0) {
	            writer.uint32(8).int32(message.round);
	        }
	        for (const v of message.votes) {
	            exports.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseCommitInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.round = reader.int32();
	                    break;
	                case 2:
	                    message.votes.push(exports.VoteInfo.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            round: (0, helpers_1.isSet)(object.round) ? Number(object.round) : 0,
	            votes: Array.isArray(object?.votes) ? object.votes.map((e) => exports.VoteInfo.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.round !== undefined && (obj.round = Math.round(message.round));
	        if (message.votes) {
	            obj.votes = message.votes.map(e => e ? exports.VoteInfo.toJSON(e) : undefined);
	        }
	        else {
	            obj.votes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseCommitInfo();
	        message.round = object.round ?? 0;
	        message.votes = object.votes?.map(e => exports.VoteInfo.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            round: object?.round,
	            votes: Array.isArray(object?.votes) ? object.votes.map((e) => exports.VoteInfo.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.round = message.round;
	        if (message.votes) {
	            obj.votes = message.votes.map(e => e ? exports.VoteInfo.toSDK(e) : undefined);
	        }
	        else {
	            obj.votes = [];
	        }
	        return obj;
	    }
	};
	function createBaseExtendedCommitInfo() {
	    return {
	        round: 0,
	        votes: []
	    };
	}
	exports.ExtendedCommitInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.round !== 0) {
	            writer.uint32(8).int32(message.round);
	        }
	        for (const v of message.votes) {
	            exports.ExtendedVoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseExtendedCommitInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.round = reader.int32();
	                    break;
	                case 2:
	                    message.votes.push(exports.ExtendedVoteInfo.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            round: (0, helpers_1.isSet)(object.round) ? Number(object.round) : 0,
	            votes: Array.isArray(object?.votes) ? object.votes.map((e) => exports.ExtendedVoteInfo.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.round !== undefined && (obj.round = Math.round(message.round));
	        if (message.votes) {
	            obj.votes = message.votes.map(e => e ? exports.ExtendedVoteInfo.toJSON(e) : undefined);
	        }
	        else {
	            obj.votes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseExtendedCommitInfo();
	        message.round = object.round ?? 0;
	        message.votes = object.votes?.map(e => exports.ExtendedVoteInfo.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            round: object?.round,
	            votes: Array.isArray(object?.votes) ? object.votes.map((e) => exports.ExtendedVoteInfo.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.round = message.round;
	        if (message.votes) {
	            obj.votes = message.votes.map(e => e ? exports.ExtendedVoteInfo.toSDK(e) : undefined);
	        }
	        else {
	            obj.votes = [];
	        }
	        return obj;
	    }
	};
	function createBaseEvent() {
	    return {
	        type: "",
	        attributes: []
	    };
	}
	exports.Event = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== "") {
	            writer.uint32(10).string(message.type);
	        }
	        for (const v of message.attributes) {
	            exports.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseEvent();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.string();
	                    break;
	                case 2:
	                    message.attributes.push(exports.EventAttribute.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? String(object.type) : "",
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.EventAttribute.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = message.type);
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.EventAttribute.toJSON(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseEvent();
	        message.type = object.type ?? "";
	        message.attributes = object.attributes?.map(e => exports.EventAttribute.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: object?.type,
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.EventAttribute.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.type = message.type;
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.EventAttribute.toSDK(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    }
	};
	function createBaseEventAttribute() {
	    return {
	        key: "",
	        value: "",
	        index: false
	    };
	}
	exports.EventAttribute = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.key !== "") {
	            writer.uint32(10).string(message.key);
	        }
	        if (message.value !== "") {
	            writer.uint32(18).string(message.value);
	        }
	        if (message.index === true) {
	            writer.uint32(24).bool(message.index);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseEventAttribute();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.key = reader.string();
	                    break;
	                case 2:
	                    message.value = reader.string();
	                    break;
	                case 3:
	                    message.index = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            key: (0, helpers_1.isSet)(object.key) ? String(object.key) : "",
	            value: (0, helpers_1.isSet)(object.value) ? String(object.value) : "",
	            index: (0, helpers_1.isSet)(object.index) ? Boolean(object.index) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.key !== undefined && (obj.key = message.key);
	        message.value !== undefined && (obj.value = message.value);
	        message.index !== undefined && (obj.index = message.index);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseEventAttribute();
	        message.key = object.key ?? "";
	        message.value = object.value ?? "";
	        message.index = object.index ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            key: object?.key,
	            value: object?.value,
	            index: object?.index
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.key = message.key;
	        obj.value = message.value;
	        obj.index = message.index;
	        return obj;
	    }
	};
	function createBaseTxResult() {
	    return {
	        height: helpers_1.Long.ZERO,
	        index: 0,
	        tx: new Uint8Array(),
	        result: undefined
	    };
	}
	exports.TxResult = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        if (message.index !== 0) {
	            writer.uint32(16).uint32(message.index);
	        }
	        if (message.tx.length !== 0) {
	            writer.uint32(26).bytes(message.tx);
	        }
	        if (message.result !== undefined) {
	            exports.ResponseDeliverTx.encode(message.result, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxResult();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                case 2:
	                    message.index = reader.uint32();
	                    break;
	                case 3:
	                    message.tx = reader.bytes();
	                    break;
	                case 4:
	                    message.result = exports.ResponseDeliverTx.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            index: (0, helpers_1.isSet)(object.index) ? Number(object.index) : 0,
	            tx: (0, helpers_1.isSet)(object.tx) ? (0, helpers_1.bytesFromBase64)(object.tx) : new Uint8Array(),
	            result: (0, helpers_1.isSet)(object.result) ? exports.ResponseDeliverTx.fromJSON(object.result) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.index !== undefined && (obj.index = Math.round(message.index));
	        message.tx !== undefined && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== undefined ? message.tx : new Uint8Array()));
	        message.result !== undefined && (obj.result = message.result ? exports.ResponseDeliverTx.toJSON(message.result) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxResult();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.index = object.index ?? 0;
	        message.tx = object.tx ?? new Uint8Array();
	        message.result = object.result !== undefined && object.result !== null ? exports.ResponseDeliverTx.fromPartial(object.result) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            index: object?.index,
	            tx: object?.tx,
	            result: object.result ? exports.ResponseDeliverTx.fromSDK(object.result) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        obj.index = message.index;
	        obj.tx = message.tx;
	        message.result !== undefined && (obj.result = message.result ? exports.ResponseDeliverTx.toSDK(message.result) : undefined);
	        return obj;
	    }
	};
	function createBaseValidator() {
	    return {
	        address: new Uint8Array(),
	        power: helpers_1.Long.ZERO
	    };
	}
	exports.Validator = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address.length !== 0) {
	            writer.uint32(10).bytes(message.address);
	        }
	        if (!message.power.isZero()) {
	            writer.uint32(24).int64(message.power);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidator();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.bytes();
	                    break;
	                case 3:
	                    message.power = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? (0, helpers_1.bytesFromBase64)(object.address) : new Uint8Array(),
	            power: (0, helpers_1.isSet)(object.power) ? helpers_1.Long.fromValue(object.power) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== undefined ? message.address : new Uint8Array()));
	        message.power !== undefined && (obj.power = (message.power || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidator();
	        message.address = object.address ?? new Uint8Array();
	        message.power = object.power !== undefined && object.power !== null ? helpers_1.Long.fromValue(object.power) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            power: object?.power
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        obj.power = message.power;
	        return obj;
	    }
	};
	function createBaseValidatorUpdate() {
	    return {
	        pubKey: undefined,
	        power: helpers_1.Long.ZERO
	    };
	}
	exports.ValidatorUpdate = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pubKey !== undefined) {
	            keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
	        }
	        if (!message.power.isZero()) {
	            writer.uint32(16).int64(message.power);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorUpdate();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.power = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pubKey: (0, helpers_1.isSet)(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : undefined,
	            power: (0, helpers_1.isSet)(object.power) ? helpers_1.Long.fromValue(object.power) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : undefined);
	        message.power !== undefined && (obj.power = (message.power || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorUpdate();
	        message.pubKey = object.pubKey !== undefined && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : undefined;
	        message.power = object.power !== undefined && object.power !== null ? helpers_1.Long.fromValue(object.power) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pubKey: object.pub_key ? keys_1.PublicKey.fromSDK(object.pub_key) : undefined,
	            power: object?.power
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pubKey !== undefined && (obj.pub_key = message.pubKey ? keys_1.PublicKey.toSDK(message.pubKey) : undefined);
	        obj.power = message.power;
	        return obj;
	    }
	};
	function createBaseVoteInfo() {
	    return {
	        validator: undefined,
	        signedLastBlock: false
	    };
	}
	exports.VoteInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.validator !== undefined) {
	            exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.signedLastBlock === true) {
	            writer.uint32(16).bool(message.signedLastBlock);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseVoteInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validator = exports.Validator.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.signedLastBlock = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validator: (0, helpers_1.isSet)(object.validator) ? exports.Validator.fromJSON(object.validator) : undefined,
	            signedLastBlock: (0, helpers_1.isSet)(object.signedLastBlock) ? Boolean(object.signedLastBlock) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);
	        message.signedLastBlock !== undefined && (obj.signedLastBlock = message.signedLastBlock);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseVoteInfo();
	        message.validator = object.validator !== undefined && object.validator !== null ? exports.Validator.fromPartial(object.validator) : undefined;
	        message.signedLastBlock = object.signedLastBlock ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validator: object.validator ? exports.Validator.fromSDK(object.validator) : undefined,
	            signedLastBlock: object?.signed_last_block
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toSDK(message.validator) : undefined);
	        obj.signed_last_block = message.signedLastBlock;
	        return obj;
	    }
	};
	function createBaseExtendedVoteInfo() {
	    return {
	        validator: undefined,
	        signedLastBlock: false,
	        voteExtension: new Uint8Array()
	    };
	}
	exports.ExtendedVoteInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.validator !== undefined) {
	            exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.signedLastBlock === true) {
	            writer.uint32(16).bool(message.signedLastBlock);
	        }
	        if (message.voteExtension.length !== 0) {
	            writer.uint32(26).bytes(message.voteExtension);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseExtendedVoteInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validator = exports.Validator.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.signedLastBlock = reader.bool();
	                    break;
	                case 3:
	                    message.voteExtension = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validator: (0, helpers_1.isSet)(object.validator) ? exports.Validator.fromJSON(object.validator) : undefined,
	            signedLastBlock: (0, helpers_1.isSet)(object.signedLastBlock) ? Boolean(object.signedLastBlock) : false,
	            voteExtension: (0, helpers_1.isSet)(object.voteExtension) ? (0, helpers_1.bytesFromBase64)(object.voteExtension) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);
	        message.signedLastBlock !== undefined && (obj.signedLastBlock = message.signedLastBlock);
	        message.voteExtension !== undefined && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== undefined ? message.voteExtension : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseExtendedVoteInfo();
	        message.validator = object.validator !== undefined && object.validator !== null ? exports.Validator.fromPartial(object.validator) : undefined;
	        message.signedLastBlock = object.signedLastBlock ?? false;
	        message.voteExtension = object.voteExtension ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validator: object.validator ? exports.Validator.fromSDK(object.validator) : undefined,
	            signedLastBlock: object?.signed_last_block,
	            voteExtension: object?.vote_extension
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toSDK(message.validator) : undefined);
	        obj.signed_last_block = message.signedLastBlock;
	        obj.vote_extension = message.voteExtension;
	        return obj;
	    }
	};
	function createBaseMisbehavior() {
	    return {
	        type: 0,
	        validator: undefined,
	        height: helpers_1.Long.ZERO,
	        time: undefined,
	        totalVotingPower: helpers_1.Long.ZERO
	    };
	}
	exports.Misbehavior = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== 0) {
	            writer.uint32(8).int32(message.type);
	        }
	        if (message.validator !== undefined) {
	            exports.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(24).int64(message.height);
	        }
	        if (message.time !== undefined) {
	            timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
	        }
	        if (!message.totalVotingPower.isZero()) {
	            writer.uint32(40).int64(message.totalVotingPower);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMisbehavior();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.int32();
	                    break;
	                case 2:
	                    message.validator = exports.Validator.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.height = reader.int64();
	                    break;
	                case 4:
	                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 5:
	                    message.totalVotingPower = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? misbehaviorTypeFromJSON(object.type) : 0,
	            validator: (0, helpers_1.isSet)(object.validator) ? exports.Validator.fromJSON(object.validator) : undefined,
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            time: (0, helpers_1.isSet)(object.time) ? (0, helpers_1.fromJsonTimestamp)(object.time) : undefined,
	            totalVotingPower: (0, helpers_1.isSet)(object.totalVotingPower) ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = misbehaviorTypeToJSON(message.type));
	        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
	        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMisbehavior();
	        message.type = object.type ?? 0;
	        message.validator = object.validator !== undefined && object.validator !== null ? exports.Validator.fromPartial(object.validator) : undefined;
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.time = object.time !== undefined && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : undefined;
	        message.totalVotingPower = object.totalVotingPower !== undefined && object.totalVotingPower !== null ? helpers_1.Long.fromValue(object.totalVotingPower) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? misbehaviorTypeFromJSON(object.type) : 0,
	            validator: object.validator ? exports.Validator.fromSDK(object.validator) : undefined,
	            height: object?.height,
	            time: object.time ? timestamp_1.Timestamp.fromSDK(object.time) : undefined,
	            totalVotingPower: object?.total_voting_power
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = misbehaviorTypeToJSON(message.type));
	        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toSDK(message.validator) : undefined);
	        obj.height = message.height;
	        message.time !== undefined && (obj.time = message.time ? timestamp_1.Timestamp.toSDK(message.time) : undefined);
	        obj.total_voting_power = message.totalVotingPower;
	        return obj;
	    }
	};
	function createBaseSnapshot() {
	    return {
	        height: helpers_1.Long.UZERO,
	        format: 0,
	        chunks: 0,
	        hash: new Uint8Array(),
	        metadata: new Uint8Array()
	    };
	}
	exports.Snapshot = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).uint64(message.height);
	        }
	        if (message.format !== 0) {
	            writer.uint32(16).uint32(message.format);
	        }
	        if (message.chunks !== 0) {
	            writer.uint32(24).uint32(message.chunks);
	        }
	        if (message.hash.length !== 0) {
	            writer.uint32(34).bytes(message.hash);
	        }
	        if (message.metadata.length !== 0) {
	            writer.uint32(42).bytes(message.metadata);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSnapshot();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.uint64();
	                    break;
	                case 2:
	                    message.format = reader.uint32();
	                    break;
	                case 3:
	                    message.chunks = reader.uint32();
	                    break;
	                case 4:
	                    message.hash = reader.bytes();
	                    break;
	                case 5:
	                    message.metadata = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO,
	            format: (0, helpers_1.isSet)(object.format) ? Number(object.format) : 0,
	            chunks: (0, helpers_1.isSet)(object.chunks) ? Number(object.chunks) : 0,
	            hash: (0, helpers_1.isSet)(object.hash) ? (0, helpers_1.bytesFromBase64)(object.hash) : new Uint8Array(),
	            metadata: (0, helpers_1.isSet)(object.metadata) ? (0, helpers_1.bytesFromBase64)(object.metadata) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.UZERO).toString());
	        message.format !== undefined && (obj.format = Math.round(message.format));
	        message.chunks !== undefined && (obj.chunks = Math.round(message.chunks));
	        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
	        message.metadata !== undefined && (obj.metadata = (0, helpers_1.base64FromBytes)(message.metadata !== undefined ? message.metadata : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSnapshot();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO;
	        message.format = object.format ?? 0;
	        message.chunks = object.chunks ?? 0;
	        message.hash = object.hash ?? new Uint8Array();
	        message.metadata = object.metadata ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            format: object?.format,
	            chunks: object?.chunks,
	            hash: object?.hash,
	            metadata: object?.metadata
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        obj.format = message.format;
	        obj.chunks = message.chunks;
	        obj.hash = message.hash;
	        obj.metadata = message.metadata;
	        return obj;
	    }
	};
	class ABCIApplicationClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Echo = this.Echo.bind(this);
	        this.Flush = this.Flush.bind(this);
	        this.Info = this.Info.bind(this);
	        this.DeliverTx = this.DeliverTx.bind(this);
	        this.CheckTx = this.CheckTx.bind(this);
	        this.Query = this.Query.bind(this);
	        this.Commit = this.Commit.bind(this);
	        this.InitChain = this.InitChain.bind(this);
	        this.BeginBlock = this.BeginBlock.bind(this);
	        this.EndBlock = this.EndBlock.bind(this);
	        this.ListSnapshots = this.ListSnapshots.bind(this);
	        this.OfferSnapshot = this.OfferSnapshot.bind(this);
	        this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this);
	        this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this);
	        this.PrepareProposal = this.PrepareProposal.bind(this);
	        this.ProcessProposal = this.ProcessProposal.bind(this);
	        this.EthQuery = this.EthQuery.bind(this);
	    }
	    Echo(request) {
	        const data = exports.RequestEcho.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Echo", data);
	        return promise.then(data => exports.ResponseEcho.decode(new _m0.Reader(data)));
	    }
	    Flush(request = {}) {
	        const data = exports.RequestFlush.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Flush", data);
	        return promise.then(data => exports.ResponseFlush.decode(new _m0.Reader(data)));
	    }
	    Info(request) {
	        const data = exports.RequestInfo.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Info", data);
	        return promise.then(data => exports.ResponseInfo.decode(new _m0.Reader(data)));
	    }
	    DeliverTx(request) {
	        const data = exports.RequestDeliverTx.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", data);
	        return promise.then(data => exports.ResponseDeliverTx.decode(new _m0.Reader(data)));
	    }
	    CheckTx(request) {
	        const data = exports.RequestCheckTx.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", data);
	        return promise.then(data => exports.ResponseCheckTx.decode(new _m0.Reader(data)));
	    }
	    Query(request) {
	        const data = exports.RequestQuery.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Query", data);
	        return promise.then(data => exports.ResponseQuery.decode(new _m0.Reader(data)));
	    }
	    Commit(request = {}) {
	        const data = exports.RequestCommit.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Commit", data);
	        return promise.then(data => exports.ResponseCommit.decode(new _m0.Reader(data)));
	    }
	    InitChain(request) {
	        const data = exports.RequestInitChain.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", data);
	        return promise.then(data => exports.ResponseInitChain.decode(new _m0.Reader(data)));
	    }
	    BeginBlock(request) {
	        const data = exports.RequestBeginBlock.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", data);
	        return promise.then(data => exports.ResponseBeginBlock.decode(new _m0.Reader(data)));
	    }
	    EndBlock(request) {
	        const data = exports.RequestEndBlock.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", data);
	        return promise.then(data => exports.ResponseEndBlock.decode(new _m0.Reader(data)));
	    }
	    ListSnapshots(request = {}) {
	        const data = exports.RequestListSnapshots.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", data);
	        return promise.then(data => exports.ResponseListSnapshots.decode(new _m0.Reader(data)));
	    }
	    OfferSnapshot(request) {
	        const data = exports.RequestOfferSnapshot.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", data);
	        return promise.then(data => exports.ResponseOfferSnapshot.decode(new _m0.Reader(data)));
	    }
	    LoadSnapshotChunk(request) {
	        const data = exports.RequestLoadSnapshotChunk.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", data);
	        return promise.then(data => exports.ResponseLoadSnapshotChunk.decode(new _m0.Reader(data)));
	    }
	    ApplySnapshotChunk(request) {
	        const data = exports.RequestApplySnapshotChunk.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", data);
	        return promise.then(data => exports.ResponseApplySnapshotChunk.decode(new _m0.Reader(data)));
	    }
	    PrepareProposal(request) {
	        const data = exports.RequestPrepareProposal.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "PrepareProposal", data);
	        return promise.then(data => exports.ResponsePrepareProposal.decode(new _m0.Reader(data)));
	    }
	    ProcessProposal(request) {
	        const data = exports.RequestProcessProposal.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ProcessProposal", data);
	        return promise.then(data => exports.ResponseProcessProposal.decode(new _m0.Reader(data)));
	    }
	    EthQuery(request) {
	        const data = exports.RequestEthQuery.encode(request).finish();
	        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "EthQuery", data);
	        return promise.then(data => exports.ResponseEthQuery.decode(new _m0.Reader(data)));
	    }
	}
	exports.ABCIApplicationClientImpl = ABCIApplicationClientImpl;
	
} (types$5));

types$5.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SearchTxsResult = exports.TxMsgData = exports.MsgData = exports.SimulationResponse = exports.Result = exports.GasInfo = exports.Attribute = exports.StringEvent = exports.ABCIMessageLog = exports.TxResponse = exports.protobufPackage = void 0;
	/* eslint-disable */
	const any_1 = any;
	const types_1 = types$5;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "cosmos.base.abci.v1beta1";
	function createBaseTxResponse() {
	    return {
	        height: helpers_1.Long.ZERO,
	        txhash: "",
	        codespace: "",
	        code: 0,
	        data: "",
	        rawLog: "",
	        logs: [],
	        info: "",
	        gasWanted: helpers_1.Long.ZERO,
	        gasUsed: helpers_1.Long.ZERO,
	        tx: undefined,
	        timestamp: "",
	        events: []
	    };
	}
	exports.TxResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        if (message.txhash !== "") {
	            writer.uint32(18).string(message.txhash);
	        }
	        if (message.codespace !== "") {
	            writer.uint32(26).string(message.codespace);
	        }
	        if (message.code !== 0) {
	            writer.uint32(32).uint32(message.code);
	        }
	        if (message.data !== "") {
	            writer.uint32(42).string(message.data);
	        }
	        if (message.rawLog !== "") {
	            writer.uint32(50).string(message.rawLog);
	        }
	        for (const v of message.logs) {
	            exports.ABCIMessageLog.encode(v, writer.uint32(58).fork()).ldelim();
	        }
	        if (message.info !== "") {
	            writer.uint32(66).string(message.info);
	        }
	        if (!message.gasWanted.isZero()) {
	            writer.uint32(72).int64(message.gasWanted);
	        }
	        if (!message.gasUsed.isZero()) {
	            writer.uint32(80).int64(message.gasUsed);
	        }
	        if (message.tx !== undefined) {
	            any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
	        }
	        if (message.timestamp !== "") {
	            writer.uint32(98).string(message.timestamp);
	        }
	        for (const v of message.events) {
	            types_1.Event.encode(v, writer.uint32(106).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                case 2:
	                    message.txhash = reader.string();
	                    break;
	                case 3:
	                    message.codespace = reader.string();
	                    break;
	                case 4:
	                    message.code = reader.uint32();
	                    break;
	                case 5:
	                    message.data = reader.string();
	                    break;
	                case 6:
	                    message.rawLog = reader.string();
	                    break;
	                case 7:
	                    message.logs.push(exports.ABCIMessageLog.decode(reader, reader.uint32()));
	                    break;
	                case 8:
	                    message.info = reader.string();
	                    break;
	                case 9:
	                    message.gasWanted = reader.int64();
	                    break;
	                case 10:
	                    message.gasUsed = reader.int64();
	                    break;
	                case 11:
	                    message.tx = any_1.Any.decode(reader, reader.uint32());
	                    break;
	                case 12:
	                    message.timestamp = reader.string();
	                    break;
	                case 13:
	                    message.events.push(types_1.Event.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            txhash: (0, helpers_1.isSet)(object.txhash) ? String(object.txhash) : "",
	            codespace: (0, helpers_1.isSet)(object.codespace) ? String(object.codespace) : "",
	            code: (0, helpers_1.isSet)(object.code) ? Number(object.code) : 0,
	            data: (0, helpers_1.isSet)(object.data) ? String(object.data) : "",
	            rawLog: (0, helpers_1.isSet)(object.rawLog) ? String(object.rawLog) : "",
	            logs: Array.isArray(object?.logs) ? object.logs.map((e) => exports.ABCIMessageLog.fromJSON(e)) : [],
	            info: (0, helpers_1.isSet)(object.info) ? String(object.info) : "",
	            gasWanted: (0, helpers_1.isSet)(object.gasWanted) ? helpers_1.Long.fromValue(object.gasWanted) : helpers_1.Long.ZERO,
	            gasUsed: (0, helpers_1.isSet)(object.gasUsed) ? helpers_1.Long.fromValue(object.gasUsed) : helpers_1.Long.ZERO,
	            tx: (0, helpers_1.isSet)(object.tx) ? any_1.Any.fromJSON(object.tx) : undefined,
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? String(object.timestamp) : "",
	            events: Array.isArray(object?.events) ? object.events.map((e) => types_1.Event.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.txhash !== undefined && (obj.txhash = message.txhash);
	        message.codespace !== undefined && (obj.codespace = message.codespace);
	        message.code !== undefined && (obj.code = Math.round(message.code));
	        message.data !== undefined && (obj.data = message.data);
	        message.rawLog !== undefined && (obj.rawLog = message.rawLog);
	        if (message.logs) {
	            obj.logs = message.logs.map(e => e ? exports.ABCIMessageLog.toJSON(e) : undefined);
	        }
	        else {
	            obj.logs = [];
	        }
	        message.info !== undefined && (obj.info = message.info);
	        message.gasWanted !== undefined && (obj.gasWanted = (message.gasWanted || helpers_1.Long.ZERO).toString());
	        message.gasUsed !== undefined && (obj.gasUsed = (message.gasUsed || helpers_1.Long.ZERO).toString());
	        message.tx !== undefined && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : undefined);
	        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
	        if (message.events) {
	            obj.events = message.events.map(e => e ? types_1.Event.toJSON(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxResponse();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.txhash = object.txhash ?? "";
	        message.codespace = object.codespace ?? "";
	        message.code = object.code ?? 0;
	        message.data = object.data ?? "";
	        message.rawLog = object.rawLog ?? "";
	        message.logs = object.logs?.map(e => exports.ABCIMessageLog.fromPartial(e)) || [];
	        message.info = object.info ?? "";
	        message.gasWanted = object.gasWanted !== undefined && object.gasWanted !== null ? helpers_1.Long.fromValue(object.gasWanted) : helpers_1.Long.ZERO;
	        message.gasUsed = object.gasUsed !== undefined && object.gasUsed !== null ? helpers_1.Long.fromValue(object.gasUsed) : helpers_1.Long.ZERO;
	        message.tx = object.tx !== undefined && object.tx !== null ? any_1.Any.fromPartial(object.tx) : undefined;
	        message.timestamp = object.timestamp ?? "";
	        message.events = object.events?.map(e => types_1.Event.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            txhash: object?.txhash,
	            codespace: object?.codespace,
	            code: object?.code,
	            data: object?.data,
	            rawLog: object?.raw_log,
	            logs: Array.isArray(object?.logs) ? object.logs.map((e) => exports.ABCIMessageLog.fromSDK(e)) : [],
	            info: object?.info,
	            gasWanted: object?.gas_wanted,
	            gasUsed: object?.gas_used,
	            tx: object.tx ? any_1.Any.fromSDK(object.tx) : undefined,
	            timestamp: object?.timestamp,
	            events: Array.isArray(object?.events) ? object.events.map((e) => types_1.Event.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        obj.txhash = message.txhash;
	        obj.codespace = message.codespace;
	        obj.code = message.code;
	        obj.data = message.data;
	        obj.raw_log = message.rawLog;
	        if (message.logs) {
	            obj.logs = message.logs.map(e => e ? exports.ABCIMessageLog.toSDK(e) : undefined);
	        }
	        else {
	            obj.logs = [];
	        }
	        obj.info = message.info;
	        obj.gas_wanted = message.gasWanted;
	        obj.gas_used = message.gasUsed;
	        message.tx !== undefined && (obj.tx = message.tx ? any_1.Any.toSDK(message.tx) : undefined);
	        obj.timestamp = message.timestamp;
	        if (message.events) {
	            obj.events = message.events.map(e => e ? types_1.Event.toSDK(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    }
	};
	function createBaseABCIMessageLog() {
	    return {
	        msgIndex: 0,
	        log: "",
	        events: []
	    };
	}
	exports.ABCIMessageLog = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.msgIndex !== 0) {
	            writer.uint32(8).uint32(message.msgIndex);
	        }
	        if (message.log !== "") {
	            writer.uint32(18).string(message.log);
	        }
	        for (const v of message.events) {
	            exports.StringEvent.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseABCIMessageLog();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.msgIndex = reader.uint32();
	                    break;
	                case 2:
	                    message.log = reader.string();
	                    break;
	                case 3:
	                    message.events.push(exports.StringEvent.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            msgIndex: (0, helpers_1.isSet)(object.msgIndex) ? Number(object.msgIndex) : 0,
	            log: (0, helpers_1.isSet)(object.log) ? String(object.log) : "",
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.StringEvent.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.msgIndex !== undefined && (obj.msgIndex = Math.round(message.msgIndex));
	        message.log !== undefined && (obj.log = message.log);
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.StringEvent.toJSON(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseABCIMessageLog();
	        message.msgIndex = object.msgIndex ?? 0;
	        message.log = object.log ?? "";
	        message.events = object.events?.map(e => exports.StringEvent.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            msgIndex: object?.msg_index,
	            log: object?.log,
	            events: Array.isArray(object?.events) ? object.events.map((e) => exports.StringEvent.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.msg_index = message.msgIndex;
	        obj.log = message.log;
	        if (message.events) {
	            obj.events = message.events.map(e => e ? exports.StringEvent.toSDK(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        return obj;
	    }
	};
	function createBaseStringEvent() {
	    return {
	        type: "",
	        attributes: []
	    };
	}
	exports.StringEvent = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== "") {
	            writer.uint32(10).string(message.type);
	        }
	        for (const v of message.attributes) {
	            exports.Attribute.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseStringEvent();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.string();
	                    break;
	                case 2:
	                    message.attributes.push(exports.Attribute.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? String(object.type) : "",
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Attribute.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = message.type);
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Attribute.toJSON(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseStringEvent();
	        message.type = object.type ?? "";
	        message.attributes = object.attributes?.map(e => exports.Attribute.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: object?.type,
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Attribute.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.type = message.type;
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Attribute.toSDK(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    }
	};
	function createBaseAttribute() {
	    return {
	        key: "",
	        value: ""
	    };
	}
	exports.Attribute = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.key !== "") {
	            writer.uint32(10).string(message.key);
	        }
	        if (message.value !== "") {
	            writer.uint32(18).string(message.value);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAttribute();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.key = reader.string();
	                    break;
	                case 2:
	                    message.value = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            key: (0, helpers_1.isSet)(object.key) ? String(object.key) : "",
	            value: (0, helpers_1.isSet)(object.value) ? String(object.value) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.key !== undefined && (obj.key = message.key);
	        message.value !== undefined && (obj.value = message.value);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAttribute();
	        message.key = object.key ?? "";
	        message.value = object.value ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            key: object?.key,
	            value: object?.value
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.key = message.key;
	        obj.value = message.value;
	        return obj;
	    }
	};
	function createBaseGasInfo() {
	    return {
	        gasWanted: helpers_1.Long.UZERO,
	        gasUsed: helpers_1.Long.UZERO,
	        minGasPrice: ""
	    };
	}
	exports.GasInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.gasWanted.isZero()) {
	            writer.uint32(8).uint64(message.gasWanted);
	        }
	        if (!message.gasUsed.isZero()) {
	            writer.uint32(16).uint64(message.gasUsed);
	        }
	        if (message.minGasPrice !== "") {
	            writer.uint32(26).string(message.minGasPrice);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGasInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.gasWanted = reader.uint64();
	                    break;
	                case 2:
	                    message.gasUsed = reader.uint64();
	                    break;
	                case 3:
	                    message.minGasPrice = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            gasWanted: (0, helpers_1.isSet)(object.gasWanted) ? helpers_1.Long.fromValue(object.gasWanted) : helpers_1.Long.UZERO,
	            gasUsed: (0, helpers_1.isSet)(object.gasUsed) ? helpers_1.Long.fromValue(object.gasUsed) : helpers_1.Long.UZERO,
	            minGasPrice: (0, helpers_1.isSet)(object.minGasPrice) ? String(object.minGasPrice) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.gasWanted !== undefined && (obj.gasWanted = (message.gasWanted || helpers_1.Long.UZERO).toString());
	        message.gasUsed !== undefined && (obj.gasUsed = (message.gasUsed || helpers_1.Long.UZERO).toString());
	        message.minGasPrice !== undefined && (obj.minGasPrice = message.minGasPrice);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGasInfo();
	        message.gasWanted = object.gasWanted !== undefined && object.gasWanted !== null ? helpers_1.Long.fromValue(object.gasWanted) : helpers_1.Long.UZERO;
	        message.gasUsed = object.gasUsed !== undefined && object.gasUsed !== null ? helpers_1.Long.fromValue(object.gasUsed) : helpers_1.Long.UZERO;
	        message.minGasPrice = object.minGasPrice ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            gasWanted: object?.gas_wanted,
	            gasUsed: object?.gas_used,
	            minGasPrice: object?.min_gas_price
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.gas_wanted = message.gasWanted;
	        obj.gas_used = message.gasUsed;
	        obj.min_gas_price = message.minGasPrice;
	        return obj;
	    }
	};
	function createBaseResult() {
	    return {
	        data: new Uint8Array(),
	        log: "",
	        events: [],
	        msgResponses: []
	    };
	}
	exports.Result = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.data.length !== 0) {
	            writer.uint32(10).bytes(message.data);
	        }
	        if (message.log !== "") {
	            writer.uint32(18).string(message.log);
	        }
	        for (const v of message.events) {
	            types_1.Event.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        for (const v of message.msgResponses) {
	            any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseResult();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.data = reader.bytes();
	                    break;
	                case 2:
	                    message.log = reader.string();
	                    break;
	                case 3:
	                    message.events.push(types_1.Event.decode(reader, reader.uint32()));
	                    break;
	                case 4:
	                    message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array(),
	            log: (0, helpers_1.isSet)(object.log) ? String(object.log) : "",
	            events: Array.isArray(object?.events) ? object.events.map((e) => types_1.Event.fromJSON(e)) : [],
	            msgResponses: Array.isArray(object?.msgResponses) ? object.msgResponses.map((e) => any_1.Any.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        message.log !== undefined && (obj.log = message.log);
	        if (message.events) {
	            obj.events = message.events.map(e => e ? types_1.Event.toJSON(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        if (message.msgResponses) {
	            obj.msgResponses = message.msgResponses.map(e => e ? any_1.Any.toJSON(e) : undefined);
	        }
	        else {
	            obj.msgResponses = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseResult();
	        message.data = object.data ?? new Uint8Array();
	        message.log = object.log ?? "";
	        message.events = object.events?.map(e => types_1.Event.fromPartial(e)) || [];
	        message.msgResponses = object.msgResponses?.map(e => any_1.Any.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            data: object?.data,
	            log: object?.log,
	            events: Array.isArray(object?.events) ? object.events.map((e) => types_1.Event.fromSDK(e)) : [],
	            msgResponses: Array.isArray(object?.msg_responses) ? object.msg_responses.map((e) => any_1.Any.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.data = message.data;
	        obj.log = message.log;
	        if (message.events) {
	            obj.events = message.events.map(e => e ? types_1.Event.toSDK(e) : undefined);
	        }
	        else {
	            obj.events = [];
	        }
	        if (message.msgResponses) {
	            obj.msg_responses = message.msgResponses.map(e => e ? any_1.Any.toSDK(e) : undefined);
	        }
	        else {
	            obj.msg_responses = [];
	        }
	        return obj;
	    }
	};
	function createBaseSimulationResponse() {
	    return {
	        gasInfo: undefined,
	        result: undefined
	    };
	}
	exports.SimulationResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.gasInfo !== undefined) {
	            exports.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.result !== undefined) {
	            exports.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSimulationResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.gasInfo = exports.GasInfo.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.result = exports.Result.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            gasInfo: (0, helpers_1.isSet)(object.gasInfo) ? exports.GasInfo.fromJSON(object.gasInfo) : undefined,
	            result: (0, helpers_1.isSet)(object.result) ? exports.Result.fromJSON(object.result) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.gasInfo !== undefined && (obj.gasInfo = message.gasInfo ? exports.GasInfo.toJSON(message.gasInfo) : undefined);
	        message.result !== undefined && (obj.result = message.result ? exports.Result.toJSON(message.result) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSimulationResponse();
	        message.gasInfo = object.gasInfo !== undefined && object.gasInfo !== null ? exports.GasInfo.fromPartial(object.gasInfo) : undefined;
	        message.result = object.result !== undefined && object.result !== null ? exports.Result.fromPartial(object.result) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            gasInfo: object.gas_info ? exports.GasInfo.fromSDK(object.gas_info) : undefined,
	            result: object.result ? exports.Result.fromSDK(object.result) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.gasInfo !== undefined && (obj.gas_info = message.gasInfo ? exports.GasInfo.toSDK(message.gasInfo) : undefined);
	        message.result !== undefined && (obj.result = message.result ? exports.Result.toSDK(message.result) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgData() {
	    return {
	        msgType: "",
	        data: new Uint8Array()
	    };
	}
	exports.MsgData = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.msgType !== "") {
	            writer.uint32(10).string(message.msgType);
	        }
	        if (message.data.length !== 0) {
	            writer.uint32(18).bytes(message.data);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgData();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.msgType = reader.string();
	                    break;
	                case 2:
	                    message.data = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            msgType: (0, helpers_1.isSet)(object.msgType) ? String(object.msgType) : "",
	            data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.msgType !== undefined && (obj.msgType = message.msgType);
	        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgData();
	        message.msgType = object.msgType ?? "";
	        message.data = object.data ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            msgType: object?.msg_type,
	            data: object?.data
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.msg_type = message.msgType;
	        obj.data = message.data;
	        return obj;
	    }
	};
	function createBaseTxMsgData() {
	    return {
	        data: [],
	        msgResponses: []
	    };
	}
	exports.TxMsgData = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.data) {
	            exports.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        for (const v of message.msgResponses) {
	            any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxMsgData();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.data.push(exports.MsgData.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            data: Array.isArray(object?.data) ? object.data.map((e) => exports.MsgData.fromJSON(e)) : [],
	            msgResponses: Array.isArray(object?.msgResponses) ? object.msgResponses.map((e) => any_1.Any.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.data) {
	            obj.data = message.data.map(e => e ? exports.MsgData.toJSON(e) : undefined);
	        }
	        else {
	            obj.data = [];
	        }
	        if (message.msgResponses) {
	            obj.msgResponses = message.msgResponses.map(e => e ? any_1.Any.toJSON(e) : undefined);
	        }
	        else {
	            obj.msgResponses = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxMsgData();
	        message.data = object.data?.map(e => exports.MsgData.fromPartial(e)) || [];
	        message.msgResponses = object.msgResponses?.map(e => any_1.Any.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            data: Array.isArray(object?.data) ? object.data.map((e) => exports.MsgData.fromSDK(e)) : [],
	            msgResponses: Array.isArray(object?.msg_responses) ? object.msg_responses.map((e) => any_1.Any.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.data) {
	            obj.data = message.data.map(e => e ? exports.MsgData.toSDK(e) : undefined);
	        }
	        else {
	            obj.data = [];
	        }
	        if (message.msgResponses) {
	            obj.msg_responses = message.msgResponses.map(e => e ? any_1.Any.toSDK(e) : undefined);
	        }
	        else {
	            obj.msg_responses = [];
	        }
	        return obj;
	    }
	};
	function createBaseSearchTxsResult() {
	    return {
	        totalCount: helpers_1.Long.UZERO,
	        count: helpers_1.Long.UZERO,
	        pageNumber: helpers_1.Long.UZERO,
	        pageTotal: helpers_1.Long.UZERO,
	        limit: helpers_1.Long.UZERO,
	        txs: []
	    };
	}
	exports.SearchTxsResult = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.totalCount.isZero()) {
	            writer.uint32(8).uint64(message.totalCount);
	        }
	        if (!message.count.isZero()) {
	            writer.uint32(16).uint64(message.count);
	        }
	        if (!message.pageNumber.isZero()) {
	            writer.uint32(24).uint64(message.pageNumber);
	        }
	        if (!message.pageTotal.isZero()) {
	            writer.uint32(32).uint64(message.pageTotal);
	        }
	        if (!message.limit.isZero()) {
	            writer.uint32(40).uint64(message.limit);
	        }
	        for (const v of message.txs) {
	            exports.TxResponse.encode(v, writer.uint32(50).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSearchTxsResult();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.totalCount = reader.uint64();
	                    break;
	                case 2:
	                    message.count = reader.uint64();
	                    break;
	                case 3:
	                    message.pageNumber = reader.uint64();
	                    break;
	                case 4:
	                    message.pageTotal = reader.uint64();
	                    break;
	                case 5:
	                    message.limit = reader.uint64();
	                    break;
	                case 6:
	                    message.txs.push(exports.TxResponse.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            totalCount: (0, helpers_1.isSet)(object.totalCount) ? helpers_1.Long.fromValue(object.totalCount) : helpers_1.Long.UZERO,
	            count: (0, helpers_1.isSet)(object.count) ? helpers_1.Long.fromValue(object.count) : helpers_1.Long.UZERO,
	            pageNumber: (0, helpers_1.isSet)(object.pageNumber) ? helpers_1.Long.fromValue(object.pageNumber) : helpers_1.Long.UZERO,
	            pageTotal: (0, helpers_1.isSet)(object.pageTotal) ? helpers_1.Long.fromValue(object.pageTotal) : helpers_1.Long.UZERO,
	            limit: (0, helpers_1.isSet)(object.limit) ? helpers_1.Long.fromValue(object.limit) : helpers_1.Long.UZERO,
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => exports.TxResponse.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.totalCount !== undefined && (obj.totalCount = (message.totalCount || helpers_1.Long.UZERO).toString());
	        message.count !== undefined && (obj.count = (message.count || helpers_1.Long.UZERO).toString());
	        message.pageNumber !== undefined && (obj.pageNumber = (message.pageNumber || helpers_1.Long.UZERO).toString());
	        message.pageTotal !== undefined && (obj.pageTotal = (message.pageTotal || helpers_1.Long.UZERO).toString());
	        message.limit !== undefined && (obj.limit = (message.limit || helpers_1.Long.UZERO).toString());
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e ? exports.TxResponse.toJSON(e) : undefined);
	        }
	        else {
	            obj.txs = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSearchTxsResult();
	        message.totalCount = object.totalCount !== undefined && object.totalCount !== null ? helpers_1.Long.fromValue(object.totalCount) : helpers_1.Long.UZERO;
	        message.count = object.count !== undefined && object.count !== null ? helpers_1.Long.fromValue(object.count) : helpers_1.Long.UZERO;
	        message.pageNumber = object.pageNumber !== undefined && object.pageNumber !== null ? helpers_1.Long.fromValue(object.pageNumber) : helpers_1.Long.UZERO;
	        message.pageTotal = object.pageTotal !== undefined && object.pageTotal !== null ? helpers_1.Long.fromValue(object.pageTotal) : helpers_1.Long.UZERO;
	        message.limit = object.limit !== undefined && object.limit !== null ? helpers_1.Long.fromValue(object.limit) : helpers_1.Long.UZERO;
	        message.txs = object.txs?.map(e => exports.TxResponse.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            totalCount: object?.total_count,
	            count: object?.count,
	            pageNumber: object?.page_number,
	            pageTotal: object?.page_total,
	            limit: object?.limit,
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => exports.TxResponse.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.total_count = message.totalCount;
	        obj.count = message.count;
	        obj.page_number = message.pageNumber;
	        obj.page_total = message.pageTotal;
	        obj.limit = message.limit;
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e ? exports.TxResponse.toSDK(e) : undefined);
	        }
	        else {
	            obj.txs = [];
	        }
	        return obj;
	    }
	};
	
} (abci));

abci.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ServiceClientImpl = exports.TxDecodeAminoResponse = exports.TxDecodeAminoRequest = exports.TxEncodeAminoResponse = exports.TxEncodeAminoRequest = exports.TxEncodeResponse = exports.TxEncodeRequest = exports.TxDecodeResponse = exports.TxDecodeRequest = exports.GetBlockWithTxsResponse = exports.GetBlockWithTxsRequest = exports.GetTxResponse = exports.GetTxRequest = exports.SimulateResponse = exports.SimulateRequest = exports.BroadcastTxResponse = exports.BroadcastTxRequest = exports.GetTxsEventResponse = exports.GetTxsEventRequest = exports.broadcastModeToJSON = exports.broadcastModeFromJSON = exports.BroadcastModeSDKType = exports.BroadcastMode = exports.orderByToJSON = exports.orderByFromJSON = exports.OrderBySDKType = exports.OrderBy = exports.protobufPackage = void 0;
	/* eslint-disable */
	const tx_1 = tx$6;
	const pagination_1 = pagination;
	const abci_1 = abci;
	const types_1 = types$9;
	const block_1 = block;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "cosmos.tx.v1beta1";
	/** OrderBy defines the sorting order */
	var OrderBy;
	(function (OrderBy) {
	    /** ORDER_BY_UNSPECIFIED - ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case. */
	    OrderBy[OrderBy["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
	    /** ORDER_BY_ASC - ORDER_BY_ASC defines ascending order */
	    OrderBy[OrderBy["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
	    /** ORDER_BY_DESC - ORDER_BY_DESC defines descending order */
	    OrderBy[OrderBy["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
	    OrderBy[OrderBy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(OrderBy = exports.OrderBy || (exports.OrderBy = {}));
	exports.OrderBySDKType = OrderBy;
	function orderByFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "ORDER_BY_UNSPECIFIED":
	            return OrderBy.ORDER_BY_UNSPECIFIED;
	        case 1:
	        case "ORDER_BY_ASC":
	            return OrderBy.ORDER_BY_ASC;
	        case 2:
	        case "ORDER_BY_DESC":
	            return OrderBy.ORDER_BY_DESC;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return OrderBy.UNRECOGNIZED;
	    }
	}
	exports.orderByFromJSON = orderByFromJSON;
	function orderByToJSON(object) {
	    switch (object) {
	        case OrderBy.ORDER_BY_UNSPECIFIED:
	            return "ORDER_BY_UNSPECIFIED";
	        case OrderBy.ORDER_BY_ASC:
	            return "ORDER_BY_ASC";
	        case OrderBy.ORDER_BY_DESC:
	            return "ORDER_BY_DESC";
	        case OrderBy.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.orderByToJSON = orderByToJSON;
	/** BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method. */
	var BroadcastMode;
	(function (BroadcastMode) {
	    /** BROADCAST_MODE_UNSPECIFIED - zero-value for mode ordering */
	    BroadcastMode[BroadcastMode["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
	    /**
	     * BROADCAST_MODE_BLOCK - DEPRECATED: use BROADCAST_MODE_SYNC instead,
	     * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
	     */
	    BroadcastMode[BroadcastMode["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
	    /**
	     * BROADCAST_MODE_SYNC - BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for
	     * a CheckTx execution response only.
	     */
	    BroadcastMode[BroadcastMode["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
	    /**
	     * BROADCAST_MODE_ASYNC - BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns
	     * immediately.
	     */
	    BroadcastMode[BroadcastMode["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
	    BroadcastMode[BroadcastMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(BroadcastMode = exports.BroadcastMode || (exports.BroadcastMode = {}));
	exports.BroadcastModeSDKType = BroadcastMode;
	function broadcastModeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "BROADCAST_MODE_UNSPECIFIED":
	            return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
	        case 1:
	        case "BROADCAST_MODE_BLOCK":
	            return BroadcastMode.BROADCAST_MODE_BLOCK;
	        case 2:
	        case "BROADCAST_MODE_SYNC":
	            return BroadcastMode.BROADCAST_MODE_SYNC;
	        case 3:
	        case "BROADCAST_MODE_ASYNC":
	            return BroadcastMode.BROADCAST_MODE_ASYNC;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return BroadcastMode.UNRECOGNIZED;
	    }
	}
	exports.broadcastModeFromJSON = broadcastModeFromJSON;
	function broadcastModeToJSON(object) {
	    switch (object) {
	        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
	            return "BROADCAST_MODE_UNSPECIFIED";
	        case BroadcastMode.BROADCAST_MODE_BLOCK:
	            return "BROADCAST_MODE_BLOCK";
	        case BroadcastMode.BROADCAST_MODE_SYNC:
	            return "BROADCAST_MODE_SYNC";
	        case BroadcastMode.BROADCAST_MODE_ASYNC:
	            return "BROADCAST_MODE_ASYNC";
	        case BroadcastMode.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.broadcastModeToJSON = broadcastModeToJSON;
	function createBaseGetTxsEventRequest() {
	    return {
	        events: [],
	        pagination: undefined,
	        orderBy: 0,
	        page: helpers_1.Long.UZERO,
	        limit: helpers_1.Long.UZERO
	    };
	}
	exports.GetTxsEventRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.events) {
	            writer.uint32(10).string(v);
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.orderBy !== 0) {
	            writer.uint32(24).int32(message.orderBy);
	        }
	        if (!message.page.isZero()) {
	            writer.uint32(32).uint64(message.page);
	        }
	        if (!message.limit.isZero()) {
	            writer.uint32(40).uint64(message.limit);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetTxsEventRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.events.push(reader.string());
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.orderBy = reader.int32();
	                    break;
	                case 4:
	                    message.page = reader.uint64();
	                    break;
	                case 5:
	                    message.limit = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            events: Array.isArray(object?.events) ? object.events.map((e) => String(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
	            orderBy: (0, helpers_1.isSet)(object.orderBy) ? orderByFromJSON(object.orderBy) : 0,
	            page: (0, helpers_1.isSet)(object.page) ? helpers_1.Long.fromValue(object.page) : helpers_1.Long.UZERO,
	            limit: (0, helpers_1.isSet)(object.limit) ? helpers_1.Long.fromValue(object.limit) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.events) {
	            obj.events = message.events.map(e => e);
	        }
	        else {
	            obj.events = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        message.orderBy !== undefined && (obj.orderBy = orderByToJSON(message.orderBy));
	        message.page !== undefined && (obj.page = (message.page || helpers_1.Long.UZERO).toString());
	        message.limit !== undefined && (obj.limit = (message.limit || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetTxsEventRequest();
	        message.events = object.events?.map(e => e) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        message.orderBy = object.orderBy ?? 0;
	        message.page = object.page !== undefined && object.page !== null ? helpers_1.Long.fromValue(object.page) : helpers_1.Long.UZERO;
	        message.limit = object.limit !== undefined && object.limit !== null ? helpers_1.Long.fromValue(object.limit) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            events: Array.isArray(object?.events) ? object.events.map((e) => e) : [],
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined,
	            orderBy: (0, helpers_1.isSet)(object.order_by) ? orderByFromJSON(object.order_by) : 0,
	            page: object?.page,
	            limit: object?.limit
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.events) {
	            obj.events = message.events.map(e => e);
	        }
	        else {
	            obj.events = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        message.orderBy !== undefined && (obj.order_by = orderByToJSON(message.orderBy));
	        obj.page = message.page;
	        obj.limit = message.limit;
	        return obj;
	    }
	};
	function createBaseGetTxsEventResponse() {
	    return {
	        txs: [],
	        txResponses: [],
	        pagination: undefined,
	        total: helpers_1.Long.UZERO
	    };
	}
	exports.GetTxsEventResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.txs) {
	            tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        for (const v of message.txResponses) {
	            abci_1.TxResponse.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
	        }
	        if (!message.total.isZero()) {
	            writer.uint32(32).uint64(message.total);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetTxsEventResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
	                    break;
	                case 3:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.total = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => tx_1.Tx.fromJSON(e)) : [],
	            txResponses: Array.isArray(object?.txResponses) ? object.txResponses.map((e) => abci_1.TxResponse.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined,
	            total: (0, helpers_1.isSet)(object.total) ? helpers_1.Long.fromValue(object.total) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e ? tx_1.Tx.toJSON(e) : undefined);
	        }
	        else {
	            obj.txs = [];
	        }
	        if (message.txResponses) {
	            obj.txResponses = message.txResponses.map(e => e ? abci_1.TxResponse.toJSON(e) : undefined);
	        }
	        else {
	            obj.txResponses = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        message.total !== undefined && (obj.total = (message.total || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetTxsEventResponse();
	        message.txs = object.txs?.map(e => tx_1.Tx.fromPartial(e)) || [];
	        message.txResponses = object.txResponses?.map(e => abci_1.TxResponse.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        message.total = object.total !== undefined && object.total !== null ? helpers_1.Long.fromValue(object.total) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => tx_1.Tx.fromSDK(e)) : [],
	            txResponses: Array.isArray(object?.tx_responses) ? object.tx_responses.map((e) => abci_1.TxResponse.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined,
	            total: object?.total
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e ? tx_1.Tx.toSDK(e) : undefined);
	        }
	        else {
	            obj.txs = [];
	        }
	        if (message.txResponses) {
	            obj.tx_responses = message.txResponses.map(e => e ? abci_1.TxResponse.toSDK(e) : undefined);
	        }
	        else {
	            obj.tx_responses = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        obj.total = message.total;
	        return obj;
	    }
	};
	function createBaseBroadcastTxRequest() {
	    return {
	        txBytes: new Uint8Array(),
	        mode: 0
	    };
	}
	exports.BroadcastTxRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.txBytes.length !== 0) {
	            writer.uint32(10).bytes(message.txBytes);
	        }
	        if (message.mode !== 0) {
	            writer.uint32(16).int32(message.mode);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBroadcastTxRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txBytes = reader.bytes();
	                    break;
	                case 2:
	                    message.mode = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txBytes: (0, helpers_1.isSet)(object.txBytes) ? (0, helpers_1.bytesFromBase64)(object.txBytes) : new Uint8Array(),
	            mode: (0, helpers_1.isSet)(object.mode) ? broadcastModeFromJSON(object.mode) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
	        message.mode !== undefined && (obj.mode = broadcastModeToJSON(message.mode));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBroadcastTxRequest();
	        message.txBytes = object.txBytes ?? new Uint8Array();
	        message.mode = object.mode ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txBytes: object?.tx_bytes,
	            mode: (0, helpers_1.isSet)(object.mode) ? broadcastModeFromJSON(object.mode) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.tx_bytes = message.txBytes;
	        message.mode !== undefined && (obj.mode = broadcastModeToJSON(message.mode));
	        return obj;
	    }
	};
	function createBaseBroadcastTxResponse() {
	    return {
	        txResponse: undefined
	    };
	}
	exports.BroadcastTxResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.txResponse !== undefined) {
	            abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBroadcastTxResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txResponse: (0, helpers_1.isSet)(object.txResponse) ? abci_1.TxResponse.fromJSON(object.txResponse) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.txResponse !== undefined && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBroadcastTxResponse();
	        message.txResponse = object.txResponse !== undefined && object.txResponse !== null ? abci_1.TxResponse.fromPartial(object.txResponse) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txResponse: object.tx_response ? abci_1.TxResponse.fromSDK(object.tx_response) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.txResponse !== undefined && (obj.tx_response = message.txResponse ? abci_1.TxResponse.toSDK(message.txResponse) : undefined);
	        return obj;
	    }
	};
	function createBaseSimulateRequest() {
	    return {
	        tx: undefined,
	        txBytes: new Uint8Array()
	    };
	}
	exports.SimulateRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.tx !== undefined) {
	            tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.txBytes.length !== 0) {
	            writer.uint32(18).bytes(message.txBytes);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSimulateRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.txBytes = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            tx: (0, helpers_1.isSet)(object.tx) ? tx_1.Tx.fromJSON(object.tx) : undefined,
	            txBytes: (0, helpers_1.isSet)(object.txBytes) ? (0, helpers_1.bytesFromBase64)(object.txBytes) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
	        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSimulateRequest();
	        message.tx = object.tx !== undefined && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : undefined;
	        message.txBytes = object.txBytes ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            tx: object.tx ? tx_1.Tx.fromSDK(object.tx) : undefined,
	            txBytes: object?.tx_bytes
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toSDK(message.tx) : undefined);
	        obj.tx_bytes = message.txBytes;
	        return obj;
	    }
	};
	function createBaseSimulateResponse() {
	    return {
	        gasInfo: undefined,
	        result: undefined
	    };
	}
	exports.SimulateResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.gasInfo !== undefined) {
	            abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.result !== undefined) {
	            abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSimulateResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.result = abci_1.Result.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            gasInfo: (0, helpers_1.isSet)(object.gasInfo) ? abci_1.GasInfo.fromJSON(object.gasInfo) : undefined,
	            result: (0, helpers_1.isSet)(object.result) ? abci_1.Result.fromJSON(object.result) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.gasInfo !== undefined && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : undefined);
	        message.result !== undefined && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSimulateResponse();
	        message.gasInfo = object.gasInfo !== undefined && object.gasInfo !== null ? abci_1.GasInfo.fromPartial(object.gasInfo) : undefined;
	        message.result = object.result !== undefined && object.result !== null ? abci_1.Result.fromPartial(object.result) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            gasInfo: object.gas_info ? abci_1.GasInfo.fromSDK(object.gas_info) : undefined,
	            result: object.result ? abci_1.Result.fromSDK(object.result) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.gasInfo !== undefined && (obj.gas_info = message.gasInfo ? abci_1.GasInfo.toSDK(message.gasInfo) : undefined);
	        message.result !== undefined && (obj.result = message.result ? abci_1.Result.toSDK(message.result) : undefined);
	        return obj;
	    }
	};
	function createBaseGetTxRequest() {
	    return {
	        hash: ""
	    };
	}
	exports.GetTxRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.hash !== "") {
	            writer.uint32(10).string(message.hash);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetTxRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.hash = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            hash: (0, helpers_1.isSet)(object.hash) ? String(object.hash) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.hash !== undefined && (obj.hash = message.hash);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetTxRequest();
	        message.hash = object.hash ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            hash: object?.hash
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.hash = message.hash;
	        return obj;
	    }
	};
	function createBaseGetTxResponse() {
	    return {
	        tx: undefined,
	        txResponse: undefined
	    };
	}
	exports.GetTxResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.tx !== undefined) {
	            tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.txResponse !== undefined) {
	            abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetTxResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            tx: (0, helpers_1.isSet)(object.tx) ? tx_1.Tx.fromJSON(object.tx) : undefined,
	            txResponse: (0, helpers_1.isSet)(object.txResponse) ? abci_1.TxResponse.fromJSON(object.txResponse) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
	        message.txResponse !== undefined && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetTxResponse();
	        message.tx = object.tx !== undefined && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : undefined;
	        message.txResponse = object.txResponse !== undefined && object.txResponse !== null ? abci_1.TxResponse.fromPartial(object.txResponse) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            tx: object.tx ? tx_1.Tx.fromSDK(object.tx) : undefined,
	            txResponse: object.tx_response ? abci_1.TxResponse.fromSDK(object.tx_response) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toSDK(message.tx) : undefined);
	        message.txResponse !== undefined && (obj.tx_response = message.txResponse ? abci_1.TxResponse.toSDK(message.txResponse) : undefined);
	        return obj;
	    }
	};
	function createBaseGetBlockWithTxsRequest() {
	    return {
	        height: helpers_1.Long.ZERO,
	        pagination: undefined
	    };
	}
	exports.GetBlockWithTxsRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.height.isZero()) {
	            writer.uint32(8).int64(message.height);
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetBlockWithTxsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.height = reader.int64();
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO,
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.ZERO).toString());
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetBlockWithTxsRequest();
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.ZERO;
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            height: object?.height,
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.height = message.height;
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseGetBlockWithTxsResponse() {
	    return {
	        txs: [],
	        blockId: undefined,
	        block: undefined,
	        pagination: undefined
	    };
	}
	exports.GetBlockWithTxsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.txs) {
	            tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.blockId !== undefined) {
	            types_1.BlockID.encode(message.blockId, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.block !== undefined) {
	            block_1.Block.encode(message.block, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGetBlockWithTxsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.blockId = types_1.BlockID.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.block = block_1.Block.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => tx_1.Tx.fromJSON(e)) : [],
	            blockId: (0, helpers_1.isSet)(object.blockId) ? types_1.BlockID.fromJSON(object.blockId) : undefined,
	            block: (0, helpers_1.isSet)(object.block) ? block_1.Block.fromJSON(object.block) : undefined,
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e ? tx_1.Tx.toJSON(e) : undefined);
	        }
	        else {
	            obj.txs = [];
	        }
	        message.blockId !== undefined && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : undefined);
	        message.block !== undefined && (obj.block = message.block ? block_1.Block.toJSON(message.block) : undefined);
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGetBlockWithTxsResponse();
	        message.txs = object.txs?.map(e => tx_1.Tx.fromPartial(e)) || [];
	        message.blockId = object.blockId !== undefined && object.blockId !== null ? types_1.BlockID.fromPartial(object.blockId) : undefined;
	        message.block = object.block !== undefined && object.block !== null ? block_1.Block.fromPartial(object.block) : undefined;
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txs: Array.isArray(object?.txs) ? object.txs.map((e) => tx_1.Tx.fromSDK(e)) : [],
	            blockId: object.block_id ? types_1.BlockID.fromSDK(object.block_id) : undefined,
	            block: object.block ? block_1.Block.fromSDK(object.block) : undefined,
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.txs) {
	            obj.txs = message.txs.map(e => e ? tx_1.Tx.toSDK(e) : undefined);
	        }
	        else {
	            obj.txs = [];
	        }
	        message.blockId !== undefined && (obj.block_id = message.blockId ? types_1.BlockID.toSDK(message.blockId) : undefined);
	        message.block !== undefined && (obj.block = message.block ? block_1.Block.toSDK(message.block) : undefined);
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseTxDecodeRequest() {
	    return {
	        txBytes: new Uint8Array()
	    };
	}
	exports.TxDecodeRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.txBytes.length !== 0) {
	            writer.uint32(10).bytes(message.txBytes);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxDecodeRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txBytes = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txBytes: (0, helpers_1.isSet)(object.txBytes) ? (0, helpers_1.bytesFromBase64)(object.txBytes) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxDecodeRequest();
	        message.txBytes = object.txBytes ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txBytes: object?.tx_bytes
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.tx_bytes = message.txBytes;
	        return obj;
	    }
	};
	function createBaseTxDecodeResponse() {
	    return {
	        tx: undefined
	    };
	}
	exports.TxDecodeResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.tx !== undefined) {
	            tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxDecodeResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            tx: (0, helpers_1.isSet)(object.tx) ? tx_1.Tx.fromJSON(object.tx) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxDecodeResponse();
	        message.tx = object.tx !== undefined && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            tx: object.tx ? tx_1.Tx.fromSDK(object.tx) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toSDK(message.tx) : undefined);
	        return obj;
	    }
	};
	function createBaseTxEncodeRequest() {
	    return {
	        tx: undefined
	    };
	}
	exports.TxEncodeRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.tx !== undefined) {
	            tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxEncodeRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            tx: (0, helpers_1.isSet)(object.tx) ? tx_1.Tx.fromJSON(object.tx) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxEncodeRequest();
	        message.tx = object.tx !== undefined && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            tx: object.tx ? tx_1.Tx.fromSDK(object.tx) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toSDK(message.tx) : undefined);
	        return obj;
	    }
	};
	function createBaseTxEncodeResponse() {
	    return {
	        txBytes: new Uint8Array()
	    };
	}
	exports.TxEncodeResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.txBytes.length !== 0) {
	            writer.uint32(10).bytes(message.txBytes);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxEncodeResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.txBytes = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            txBytes: (0, helpers_1.isSet)(object.txBytes) ? (0, helpers_1.bytesFromBase64)(object.txBytes) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxEncodeResponse();
	        message.txBytes = object.txBytes ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            txBytes: object?.tx_bytes
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.tx_bytes = message.txBytes;
	        return obj;
	    }
	};
	function createBaseTxEncodeAminoRequest() {
	    return {
	        aminoJson: ""
	    };
	}
	exports.TxEncodeAminoRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.aminoJson !== "") {
	            writer.uint32(10).string(message.aminoJson);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxEncodeAminoRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.aminoJson = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            aminoJson: (0, helpers_1.isSet)(object.aminoJson) ? String(object.aminoJson) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.aminoJson !== undefined && (obj.aminoJson = message.aminoJson);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxEncodeAminoRequest();
	        message.aminoJson = object.aminoJson ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            aminoJson: object?.amino_json
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.amino_json = message.aminoJson;
	        return obj;
	    }
	};
	function createBaseTxEncodeAminoResponse() {
	    return {
	        aminoBinary: new Uint8Array()
	    };
	}
	exports.TxEncodeAminoResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.aminoBinary.length !== 0) {
	            writer.uint32(10).bytes(message.aminoBinary);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxEncodeAminoResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.aminoBinary = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            aminoBinary: (0, helpers_1.isSet)(object.aminoBinary) ? (0, helpers_1.bytesFromBase64)(object.aminoBinary) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.aminoBinary !== undefined && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== undefined ? message.aminoBinary : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxEncodeAminoResponse();
	        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            aminoBinary: object?.amino_binary
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.amino_binary = message.aminoBinary;
	        return obj;
	    }
	};
	function createBaseTxDecodeAminoRequest() {
	    return {
	        aminoBinary: new Uint8Array()
	    };
	}
	exports.TxDecodeAminoRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.aminoBinary.length !== 0) {
	            writer.uint32(10).bytes(message.aminoBinary);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxDecodeAminoRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.aminoBinary = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            aminoBinary: (0, helpers_1.isSet)(object.aminoBinary) ? (0, helpers_1.bytesFromBase64)(object.aminoBinary) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.aminoBinary !== undefined && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== undefined ? message.aminoBinary : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxDecodeAminoRequest();
	        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            aminoBinary: object?.amino_binary
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.amino_binary = message.aminoBinary;
	        return obj;
	    }
	};
	function createBaseTxDecodeAminoResponse() {
	    return {
	        aminoJson: ""
	    };
	}
	exports.TxDecodeAminoResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.aminoJson !== "") {
	            writer.uint32(10).string(message.aminoJson);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTxDecodeAminoResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.aminoJson = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            aminoJson: (0, helpers_1.isSet)(object.aminoJson) ? String(object.aminoJson) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.aminoJson !== undefined && (obj.aminoJson = message.aminoJson);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTxDecodeAminoResponse();
	        message.aminoJson = object.aminoJson ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            aminoJson: object?.amino_json
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.amino_json = message.aminoJson;
	        return obj;
	    }
	};
	class ServiceClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Simulate = this.Simulate.bind(this);
	        this.GetTx = this.GetTx.bind(this);
	        this.BroadcastTx = this.BroadcastTx.bind(this);
	        this.GetTxsEvent = this.GetTxsEvent.bind(this);
	        this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this);
	        this.TxDecode = this.TxDecode.bind(this);
	        this.TxEncode = this.TxEncode.bind(this);
	        this.TxEncodeAmino = this.TxEncodeAmino.bind(this);
	        this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
	    }
	    Simulate(request) {
	        const data = exports.SimulateRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data);
	        return promise.then(data => exports.SimulateResponse.decode(new _m0.Reader(data)));
	    }
	    GetTx(request) {
	        const data = exports.GetTxRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data);
	        return promise.then(data => exports.GetTxResponse.decode(new _m0.Reader(data)));
	    }
	    BroadcastTx(request) {
	        const data = exports.BroadcastTxRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data);
	        return promise.then(data => exports.BroadcastTxResponse.decode(new _m0.Reader(data)));
	    }
	    GetTxsEvent(request) {
	        const data = exports.GetTxsEventRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data);
	        return promise.then(data => exports.GetTxsEventResponse.decode(new _m0.Reader(data)));
	    }
	    GetBlockWithTxs(request) {
	        const data = exports.GetBlockWithTxsRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", data);
	        return promise.then(data => exports.GetBlockWithTxsResponse.decode(new _m0.Reader(data)));
	    }
	    TxDecode(request) {
	        const data = exports.TxDecodeRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", data);
	        return promise.then(data => exports.TxDecodeResponse.decode(new _m0.Reader(data)));
	    }
	    TxEncode(request) {
	        const data = exports.TxEncodeRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", data);
	        return promise.then(data => exports.TxEncodeResponse.decode(new _m0.Reader(data)));
	    }
	    TxEncodeAmino(request) {
	        const data = exports.TxEncodeAminoRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", data);
	        return promise.then(data => exports.TxEncodeAminoResponse.decode(new _m0.Reader(data)));
	    }
	    TxDecodeAmino(request) {
	        const data = exports.TxDecodeAminoRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", data);
	        return promise.then(data => exports.TxDecodeAminoResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.ServiceClientImpl = ServiceClientImpl;
	
} (service));

service.default;

const ZERO_PUBKEY = '0x000000000000000000000000000000000000000000000000000000000000000000';

const createEIP712 = (types, chainId, message) => {
    return {
        types,
        primaryType: 'Tx',
        domain: {
            name: 'Greenfield Tx',
            version: '1.0.0',
            chainId,
            verifyingContract: 'greenfield',
            salt: '0',
        },
        message,
    };
};
const generateMessage = (accountNumber, sequence, chainCosmosId, memo, fee, msg, timeoutHeight) => {
    return {
        account_number: accountNumber,
        chain_id: chainCosmosId,
        sequence,
        memo,
        fee,
        msg,
        timeout_height: timeoutHeight,
    };
};
const generateTypes = (newTypes) => {
    const types = {
        Coin: [
            { name: 'denom', type: 'string' },
            { name: 'amount', type: 'uint256' },
        ],
        EIP712Domain: [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'string' },
            { name: 'salt', type: 'string' },
        ],
        Tx: [
            { name: 'account_number', type: 'uint256' },
            { name: 'chain_id', type: 'uint256' },
            { name: 'fee', type: 'Fee' },
            { name: 'memo', type: 'string' },
            { name: 'msg', type: 'Msg' },
            { name: 'sequence', type: 'uint256' },
            { name: 'timeout_height', type: 'uint256' },
        ],
        Fee: [
            { name: 'amount', type: 'Coin[]' },
            { name: 'gas_limit', type: 'uint256' },
            { name: 'payer', type: 'string' },
            { name: 'granter', type: 'string' },
        ],
        TypeAmount: [
            { name: 'denom', type: 'string' },
            { name: 'amount', type: 'string' },
        ],
    };
    Object.assign(types, newTypes);
    return types;
};
const generateFee = (amount, denom, gas_limit, payer, granter) => {
    return {
        amount: [
            {
                amount,
                denom,
            },
        ],
        gas_limit,
        payer,
        granter,
    };
};

/**
 * @addr wallet address
 * @message sign typed v4 data
 */
const sign712Tx = (addr, message) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // TODO: eth-sig-utils
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const signature = yield ((_a = window.ethereum) === null || _a === void 0 ? void 0 : _a.request({
        method: 'eth_signTypedData_v4',
        params: [addr, message],
    }));
    const messageHash = ethSigUtil.TypedDataUtils.eip712Hash(JSON.parse(message), ethSigUtil.SignTypedDataVersion.V4);
    return {
        signature,
        messageHash,
    };
});

var keys = {};

var __createBinding$6 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$6 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$6 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$6(result, mod, k);
    __setModuleDefault$6(result, mod);
    return result;
};
Object.defineProperty(keys, "__esModule", { value: true });
keys.PrivKey = PubKey = keys.PubKey = keys.protobufPackage = void 0;
/* eslint-disable */
const _m0$6 = __importStar$6(minimal$1.exports);
const helpers_1$6 = helpers;
keys.protobufPackage = "cosmos.crypto.secp256k1";
function createBasePubKey() {
    return {
        key: new Uint8Array()
    };
}
var PubKey = keys.PubKey = {
    encode(message, writer = _m0$6.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$6.Reader ? input : new _m0$6.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: (0, helpers_1$6.isSet)(object.key) ? (0, helpers_1$6.bytesFromBase64)(object.key) : new Uint8Array()
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1$6.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
    },
    fromSDK(object) {
        return {
            key: object?.key
        };
    },
    toSDK(message) {
        const obj = {};
        obj.key = message.key;
        return obj;
    }
};
function createBasePrivKey() {
    return {
        key: new Uint8Array()
    };
}
keys.PrivKey = {
    encode(message, writer = _m0$6.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$6.Reader ? input : new _m0$6.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: (0, helpers_1$6.isSet)(object.key) ? (0, helpers_1$6.bytesFromBase64)(object.key) : new Uint8Array()
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1$6.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
    },
    fromSDK(object) {
        return {
            key: object?.key
        };
    },
    toSDK(message) {
        const obj = {};
        obj.key = message.key;
        return obj;
    }
};

/**
 * recover public key from signature
 *
 * @messageHash message hash
 * @signature message signature
 *
 * @returns uncompressed public key
 */
const recoverPk = ({ messageHash, signature }) => {
    const uncompressedPubKey = signingKey.recoverPublicKey(messageHash, signature);
    return signingKey.computePublicKey(uncompressedPubKey, true);
};
/**
 * @pk compressed public key from signature
 * @return eg. { typeUrl: '/ethermint.crypto.v1.ethsecp256k1.PubKey', value: 'CiEC+hp2uVKio9T7x0goOPyHgwUYiRsZ8MeYUrfRX8MxrzM=' }
 */
const makeCosmsPubKey = (pk) => {
    const pubKey = PubKey.fromPartial({
        key: util.toBuffer(pk),
    });
    return {
        typeUrl: '/ethermint.crypto.v1.ethsecp256k1.PubKey',
        value: PubKey.encode(pubKey).finish(),
    };
};

const typeWrapper = (type, msg) => {
    return Object.assign(Object.assign({}, msg), { type });
};

const makeClientWithExtension = (rpcUrl) => __awaiter(void 0, void 0, void 0, function* () {
    const tmClient = yield tendermintRpc.Tendermint34Client.connect(rpcUrl);
    return [
        stargate.QueryClient.withExtensions(tmClient, stargate.setupAuthExtension, stargate.setupAuthzExtension, stargate.setupBankExtension, stargate.setupDistributionExtension, stargate.setupFeegrantExtension, stargate.setupGovExtension, stargate.setupIbcExtension, stargate.setupMintExtension, stargate.setupSlashingExtension, stargate.setupStakingExtension, stargate.setupTxExtension),
        tmClient,
    ];
});
const makeRpcClient = (rpcUrl) => __awaiter(void 0, void 0, void 0, function* () {
    const [, tmClient] = yield makeClientWithExtension(rpcUrl);
    const rpc = stargate.createProtobufRpcClient(new stargate.QueryClient(tmClient));
    return rpc;
});
class Basic {
    constructor(rpcUrl, chainId) {
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.rpcClient = null;
        this.queryClient = null;
    }
    getNodeInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$6.ServiceClientImpl(rpcClient);
            return yield rpc.GetNodeInfo();
        });
    }
    getLatestBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$6.ServiceClientImpl(rpcClient);
            return yield rpc.GetLatestBlock();
        });
    }
    getLatestBlockHeight() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const latestBlock = yield this.getLatestBlock();
            const height = (_b = (_a = latestBlock.sdkBlock) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.height;
            if (!height)
                return 0;
            return height.toNumber();
        });
    }
    getSyncing() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$6.ServiceClientImpl(rpcClient);
            const syncing = yield rpc.GetSyncing();
            return syncing.syncing;
        });
    }
    getBlockByHeight(height) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$6.ServiceClientImpl(rpcClient);
            return yield rpc.GetBlockByHeight({
                height: Long__default["default"].fromInt(height),
            });
        });
    }
    GetLatestValidatorSet(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$6.ServiceClientImpl(rpcClient);
            const validatorSet = yield rpc.GetLatestValidatorSet(request);
            return validatorSet.blockHeight.toNumber();
        });
    }
    getRpcClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rpcClient) {
                this.rpcClient = yield makeRpcClient(this.rpcUrl);
            }
            return this.rpcClient;
        });
    }
    simulateRawTx(txBodyBytes, accountInfo, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new service.ServiceClientImpl(rpcClient);
            const { denom } = txOption;
            const authInfoBytes = this.getAuthInfoBytes({
                sequence: accountInfo.sequence + '',
                denom,
                gasLimit: 0,
                gasPrice: '0',
                pubKey: makeCosmsPubKey(ZERO_PUBKEY),
            });
            const tx = tx$6.Tx.fromPartial({
                authInfo: tx$6.AuthInfo.decode(authInfoBytes),
                body: tx$6.TxBody.decode(txBodyBytes),
                signatures: [Uint8Array.from([])],
            });
            const request = service.SimulateRequest.fromPartial({
                txBytes: tx$6.Tx.encode(tx).finish(),
            });
            const res = yield rpc.Simulate(request);
            return getGasFeeBySimulate(res, txOption.denom);
        });
    }
    broadcastRawTx(txRawBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield stargate.StargateClient.connect(this.rpcUrl);
            return yield client.broadcastTx(txRawBytes);
        });
    }
    getQueryClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.queryClient) {
                const [client] = yield makeClientWithExtension(this.rpcUrl);
                this.queryClient = client;
            }
            return this.queryClient;
        });
    }
    getAuthInfoBytes(params) {
        const { pubKey, denom, sequence, gasLimit, gasPrice } = params;
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                denom,
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
    getRawTxBytes(typeUrl, msgEIP712Structor, msgEIP712, bodyBytes, accountInfo, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const { denom, gasLimit, gasPrice } = txOption;
            const eip712 = this.getEIP712Struct(typeUrl, msgEIP712Structor, accountInfo.accountNumber + '', accountInfo.sequence + '', this.chainId, msgEIP712, txOption);
            const { signature, pubKey } = yield this.signTx(accountInfo.address, JSON.stringify(eip712));
            const authInfoBytes = this.getAuthInfoBytes({
                denom,
                sequence: accountInfo.sequence + '',
                gasLimit,
                gasPrice,
                pubKey,
            });
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [util.toBuffer(signature)],
            });
            return tx$6.TxRaw.encode(txRaw).finish();
        });
    }
    getBodyBytes(typeUrl, msgBytes) {
        const msgWrapped = Any.fromPartial({
            typeUrl,
            value: msgBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
    getEIP712Struct(typeUrl, types, accountNumber, sequence, chainId, msg, txOption) {
        const { gasLimit, gasPrice, denom, payer } = txOption;
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), payer, '');
        const wrapperTypes = generateTypes(types);
        const wrapperMsg = typeWrapper(typeUrl, msg);
        const messages = generateMessage(accountNumber, sequence, chainId, '', fee, wrapperMsg, '0');
        return createEIP712(wrapperTypes, chainId, messages);
    }
    signTx(addr, message) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: provider
            /* eslint-disable @typescript-eslint/no-explicit-any */
            const signature = yield ((_a = window.ethereum) === null || _a === void 0 ? void 0 : _a.request({
                method: 'eth_signTypedData_v4',
                params: [addr, message],
            }));
            const messageHash = ethSigUtil.TypedDataUtils.eip712Hash(JSON.parse(message), ethSigUtil.SignTypedDataVersion.V4);
            const pk = recoverPk({
                signature,
                messageHash,
            });
            const pubKey = makeCosmsPubKey(pk);
            return {
                signature,
                messageHash,
                pubKey,
            };
        });
    }
}

class Account extends Basic {
    multiTransfer(address, msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/cosmos.bank.v1beta1.MsgMultiSend';
            const msgBytes = tx$8.MsgMultiSend.encode(msg).finish();
            const accountInfo = yield this.getAccount(address);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgMultiSendSDKTypeEIP712, tx$8.MsgMultiSend.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    createPaymentAccount(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.payment.MsgCreatePaymentAccount';
            const msgBytes = tx$7.MsgCreatePaymentAccount.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.creator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgCreatePaymentAccountSDKTypeEIP712, tx$7.MsgCreatePaymentAccount.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    getPaymentAccountsByOwner(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$7.QueryClientImpl(rpcClient);
            return yield rpc.GetPaymentAccountsByOwner({
                owner,
            });
        });
    }
    getModuleAccountByName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$9.QueryClientImpl(rpcClient);
            return rpc.ModuleAccountByName({
                name,
            });
        });
    }
    getModuleAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$9.QueryClientImpl(rpcClient);
            return yield rpc.ModuleAccounts();
        });
    }
    getPaymentAccount(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$7.QueryClientImpl(rpcClient);
            return yield rpc.PaymentAccount(request);
        });
    }
    getAccountBalance(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$8.QueryClientImpl(rpcClient);
            return yield rpc.Balance(request);
        });
    }
    getAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getQueryClient();
            const account = yield client.auth.account(address);
            if (!account)
                return auth.BaseAccount.fromJSON({});
            return auth.BaseAccount.toJSON(auth.BaseAccount.decode(account.value));
        });
    }
    transfer(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = MsgSendTypeUrl;
            const msgBytes = tx$8.MsgSend.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.fromAddress);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgSendSDKTypeEIP712$1, tx$8.MsgSend.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
}

const TYPE_URL$6 = '/bnbchain.greenfield.storage.MsgCreateBucket';
const MsgCreateBucketSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'visibility',
            type: 'string',
        },
        {
            name: 'payment_address',
            type: 'string',
        },
        {
            name: 'primary_sp_address',
            type: 'string',
        },
        {
            name: 'primary_sp_approval',
            type: 'TypePrimarySpApproval',
        },
        {
            name: 'charged_read_quota',
            type: 'uint64',
        },
    ],
    TypePrimarySpApproval: [
        {
            name: 'expired_height',
            type: 'uint64',
        },
        {
            name: 'sig',
            type: 'bytes',
        },
    ],
};
const newMsgCreateBucket = ({ bucketName, expiredHeight, from, visibility, paymentAddress, primarySpAddress, chargedReadQuota, sig, }) => {
    return {
        type: TYPE_URL$6,
        bucket_name: bucketName,
        creator: from,
        visibility,
        payment_address: paymentAddress,
        primary_sp_address: primarySpAddress,
        primary_sp_approval: {
            expired_height: expiredHeight,
            sig,
        },
        charged_read_quota: chargedReadQuota,
    };
};

const TYPE_URL$5 = '/bnbchain.greenfield.storage.MsgDeleteBucket';
const MsgDeleteBucketSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
    ],
};
const newMsgDeleteBucket = ({ bucketName, from }) => {
    return {
        type: TYPE_URL$5,
        bucket_name: bucketName,
        operator: from,
    };
};

const toHex = (char = '') => {
    return char.charCodeAt(0).toString(16);
};
const encodeToHex = (str = '') => {
    return str.split('').map(toHex).join('');
};
const decodeFromHex = (hex = '') => {
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
        result.push(String.fromCharCode(parseInt(hex.substr(i, 2), 16)));
    }
    return result.join('');
};
const encodeObjectToHexString = (jsonObject) => {
    const utf8Encoder = new TextEncoder();
    const utf8Bytes = utf8Encoder.encode(JSON.stringify(jsonObject));
    return Array.from(utf8Bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
};
const encodeToHexString = (str = '') => {
    const utf8Encoder = new TextEncoder();
    const utf8Bytes = utf8Encoder.encode(str);
    return Array.from(utf8Bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
};
const hexToBytes = (hex = '') => {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    return bytes;
};
function uint8ArrayToJson(uint8Array) {
    const decoder = new TextDecoder('utf-8');
    const jsonString = decoder.decode(uint8Array);
    return JSON.parse(jsonString);
}
const decodeObjectFromHexString = (hex = '') => {
    return uint8ArrayToJson(hexToBytes(hex));
};

const MOCK_SIGNATURE = '1234567812345678123456781234567812345678123456781234567812345678';
const NORMAL_ERROR_CODE = 404;
const METHOD_GET = 'GET';
const METHOD_PUT = 'PUT';
function timeoutAfter(duration) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('request time out'));
        }, duration);
    });
}
const fetchWithTimeout = (fetchUrl = '', fetchOptions = {}, duration = 30000) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const response = yield Promise.race([timeoutAfter(duration), fetch(fetchUrl, fetchOptions)]);
        return response;
    }
    catch (error) {
        return Promise.reject(error);
    }
});

const IP_REGEX = /^(\d+\.){3}\d+$/g;
const ALLOW_REGEX = /^[a-z0-9][a-z0-9.\-]{1,61}[a-z0-9]$/g;
const dotdotComponent = '..';
const dotComponent = '.';
const slashSeparator = '/';
const isValidBucketName = (bucketName) => {
    if (!bucketName) {
        throw new Error('Bucket name is empty, please check.');
    }
    const length = bucketName.length;
    if (length < 3 || length > 63) {
        throw new Error(`Bucket name length is required to be between 3~63, please check.`);
    }
    if (bucketName.match(IP_REGEX)) {
        throw new Error('The bucket name %s cannot be formatted as an IP address, please check.');
    }
    if (bucketName.includes('..') || bucketName.includes('.-') || bucketName.includes('-.')) {
        throw new Error('Bucket name contains invalid characters, please check.');
    }
    if (!bucketName.match(ALLOW_REGEX)) {
        throw new Error('Bucket name can only include lowercase letters, numbers, commas and hyphen, please check.');
    }
    if (bucketName[0] === '-' ||
        bucketName[length - 1] === '-' ||
        bucketName[0] === '.' ||
        bucketName[length - 1] === '.') {
        throw new Error('Bucket name %must start and end with a lowercase letter or number, please check.');
    }
    return true;
};
const hasBadPathComponent = (path) => {
    const newPath = path.trim();
    for (const p of newPath.split(slashSeparator)) {
        switch (p.trim()) {
            case dotdotComponent:
            case dotComponent:
                return true;
        }
    }
    return false;
};
const isUTF8 = (str) => {
    try {
        new TextDecoder('utf-8').decode(new TextEncoder().encode(str));
        return true;
    }
    catch (_a) {
        return false;
    }
};
const isValidObjectName = (objectName) => {
    if (!objectName) {
        throw new Error('Object name is empty, please check.');
    }
    if (objectName.length > 1024) {
        throw new Error('Object name is limited to 1024 at most, please check.');
    }
    if (hasBadPathComponent(objectName)) {
        throw new Error('Object name error, please check.');
    }
    if (!isUTF8(objectName)) {
        throw new Error('Object name is not in UTF-8 format, please check.');
    }
    if (objectName.includes(`//`)) {
        throw new Error(`Object name that contains a "//" is not supported`);
    }
    return true;
};
const isValidAddress = (address) => {
    if (!address) {
        throw new Error('Address is empty, please check.');
    }
    if (address.length > 1024) {
        throw new Error('Address is limited to 1024 at most, please check.');
    }
    return true;
};
const isValidUrl = (url) => {
    if (!url || url.length === 0)
        return false;
    const pattern = new RegExp('^(https?:\\/\\/)?' + // 协议
        '((([a-zA-Z\\d]([a-zA-Z\\d-]{0,61}[a-zA-Z\\d])?)\\.)+' + // 域名
        '[a-zA-Z]{2,13})' + // 顶级域名
        '(\\:\\d{1,5})?' + // 端口号
        '(\\/[-a-zA-Z\\d%_.~+]*)*' + // 路径
        '(\\?[;&a-zA-Z\\d%_.~+=-]*)?' + // 查询字符串
        '(\\#[-a-zA-Z\\d_]*)?$', 'i'); // 锚点
    return pattern.test(url);
};
// remove specified from prefix and suffix of a string
const trimString = (originString, deleteString) => {
    const delStrLength = deleteString.length;
    if (originString.startsWith(deleteString)) {
        originString = originString.substring(delStrLength);
    }
    if (originString.endsWith(deleteString)) {
        originString = originString.substring(0, originString.length - delStrLength);
    }
    return originString;
};
const generateUrlByBucketName = (endpoint = '', bucketName) => {
    if (!isValidUrl(endpoint)) {
        throw new Error('Invalid endpoint');
    }
    if (!isValidBucketName(bucketName)) ;
    const { protocol } = new URL(endpoint);
    return endpoint.replace(`${protocol}//`, `${protocol}//${bucketName}.`);
};

const MsgDeletePolicySDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgPutPolicySDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgUpdateBucketInfoSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ]
};

var common$3 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SecondarySpSignDoc = exports.Approval = exports.visibilityTypeToJSON = exports.visibilityTypeFromJSON = exports.VisibilityTypeSDKType = exports.VisibilityType = exports.objectStatusToJSON = exports.objectStatusFromJSON = exports.ObjectStatusSDKType = exports.ObjectStatus = exports.redundancyTypeToJSON = exports.redundancyTypeFromJSON = exports.RedundancyTypeSDKType = exports.RedundancyType = exports.bucketStatusToJSON = exports.bucketStatusFromJSON = exports.BucketStatusSDKType = exports.BucketStatus = exports.sourceTypeToJSON = exports.sourceTypeFromJSON = exports.SourceTypeSDKType = exports.SourceType = exports.protobufPackage = void 0;
	/* eslint-disable */
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "greenfield.storage";
	/**
	 * SourceType represents the source of resource creation, which can
	 * from Greenfield native or from a cross-chain transfer from BSC
	 */
	var SourceType;
	(function (SourceType) {
	    SourceType[SourceType["SOURCE_TYPE_ORIGIN"] = 0] = "SOURCE_TYPE_ORIGIN";
	    SourceType[SourceType["SOURCE_TYPE_BSC_CROSS_CHAIN"] = 1] = "SOURCE_TYPE_BSC_CROSS_CHAIN";
	    SourceType[SourceType["SOURCE_TYPE_MIRROR_PENDING"] = 2] = "SOURCE_TYPE_MIRROR_PENDING";
	    SourceType[SourceType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(SourceType = exports.SourceType || (exports.SourceType = {}));
	exports.SourceTypeSDKType = SourceType;
	function sourceTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "SOURCE_TYPE_ORIGIN":
	            return SourceType.SOURCE_TYPE_ORIGIN;
	        case 1:
	        case "SOURCE_TYPE_BSC_CROSS_CHAIN":
	            return SourceType.SOURCE_TYPE_BSC_CROSS_CHAIN;
	        case 2:
	        case "SOURCE_TYPE_MIRROR_PENDING":
	            return SourceType.SOURCE_TYPE_MIRROR_PENDING;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return SourceType.UNRECOGNIZED;
	    }
	}
	exports.sourceTypeFromJSON = sourceTypeFromJSON;
	function sourceTypeToJSON(object) {
	    switch (object) {
	        case SourceType.SOURCE_TYPE_ORIGIN:
	            return "SOURCE_TYPE_ORIGIN";
	        case SourceType.SOURCE_TYPE_BSC_CROSS_CHAIN:
	            return "SOURCE_TYPE_BSC_CROSS_CHAIN";
	        case SourceType.SOURCE_TYPE_MIRROR_PENDING:
	            return "SOURCE_TYPE_MIRROR_PENDING";
	        case SourceType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.sourceTypeToJSON = sourceTypeToJSON;
	/**
	 * BucketStatus represents the status of a bucket. After a user successfully
	 * sends a CreateBucket transaction onto the chain, the status is set to 'Created'.
	 * When a Discontinue Object transaction is received on chain, the status is set to 'Discontinued'.
	 */
	var BucketStatus;
	(function (BucketStatus) {
	    BucketStatus[BucketStatus["BUCKET_STATUS_CREATED"] = 0] = "BUCKET_STATUS_CREATED";
	    BucketStatus[BucketStatus["BUCKET_STATUS_DISCONTINUED"] = 1] = "BUCKET_STATUS_DISCONTINUED";
	    BucketStatus[BucketStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(BucketStatus = exports.BucketStatus || (exports.BucketStatus = {}));
	exports.BucketStatusSDKType = BucketStatus;
	function bucketStatusFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "BUCKET_STATUS_CREATED":
	            return BucketStatus.BUCKET_STATUS_CREATED;
	        case 1:
	        case "BUCKET_STATUS_DISCONTINUED":
	            return BucketStatus.BUCKET_STATUS_DISCONTINUED;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return BucketStatus.UNRECOGNIZED;
	    }
	}
	exports.bucketStatusFromJSON = bucketStatusFromJSON;
	function bucketStatusToJSON(object) {
	    switch (object) {
	        case BucketStatus.BUCKET_STATUS_CREATED:
	            return "BUCKET_STATUS_CREATED";
	        case BucketStatus.BUCKET_STATUS_DISCONTINUED:
	            return "BUCKET_STATUS_DISCONTINUED";
	        case BucketStatus.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.bucketStatusToJSON = bucketStatusToJSON;
	/**
	 * RedundancyType represents the redundancy algorithm type for object data,
	 * which can be either multi-replica or erasure coding.
	 */
	var RedundancyType;
	(function (RedundancyType) {
	    RedundancyType[RedundancyType["REDUNDANCY_EC_TYPE"] = 0] = "REDUNDANCY_EC_TYPE";
	    RedundancyType[RedundancyType["REDUNDANCY_REPLICA_TYPE"] = 1] = "REDUNDANCY_REPLICA_TYPE";
	    RedundancyType[RedundancyType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(RedundancyType = exports.RedundancyType || (exports.RedundancyType = {}));
	exports.RedundancyTypeSDKType = RedundancyType;
	function redundancyTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "REDUNDANCY_EC_TYPE":
	            return RedundancyType.REDUNDANCY_EC_TYPE;
	        case 1:
	        case "REDUNDANCY_REPLICA_TYPE":
	            return RedundancyType.REDUNDANCY_REPLICA_TYPE;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return RedundancyType.UNRECOGNIZED;
	    }
	}
	exports.redundancyTypeFromJSON = redundancyTypeFromJSON;
	function redundancyTypeToJSON(object) {
	    switch (object) {
	        case RedundancyType.REDUNDANCY_EC_TYPE:
	            return "REDUNDANCY_EC_TYPE";
	        case RedundancyType.REDUNDANCY_REPLICA_TYPE:
	            return "REDUNDANCY_REPLICA_TYPE";
	        case RedundancyType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.redundancyTypeToJSON = redundancyTypeToJSON;
	/**
	 * ObjectStatus represents the creation status of an object. After a user successfully
	 * sends a CreateObject transaction onto the chain, the status is set to 'Created'.
	 * After the Primary Service Provider successfully sends a Seal Object transaction onto
	 * the chain, the status is set to 'Sealed'. When a Discontinue Object transaction is
	 * received on chain, the status is set to 'Discontinued'.
	 */
	var ObjectStatus;
	(function (ObjectStatus) {
	    ObjectStatus[ObjectStatus["OBJECT_STATUS_CREATED"] = 0] = "OBJECT_STATUS_CREATED";
	    ObjectStatus[ObjectStatus["OBJECT_STATUS_SEALED"] = 1] = "OBJECT_STATUS_SEALED";
	    ObjectStatus[ObjectStatus["OBJECT_STATUS_DISCONTINUED"] = 2] = "OBJECT_STATUS_DISCONTINUED";
	    ObjectStatus[ObjectStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(ObjectStatus = exports.ObjectStatus || (exports.ObjectStatus = {}));
	exports.ObjectStatusSDKType = ObjectStatus;
	function objectStatusFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "OBJECT_STATUS_CREATED":
	            return ObjectStatus.OBJECT_STATUS_CREATED;
	        case 1:
	        case "OBJECT_STATUS_SEALED":
	            return ObjectStatus.OBJECT_STATUS_SEALED;
	        case 2:
	        case "OBJECT_STATUS_DISCONTINUED":
	            return ObjectStatus.OBJECT_STATUS_DISCONTINUED;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return ObjectStatus.UNRECOGNIZED;
	    }
	}
	exports.objectStatusFromJSON = objectStatusFromJSON;
	function objectStatusToJSON(object) {
	    switch (object) {
	        case ObjectStatus.OBJECT_STATUS_CREATED:
	            return "OBJECT_STATUS_CREATED";
	        case ObjectStatus.OBJECT_STATUS_SEALED:
	            return "OBJECT_STATUS_SEALED";
	        case ObjectStatus.OBJECT_STATUS_DISCONTINUED:
	            return "OBJECT_STATUS_DISCONTINUED";
	        case ObjectStatus.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.objectStatusToJSON = objectStatusToJSON;
	/** VisibilityType is the resources public status. */
	var VisibilityType;
	(function (VisibilityType) {
	    VisibilityType[VisibilityType["VISIBILITY_TYPE_UNSPECIFIED"] = 0] = "VISIBILITY_TYPE_UNSPECIFIED";
	    VisibilityType[VisibilityType["VISIBILITY_TYPE_PUBLIC_READ"] = 1] = "VISIBILITY_TYPE_PUBLIC_READ";
	    VisibilityType[VisibilityType["VISIBILITY_TYPE_PRIVATE"] = 2] = "VISIBILITY_TYPE_PRIVATE";
	    /** VISIBILITY_TYPE_INHERIT - If the bucket Visibility is inherit, it's finally set to private. If the object Visibility is inherit, it's the same as bucket. */
	    VisibilityType[VisibilityType["VISIBILITY_TYPE_INHERIT"] = 3] = "VISIBILITY_TYPE_INHERIT";
	    VisibilityType[VisibilityType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(VisibilityType = exports.VisibilityType || (exports.VisibilityType = {}));
	exports.VisibilityTypeSDKType = VisibilityType;
	function visibilityTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "VISIBILITY_TYPE_UNSPECIFIED":
	            return VisibilityType.VISIBILITY_TYPE_UNSPECIFIED;
	        case 1:
	        case "VISIBILITY_TYPE_PUBLIC_READ":
	            return VisibilityType.VISIBILITY_TYPE_PUBLIC_READ;
	        case 2:
	        case "VISIBILITY_TYPE_PRIVATE":
	            return VisibilityType.VISIBILITY_TYPE_PRIVATE;
	        case 3:
	        case "VISIBILITY_TYPE_INHERIT":
	            return VisibilityType.VISIBILITY_TYPE_INHERIT;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return VisibilityType.UNRECOGNIZED;
	    }
	}
	exports.visibilityTypeFromJSON = visibilityTypeFromJSON;
	function visibilityTypeToJSON(object) {
	    switch (object) {
	        case VisibilityType.VISIBILITY_TYPE_UNSPECIFIED:
	            return "VISIBILITY_TYPE_UNSPECIFIED";
	        case VisibilityType.VISIBILITY_TYPE_PUBLIC_READ:
	            return "VISIBILITY_TYPE_PUBLIC_READ";
	        case VisibilityType.VISIBILITY_TYPE_PRIVATE:
	            return "VISIBILITY_TYPE_PRIVATE";
	        case VisibilityType.VISIBILITY_TYPE_INHERIT:
	            return "VISIBILITY_TYPE_INHERIT";
	        case VisibilityType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.visibilityTypeToJSON = visibilityTypeToJSON;
	function createBaseApproval() {
	    return {
	        expiredHeight: helpers_1.Long.UZERO,
	        sig: new Uint8Array()
	    };
	}
	exports.Approval = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.expiredHeight.isZero()) {
	            writer.uint32(8).uint64(message.expiredHeight);
	        }
	        if (message.sig.length !== 0) {
	            writer.uint32(18).bytes(message.sig);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseApproval();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.expiredHeight = reader.uint64();
	                    break;
	                case 2:
	                    message.sig = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            expiredHeight: (0, helpers_1.isSet)(object.expiredHeight) ? helpers_1.Long.fromValue(object.expiredHeight) : helpers_1.Long.UZERO,
	            sig: (0, helpers_1.isSet)(object.sig) ? (0, helpers_1.bytesFromBase64)(object.sig) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.expiredHeight !== undefined && (obj.expiredHeight = (message.expiredHeight || helpers_1.Long.UZERO).toString());
	        message.sig !== undefined && (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== undefined ? message.sig : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseApproval();
	        message.expiredHeight = object.expiredHeight !== undefined && object.expiredHeight !== null ? helpers_1.Long.fromValue(object.expiredHeight) : helpers_1.Long.UZERO;
	        message.sig = object.sig ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            expiredHeight: object?.expired_height,
	            sig: object?.sig
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.expired_height = message.expiredHeight;
	        obj.sig = message.sig;
	        return obj;
	    }
	};
	function createBaseSecondarySpSignDoc() {
	    return {
	        spAddress: "",
	        objectId: "",
	        checksum: new Uint8Array()
	    };
	}
	exports.SecondarySpSignDoc = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spAddress !== "") {
	            writer.uint32(10).string(message.spAddress);
	        }
	        if (message.objectId !== "") {
	            writer.uint32(18).string(message.objectId);
	        }
	        if (message.checksum.length !== 0) {
	            writer.uint32(26).bytes(message.checksum);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSecondarySpSignDoc();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spAddress = reader.string();
	                    break;
	                case 2:
	                    message.objectId = reader.string();
	                    break;
	                case 3:
	                    message.checksum = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
	            objectId: (0, helpers_1.isSet)(object.objectId) ? String(object.objectId) : "",
	            checksum: (0, helpers_1.isSet)(object.checksum) ? (0, helpers_1.bytesFromBase64)(object.checksum) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        message.objectId !== undefined && (obj.objectId = message.objectId);
	        message.checksum !== undefined && (obj.checksum = (0, helpers_1.base64FromBytes)(message.checksum !== undefined ? message.checksum : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSecondarySpSignDoc();
	        message.spAddress = object.spAddress ?? "";
	        message.objectId = object.objectId ?? "";
	        message.checksum = object.checksum ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spAddress: object?.sp_address,
	            objectId: object?.object_id,
	            checksum: object?.checksum
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sp_address = message.spAddress;
	        obj.object_id = message.objectId;
	        obj.checksum = message.checksum;
	        return obj;
	    }
	};
	
} (common$3));

var common$1 = common$3.default;

var common$2 = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    'default': common$1
}, [common$3]);

var query$5 = {};

var common = {};

var wrapper = {};

var __createBinding$5 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$5 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$5 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$5(result, mod, k);
    __setModuleDefault$5(result, mod);
    return result;
};
Object.defineProperty(wrapper, "__esModule", { value: true });
wrapper.BytesValue = wrapper.StringValue = wrapper.BoolValue = wrapper.UInt32Value = wrapper.Int32Value = wrapper.UInt64Value = wrapper.Int64Value = wrapper.FloatValue = wrapper.DoubleValue = wrapper.protobufPackage = void 0;
/* eslint-disable */
const _m0$5 = __importStar$5(minimal$1.exports);
const helpers_1$5 = helpers;
wrapper.protobufPackage = "greenfield.common";
function createBaseDoubleValue() {
    return {
        value: 0
    };
}
wrapper.DoubleValue = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(9).double(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDoubleValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? Number(object.value) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDoubleValue();
        message.value = object.value ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseFloatValue() {
    return {
        value: 0
    };
}
wrapper.FloatValue = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(13).float(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFloatValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? Number(object.value) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFloatValue();
        message.value = object.value ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseInt64Value() {
    return {
        value: helpers_1$5.Long.ZERO
    };
}
wrapper.Int64Value = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (!message.value.isZero()) {
            writer.uint32(8).int64(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInt64Value();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? helpers_1$5.Long.fromValue(object.value) : helpers_1$5.Long.ZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = (message.value || helpers_1$5.Long.ZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInt64Value();
        message.value = object.value !== undefined && object.value !== null ? helpers_1$5.Long.fromValue(object.value) : helpers_1$5.Long.ZERO;
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseUInt64Value() {
    return {
        value: helpers_1$5.Long.UZERO
    };
}
wrapper.UInt64Value = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (!message.value.isZero()) {
            writer.uint32(8).uint64(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUInt64Value();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? helpers_1$5.Long.fromValue(object.value) : helpers_1$5.Long.UZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = (message.value || helpers_1$5.Long.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUInt64Value();
        message.value = object.value !== undefined && object.value !== null ? helpers_1$5.Long.fromValue(object.value) : helpers_1$5.Long.UZERO;
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseInt32Value() {
    return {
        value: 0
    };
}
wrapper.Int32Value = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(8).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInt32Value();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? Number(object.value) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = Math.round(message.value));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInt32Value();
        message.value = object.value ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseUInt32Value() {
    return {
        value: 0
    };
}
wrapper.UInt32Value = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(8).uint32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUInt32Value();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? Number(object.value) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = Math.round(message.value));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUInt32Value();
        message.value = object.value ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseBoolValue() {
    return {
        value: false
    };
}
wrapper.BoolValue = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (message.value === true) {
            writer.uint32(8).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBoolValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? Boolean(object.value) : false
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBoolValue();
        message.value = object.value ?? false;
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseStringValue() {
    return {
        value: ""
    };
}
wrapper.StringValue = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStringValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? String(object.value) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStringValue();
        message.value = object.value ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};
function createBaseBytesValue() {
    return {
        value: new Uint8Array()
    };
}
wrapper.BytesValue = {
    encode(message, writer = _m0$5.Writer.create()) {
        if (message.value.length !== 0) {
            writer.uint32(10).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$5.Reader ? input : new _m0$5.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBytesValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: (0, helpers_1$5.isSet)(object.value) ? (0, helpers_1$5.bytesFromBase64)(object.value) : new Uint8Array()
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = (0, helpers_1$5.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBytesValue();
        message.value = object.value ?? new Uint8Array();
        return message;
    },
    fromSDK(object) {
        return {
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.value = message.value;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Principal = exports.Statement = exports.principalTypeToJSON = exports.principalTypeFromJSON = exports.PrincipalTypeSDKType = exports.PrincipalType = exports.effectToJSON = exports.effectFromJSON = exports.EffectSDKType = exports.Effect = exports.actionTypeToJSON = exports.actionTypeFromJSON = exports.ActionTypeSDKType = exports.ActionType = exports.protobufPackage = void 0;
	/* eslint-disable */
	const timestamp_1 = timestamp;
	const wrapper_1 = wrapper;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.permission";
	/** ActionType defines the operations you can execute in greenfield storage network */
	var ActionType;
	(function (ActionType) {
	    ActionType[ActionType["ACTION_UNSPECIFIED"] = 0] = "ACTION_UNSPECIFIED";
	    ActionType[ActionType["ACTION_UPDATE_BUCKET_INFO"] = 1] = "ACTION_UPDATE_BUCKET_INFO";
	    ActionType[ActionType["ACTION_DELETE_BUCKET"] = 2] = "ACTION_DELETE_BUCKET";
	    ActionType[ActionType["ACTION_CREATE_OBJECT"] = 3] = "ACTION_CREATE_OBJECT";
	    ActionType[ActionType["ACTION_DELETE_OBJECT"] = 4] = "ACTION_DELETE_OBJECT";
	    ActionType[ActionType["ACTION_COPY_OBJECT"] = 5] = "ACTION_COPY_OBJECT";
	    ActionType[ActionType["ACTION_GET_OBJECT"] = 6] = "ACTION_GET_OBJECT";
	    ActionType[ActionType["ACTION_EXECUTE_OBJECT"] = 7] = "ACTION_EXECUTE_OBJECT";
	    ActionType[ActionType["ACTION_LIST_OBJECT"] = 8] = "ACTION_LIST_OBJECT";
	    ActionType[ActionType["ACTION_UPDATE_GROUP_MEMBER"] = 9] = "ACTION_UPDATE_GROUP_MEMBER";
	    ActionType[ActionType["ACTION_DELETE_GROUP"] = 10] = "ACTION_DELETE_GROUP";
	    ActionType[ActionType["ACTION_UPDATE_OBJECT_INFO"] = 11] = "ACTION_UPDATE_OBJECT_INFO";
	    ActionType[ActionType["ACTION_TYPE_ALL"] = 99] = "ACTION_TYPE_ALL";
	    ActionType[ActionType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(ActionType = exports.ActionType || (exports.ActionType = {}));
	exports.ActionTypeSDKType = ActionType;
	function actionTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "ACTION_UNSPECIFIED":
	            return ActionType.ACTION_UNSPECIFIED;
	        case 1:
	        case "ACTION_UPDATE_BUCKET_INFO":
	            return ActionType.ACTION_UPDATE_BUCKET_INFO;
	        case 2:
	        case "ACTION_DELETE_BUCKET":
	            return ActionType.ACTION_DELETE_BUCKET;
	        case 3:
	        case "ACTION_CREATE_OBJECT":
	            return ActionType.ACTION_CREATE_OBJECT;
	        case 4:
	        case "ACTION_DELETE_OBJECT":
	            return ActionType.ACTION_DELETE_OBJECT;
	        case 5:
	        case "ACTION_COPY_OBJECT":
	            return ActionType.ACTION_COPY_OBJECT;
	        case 6:
	        case "ACTION_GET_OBJECT":
	            return ActionType.ACTION_GET_OBJECT;
	        case 7:
	        case "ACTION_EXECUTE_OBJECT":
	            return ActionType.ACTION_EXECUTE_OBJECT;
	        case 8:
	        case "ACTION_LIST_OBJECT":
	            return ActionType.ACTION_LIST_OBJECT;
	        case 9:
	        case "ACTION_UPDATE_GROUP_MEMBER":
	            return ActionType.ACTION_UPDATE_GROUP_MEMBER;
	        case 10:
	        case "ACTION_DELETE_GROUP":
	            return ActionType.ACTION_DELETE_GROUP;
	        case 11:
	        case "ACTION_UPDATE_OBJECT_INFO":
	            return ActionType.ACTION_UPDATE_OBJECT_INFO;
	        case 99:
	        case "ACTION_TYPE_ALL":
	            return ActionType.ACTION_TYPE_ALL;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return ActionType.UNRECOGNIZED;
	    }
	}
	exports.actionTypeFromJSON = actionTypeFromJSON;
	function actionTypeToJSON(object) {
	    switch (object) {
	        case ActionType.ACTION_UNSPECIFIED:
	            return "ACTION_UNSPECIFIED";
	        case ActionType.ACTION_UPDATE_BUCKET_INFO:
	            return "ACTION_UPDATE_BUCKET_INFO";
	        case ActionType.ACTION_DELETE_BUCKET:
	            return "ACTION_DELETE_BUCKET";
	        case ActionType.ACTION_CREATE_OBJECT:
	            return "ACTION_CREATE_OBJECT";
	        case ActionType.ACTION_DELETE_OBJECT:
	            return "ACTION_DELETE_OBJECT";
	        case ActionType.ACTION_COPY_OBJECT:
	            return "ACTION_COPY_OBJECT";
	        case ActionType.ACTION_GET_OBJECT:
	            return "ACTION_GET_OBJECT";
	        case ActionType.ACTION_EXECUTE_OBJECT:
	            return "ACTION_EXECUTE_OBJECT";
	        case ActionType.ACTION_LIST_OBJECT:
	            return "ACTION_LIST_OBJECT";
	        case ActionType.ACTION_UPDATE_GROUP_MEMBER:
	            return "ACTION_UPDATE_GROUP_MEMBER";
	        case ActionType.ACTION_DELETE_GROUP:
	            return "ACTION_DELETE_GROUP";
	        case ActionType.ACTION_UPDATE_OBJECT_INFO:
	            return "ACTION_UPDATE_OBJECT_INFO";
	        case ActionType.ACTION_TYPE_ALL:
	            return "ACTION_TYPE_ALL";
	        case ActionType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.actionTypeToJSON = actionTypeToJSON;
	/** Effect define the effect of the operation permission, include Allow or deny */
	var Effect;
	(function (Effect) {
	    Effect[Effect["EFFECT_UNSPECIFIED"] = 0] = "EFFECT_UNSPECIFIED";
	    Effect[Effect["EFFECT_ALLOW"] = 1] = "EFFECT_ALLOW";
	    Effect[Effect["EFFECT_DENY"] = 2] = "EFFECT_DENY";
	    Effect[Effect["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(Effect = exports.Effect || (exports.Effect = {}));
	exports.EffectSDKType = Effect;
	function effectFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "EFFECT_UNSPECIFIED":
	            return Effect.EFFECT_UNSPECIFIED;
	        case 1:
	        case "EFFECT_ALLOW":
	            return Effect.EFFECT_ALLOW;
	        case 2:
	        case "EFFECT_DENY":
	            return Effect.EFFECT_DENY;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return Effect.UNRECOGNIZED;
	    }
	}
	exports.effectFromJSON = effectFromJSON;
	function effectToJSON(object) {
	    switch (object) {
	        case Effect.EFFECT_UNSPECIFIED:
	            return "EFFECT_UNSPECIFIED";
	        case Effect.EFFECT_ALLOW:
	            return "EFFECT_ALLOW";
	        case Effect.EFFECT_DENY:
	            return "EFFECT_DENY";
	        case Effect.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.effectToJSON = effectToJSON;
	/**
	 * PrincipalType refers to the identity type of system users or entities.
	 * In Greenfield, it usually refers to accounts or groups.
	 */
	var PrincipalType;
	(function (PrincipalType) {
	    PrincipalType[PrincipalType["PRINCIPAL_TYPE_UNSPECIFIED"] = 0] = "PRINCIPAL_TYPE_UNSPECIFIED";
	    PrincipalType[PrincipalType["PRINCIPAL_TYPE_GNFD_ACCOUNT"] = 1] = "PRINCIPAL_TYPE_GNFD_ACCOUNT";
	    PrincipalType[PrincipalType["PRINCIPAL_TYPE_GNFD_GROUP"] = 2] = "PRINCIPAL_TYPE_GNFD_GROUP";
	    PrincipalType[PrincipalType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(PrincipalType = exports.PrincipalType || (exports.PrincipalType = {}));
	exports.PrincipalTypeSDKType = PrincipalType;
	function principalTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "PRINCIPAL_TYPE_UNSPECIFIED":
	            return PrincipalType.PRINCIPAL_TYPE_UNSPECIFIED;
	        case 1:
	        case "PRINCIPAL_TYPE_GNFD_ACCOUNT":
	            return PrincipalType.PRINCIPAL_TYPE_GNFD_ACCOUNT;
	        case 2:
	        case "PRINCIPAL_TYPE_GNFD_GROUP":
	            return PrincipalType.PRINCIPAL_TYPE_GNFD_GROUP;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return PrincipalType.UNRECOGNIZED;
	    }
	}
	exports.principalTypeFromJSON = principalTypeFromJSON;
	function principalTypeToJSON(object) {
	    switch (object) {
	        case PrincipalType.PRINCIPAL_TYPE_UNSPECIFIED:
	            return "PRINCIPAL_TYPE_UNSPECIFIED";
	        case PrincipalType.PRINCIPAL_TYPE_GNFD_ACCOUNT:
	            return "PRINCIPAL_TYPE_GNFD_ACCOUNT";
	        case PrincipalType.PRINCIPAL_TYPE_GNFD_GROUP:
	            return "PRINCIPAL_TYPE_GNFD_GROUP";
	        case PrincipalType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.principalTypeToJSON = principalTypeToJSON;
	function createBaseStatement() {
	    return {
	        effect: 0,
	        actions: [],
	        resources: [],
	        expirationTime: undefined,
	        limitSize: undefined
	    };
	}
	exports.Statement = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.effect !== 0) {
	            writer.uint32(8).int32(message.effect);
	        }
	        writer.uint32(18).fork();
	        for (const v of message.actions) {
	            writer.int32(v);
	        }
	        writer.ldelim();
	        for (const v of message.resources) {
	            writer.uint32(26).string(v);
	        }
	        if (message.expirationTime !== undefined) {
	            timestamp_1.Timestamp.encode(message.expirationTime, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.limitSize !== undefined) {
	            wrapper_1.UInt64Value.encode(message.limitSize, writer.uint32(42).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseStatement();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.effect = reader.int32();
	                    break;
	                case 2:
	                    if ((tag & 7) === 2) {
	                        const end2 = reader.uint32() + reader.pos;
	                        while (reader.pos < end2) {
	                            message.actions.push(reader.int32());
	                        }
	                    }
	                    else {
	                        message.actions.push(reader.int32());
	                    }
	                    break;
	                case 3:
	                    message.resources.push(reader.string());
	                    break;
	                case 4:
	                    message.expirationTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                case 5:
	                    message.limitSize = wrapper_1.UInt64Value.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            effect: (0, helpers_1.isSet)(object.effect) ? effectFromJSON(object.effect) : 0,
	            actions: Array.isArray(object?.actions) ? object.actions.map((e) => actionTypeFromJSON(e)) : [],
	            resources: Array.isArray(object?.resources) ? object.resources.map((e) => String(e)) : [],
	            expirationTime: (0, helpers_1.isSet)(object.expirationTime) ? (0, helpers_1.fromJsonTimestamp)(object.expirationTime) : undefined,
	            limitSize: (0, helpers_1.isSet)(object.limitSize) ? wrapper_1.UInt64Value.fromJSON(object.limitSize) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.effect !== undefined && (obj.effect = effectToJSON(message.effect));
	        if (message.actions) {
	            obj.actions = message.actions.map(e => actionTypeToJSON(e));
	        }
	        else {
	            obj.actions = [];
	        }
	        if (message.resources) {
	            obj.resources = message.resources.map(e => e);
	        }
	        else {
	            obj.resources = [];
	        }
	        message.expirationTime !== undefined && (obj.expirationTime = (0, helpers_1.fromTimestamp)(message.expirationTime).toISOString());
	        message.limitSize !== undefined && (obj.limitSize = message.limitSize ? wrapper_1.UInt64Value.toJSON(message.limitSize) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseStatement();
	        message.effect = object.effect ?? 0;
	        message.actions = object.actions?.map(e => e) || [];
	        message.resources = object.resources?.map(e => e) || [];
	        message.expirationTime = object.expirationTime !== undefined && object.expirationTime !== null ? timestamp_1.Timestamp.fromPartial(object.expirationTime) : undefined;
	        message.limitSize = object.limitSize !== undefined && object.limitSize !== null ? wrapper_1.UInt64Value.fromPartial(object.limitSize) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            effect: (0, helpers_1.isSet)(object.effect) ? effectFromJSON(object.effect) : 0,
	            actions: Array.isArray(object?.actions) ? object.actions.map((e) => actionTypeFromJSON(e)) : [],
	            resources: Array.isArray(object?.resources) ? object.resources.map((e) => e) : [],
	            expirationTime: object.expiration_time ? timestamp_1.Timestamp.fromSDK(object.expiration_time) : undefined,
	            limitSize: object.limit_size ? wrapper_1.UInt64Value.fromSDK(object.limit_size) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.effect !== undefined && (obj.effect = effectToJSON(message.effect));
	        if (message.actions) {
	            obj.actions = message.actions.map(e => actionTypeToJSON(e));
	        }
	        else {
	            obj.actions = [];
	        }
	        if (message.resources) {
	            obj.resources = message.resources.map(e => e);
	        }
	        else {
	            obj.resources = [];
	        }
	        message.expirationTime !== undefined && (obj.expiration_time = message.expirationTime ? timestamp_1.Timestamp.toSDK(message.expirationTime) : undefined);
	        message.limitSize !== undefined && (obj.limit_size = message.limitSize ? wrapper_1.UInt64Value.toSDK(message.limitSize) : undefined);
	        return obj;
	    }
	};
	function createBasePrincipal() {
	    return {
	        type: 0,
	        value: ""
	    };
	}
	exports.Principal = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.type !== 0) {
	            writer.uint32(8).int32(message.type);
	        }
	        if (message.value !== "") {
	            writer.uint32(18).string(message.value);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBasePrincipal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.type = reader.int32();
	                    break;
	                case 2:
	                    message.value = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? principalTypeFromJSON(object.type) : 0,
	            value: (0, helpers_1.isSet)(object.value) ? String(object.value) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = principalTypeToJSON(message.type));
	        message.value !== undefined && (obj.value = message.value);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBasePrincipal();
	        message.type = object.type ?? 0;
	        message.value = object.value ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            type: (0, helpers_1.isSet)(object.type) ? principalTypeFromJSON(object.type) : 0,
	            value: object?.value
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.type !== undefined && (obj.type = principalTypeToJSON(message.type));
	        obj.value = message.value;
	        return obj;
	    }
	};
	
} (common));

common.default;

var params$3 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.VersionedParams = exports.Params = exports.protobufPackage = void 0;
	/* eslint-disable */
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "greenfield.storage";
	function createBaseParams() {
	    return {
	        versionedParams: undefined,
	        maxPayloadSize: helpers_1.Long.UZERO,
	        mirrorBucketRelayerFee: "",
	        mirrorBucketAckRelayerFee: "",
	        mirrorObjectRelayerFee: "",
	        mirrorObjectAckRelayerFee: "",
	        mirrorGroupRelayerFee: "",
	        mirrorGroupAckRelayerFee: "",
	        maxBucketsPerAccount: 0,
	        discontinueCountingWindow: helpers_1.Long.UZERO,
	        discontinueObjectMax: helpers_1.Long.UZERO,
	        discontinueBucketMax: helpers_1.Long.UZERO,
	        discontinueConfirmPeriod: helpers_1.Long.ZERO,
	        discontinueDeletionMax: helpers_1.Long.UZERO,
	        stalePolicyCleanupMax: helpers_1.Long.UZERO
	    };
	}
	exports.Params = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.versionedParams !== undefined) {
	            exports.VersionedParams.encode(message.versionedParams, writer.uint32(10).fork()).ldelim();
	        }
	        if (!message.maxPayloadSize.isZero()) {
	            writer.uint32(16).uint64(message.maxPayloadSize);
	        }
	        if (message.mirrorBucketRelayerFee !== "") {
	            writer.uint32(26).string(message.mirrorBucketRelayerFee);
	        }
	        if (message.mirrorBucketAckRelayerFee !== "") {
	            writer.uint32(34).string(message.mirrorBucketAckRelayerFee);
	        }
	        if (message.mirrorObjectRelayerFee !== "") {
	            writer.uint32(42).string(message.mirrorObjectRelayerFee);
	        }
	        if (message.mirrorObjectAckRelayerFee !== "") {
	            writer.uint32(50).string(message.mirrorObjectAckRelayerFee);
	        }
	        if (message.mirrorGroupRelayerFee !== "") {
	            writer.uint32(58).string(message.mirrorGroupRelayerFee);
	        }
	        if (message.mirrorGroupAckRelayerFee !== "") {
	            writer.uint32(66).string(message.mirrorGroupAckRelayerFee);
	        }
	        if (message.maxBucketsPerAccount !== 0) {
	            writer.uint32(72).uint32(message.maxBucketsPerAccount);
	        }
	        if (!message.discontinueCountingWindow.isZero()) {
	            writer.uint32(80).uint64(message.discontinueCountingWindow);
	        }
	        if (!message.discontinueObjectMax.isZero()) {
	            writer.uint32(88).uint64(message.discontinueObjectMax);
	        }
	        if (!message.discontinueBucketMax.isZero()) {
	            writer.uint32(96).uint64(message.discontinueBucketMax);
	        }
	        if (!message.discontinueConfirmPeriod.isZero()) {
	            writer.uint32(104).int64(message.discontinueConfirmPeriod);
	        }
	        if (!message.discontinueDeletionMax.isZero()) {
	            writer.uint32(112).uint64(message.discontinueDeletionMax);
	        }
	        if (!message.stalePolicyCleanupMax.isZero()) {
	            writer.uint32(120).uint64(message.stalePolicyCleanupMax);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.versionedParams = exports.VersionedParams.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.maxPayloadSize = reader.uint64();
	                    break;
	                case 3:
	                    message.mirrorBucketRelayerFee = reader.string();
	                    break;
	                case 4:
	                    message.mirrorBucketAckRelayerFee = reader.string();
	                    break;
	                case 5:
	                    message.mirrorObjectRelayerFee = reader.string();
	                    break;
	                case 6:
	                    message.mirrorObjectAckRelayerFee = reader.string();
	                    break;
	                case 7:
	                    message.mirrorGroupRelayerFee = reader.string();
	                    break;
	                case 8:
	                    message.mirrorGroupAckRelayerFee = reader.string();
	                    break;
	                case 9:
	                    message.maxBucketsPerAccount = reader.uint32();
	                    break;
	                case 10:
	                    message.discontinueCountingWindow = reader.uint64();
	                    break;
	                case 11:
	                    message.discontinueObjectMax = reader.uint64();
	                    break;
	                case 12:
	                    message.discontinueBucketMax = reader.uint64();
	                    break;
	                case 13:
	                    message.discontinueConfirmPeriod = reader.int64();
	                    break;
	                case 14:
	                    message.discontinueDeletionMax = reader.uint64();
	                    break;
	                case 15:
	                    message.stalePolicyCleanupMax = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            versionedParams: (0, helpers_1.isSet)(object.versionedParams) ? exports.VersionedParams.fromJSON(object.versionedParams) : undefined,
	            maxPayloadSize: (0, helpers_1.isSet)(object.maxPayloadSize) ? helpers_1.Long.fromValue(object.maxPayloadSize) : helpers_1.Long.UZERO,
	            mirrorBucketRelayerFee: (0, helpers_1.isSet)(object.mirrorBucketRelayerFee) ? String(object.mirrorBucketRelayerFee) : "",
	            mirrorBucketAckRelayerFee: (0, helpers_1.isSet)(object.mirrorBucketAckRelayerFee) ? String(object.mirrorBucketAckRelayerFee) : "",
	            mirrorObjectRelayerFee: (0, helpers_1.isSet)(object.mirrorObjectRelayerFee) ? String(object.mirrorObjectRelayerFee) : "",
	            mirrorObjectAckRelayerFee: (0, helpers_1.isSet)(object.mirrorObjectAckRelayerFee) ? String(object.mirrorObjectAckRelayerFee) : "",
	            mirrorGroupRelayerFee: (0, helpers_1.isSet)(object.mirrorGroupRelayerFee) ? String(object.mirrorGroupRelayerFee) : "",
	            mirrorGroupAckRelayerFee: (0, helpers_1.isSet)(object.mirrorGroupAckRelayerFee) ? String(object.mirrorGroupAckRelayerFee) : "",
	            maxBucketsPerAccount: (0, helpers_1.isSet)(object.maxBucketsPerAccount) ? Number(object.maxBucketsPerAccount) : 0,
	            discontinueCountingWindow: (0, helpers_1.isSet)(object.discontinueCountingWindow) ? helpers_1.Long.fromValue(object.discontinueCountingWindow) : helpers_1.Long.UZERO,
	            discontinueObjectMax: (0, helpers_1.isSet)(object.discontinueObjectMax) ? helpers_1.Long.fromValue(object.discontinueObjectMax) : helpers_1.Long.UZERO,
	            discontinueBucketMax: (0, helpers_1.isSet)(object.discontinueBucketMax) ? helpers_1.Long.fromValue(object.discontinueBucketMax) : helpers_1.Long.UZERO,
	            discontinueConfirmPeriod: (0, helpers_1.isSet)(object.discontinueConfirmPeriod) ? helpers_1.Long.fromValue(object.discontinueConfirmPeriod) : helpers_1.Long.ZERO,
	            discontinueDeletionMax: (0, helpers_1.isSet)(object.discontinueDeletionMax) ? helpers_1.Long.fromValue(object.discontinueDeletionMax) : helpers_1.Long.UZERO,
	            stalePolicyCleanupMax: (0, helpers_1.isSet)(object.stalePolicyCleanupMax) ? helpers_1.Long.fromValue(object.stalePolicyCleanupMax) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.versionedParams !== undefined && (obj.versionedParams = message.versionedParams ? exports.VersionedParams.toJSON(message.versionedParams) : undefined);
	        message.maxPayloadSize !== undefined && (obj.maxPayloadSize = (message.maxPayloadSize || helpers_1.Long.UZERO).toString());
	        message.mirrorBucketRelayerFee !== undefined && (obj.mirrorBucketRelayerFee = message.mirrorBucketRelayerFee);
	        message.mirrorBucketAckRelayerFee !== undefined && (obj.mirrorBucketAckRelayerFee = message.mirrorBucketAckRelayerFee);
	        message.mirrorObjectRelayerFee !== undefined && (obj.mirrorObjectRelayerFee = message.mirrorObjectRelayerFee);
	        message.mirrorObjectAckRelayerFee !== undefined && (obj.mirrorObjectAckRelayerFee = message.mirrorObjectAckRelayerFee);
	        message.mirrorGroupRelayerFee !== undefined && (obj.mirrorGroupRelayerFee = message.mirrorGroupRelayerFee);
	        message.mirrorGroupAckRelayerFee !== undefined && (obj.mirrorGroupAckRelayerFee = message.mirrorGroupAckRelayerFee);
	        message.maxBucketsPerAccount !== undefined && (obj.maxBucketsPerAccount = Math.round(message.maxBucketsPerAccount));
	        message.discontinueCountingWindow !== undefined && (obj.discontinueCountingWindow = (message.discontinueCountingWindow || helpers_1.Long.UZERO).toString());
	        message.discontinueObjectMax !== undefined && (obj.discontinueObjectMax = (message.discontinueObjectMax || helpers_1.Long.UZERO).toString());
	        message.discontinueBucketMax !== undefined && (obj.discontinueBucketMax = (message.discontinueBucketMax || helpers_1.Long.UZERO).toString());
	        message.discontinueConfirmPeriod !== undefined && (obj.discontinueConfirmPeriod = (message.discontinueConfirmPeriod || helpers_1.Long.ZERO).toString());
	        message.discontinueDeletionMax !== undefined && (obj.discontinueDeletionMax = (message.discontinueDeletionMax || helpers_1.Long.UZERO).toString());
	        message.stalePolicyCleanupMax !== undefined && (obj.stalePolicyCleanupMax = (message.stalePolicyCleanupMax || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseParams();
	        message.versionedParams = object.versionedParams !== undefined && object.versionedParams !== null ? exports.VersionedParams.fromPartial(object.versionedParams) : undefined;
	        message.maxPayloadSize = object.maxPayloadSize !== undefined && object.maxPayloadSize !== null ? helpers_1.Long.fromValue(object.maxPayloadSize) : helpers_1.Long.UZERO;
	        message.mirrorBucketRelayerFee = object.mirrorBucketRelayerFee ?? "";
	        message.mirrorBucketAckRelayerFee = object.mirrorBucketAckRelayerFee ?? "";
	        message.mirrorObjectRelayerFee = object.mirrorObjectRelayerFee ?? "";
	        message.mirrorObjectAckRelayerFee = object.mirrorObjectAckRelayerFee ?? "";
	        message.mirrorGroupRelayerFee = object.mirrorGroupRelayerFee ?? "";
	        message.mirrorGroupAckRelayerFee = object.mirrorGroupAckRelayerFee ?? "";
	        message.maxBucketsPerAccount = object.maxBucketsPerAccount ?? 0;
	        message.discontinueCountingWindow = object.discontinueCountingWindow !== undefined && object.discontinueCountingWindow !== null ? helpers_1.Long.fromValue(object.discontinueCountingWindow) : helpers_1.Long.UZERO;
	        message.discontinueObjectMax = object.discontinueObjectMax !== undefined && object.discontinueObjectMax !== null ? helpers_1.Long.fromValue(object.discontinueObjectMax) : helpers_1.Long.UZERO;
	        message.discontinueBucketMax = object.discontinueBucketMax !== undefined && object.discontinueBucketMax !== null ? helpers_1.Long.fromValue(object.discontinueBucketMax) : helpers_1.Long.UZERO;
	        message.discontinueConfirmPeriod = object.discontinueConfirmPeriod !== undefined && object.discontinueConfirmPeriod !== null ? helpers_1.Long.fromValue(object.discontinueConfirmPeriod) : helpers_1.Long.ZERO;
	        message.discontinueDeletionMax = object.discontinueDeletionMax !== undefined && object.discontinueDeletionMax !== null ? helpers_1.Long.fromValue(object.discontinueDeletionMax) : helpers_1.Long.UZERO;
	        message.stalePolicyCleanupMax = object.stalePolicyCleanupMax !== undefined && object.stalePolicyCleanupMax !== null ? helpers_1.Long.fromValue(object.stalePolicyCleanupMax) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            versionedParams: object.versioned_params ? exports.VersionedParams.fromSDK(object.versioned_params) : undefined,
	            maxPayloadSize: object?.max_payload_size,
	            mirrorBucketRelayerFee: object?.mirror_bucket_relayer_fee,
	            mirrorBucketAckRelayerFee: object?.mirror_bucket_ack_relayer_fee,
	            mirrorObjectRelayerFee: object?.mirror_object_relayer_fee,
	            mirrorObjectAckRelayerFee: object?.mirror_object_ack_relayer_fee,
	            mirrorGroupRelayerFee: object?.mirror_group_relayer_fee,
	            mirrorGroupAckRelayerFee: object?.mirror_group_ack_relayer_fee,
	            maxBucketsPerAccount: object?.max_buckets_per_account,
	            discontinueCountingWindow: object?.discontinue_counting_window,
	            discontinueObjectMax: object?.discontinue_object_max,
	            discontinueBucketMax: object?.discontinue_bucket_max,
	            discontinueConfirmPeriod: object?.discontinue_confirm_period,
	            discontinueDeletionMax: object?.discontinue_deletion_max,
	            stalePolicyCleanupMax: object?.stale_policy_cleanup_max
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.versionedParams !== undefined && (obj.versioned_params = message.versionedParams ? exports.VersionedParams.toSDK(message.versionedParams) : undefined);
	        obj.max_payload_size = message.maxPayloadSize;
	        obj.mirror_bucket_relayer_fee = message.mirrorBucketRelayerFee;
	        obj.mirror_bucket_ack_relayer_fee = message.mirrorBucketAckRelayerFee;
	        obj.mirror_object_relayer_fee = message.mirrorObjectRelayerFee;
	        obj.mirror_object_ack_relayer_fee = message.mirrorObjectAckRelayerFee;
	        obj.mirror_group_relayer_fee = message.mirrorGroupRelayerFee;
	        obj.mirror_group_ack_relayer_fee = message.mirrorGroupAckRelayerFee;
	        obj.max_buckets_per_account = message.maxBucketsPerAccount;
	        obj.discontinue_counting_window = message.discontinueCountingWindow;
	        obj.discontinue_object_max = message.discontinueObjectMax;
	        obj.discontinue_bucket_max = message.discontinueBucketMax;
	        obj.discontinue_confirm_period = message.discontinueConfirmPeriod;
	        obj.discontinue_deletion_max = message.discontinueDeletionMax;
	        obj.stale_policy_cleanup_max = message.stalePolicyCleanupMax;
	        return obj;
	    }
	};
	function createBaseVersionedParams() {
	    return {
	        maxSegmentSize: helpers_1.Long.UZERO,
	        redundantDataChunkNum: 0,
	        redundantParityChunkNum: 0,
	        minChargeSize: helpers_1.Long.UZERO
	    };
	}
	exports.VersionedParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.maxSegmentSize.isZero()) {
	            writer.uint32(8).uint64(message.maxSegmentSize);
	        }
	        if (message.redundantDataChunkNum !== 0) {
	            writer.uint32(16).uint32(message.redundantDataChunkNum);
	        }
	        if (message.redundantParityChunkNum !== 0) {
	            writer.uint32(24).uint32(message.redundantParityChunkNum);
	        }
	        if (!message.minChargeSize.isZero()) {
	            writer.uint32(32).uint64(message.minChargeSize);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseVersionedParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.maxSegmentSize = reader.uint64();
	                    break;
	                case 2:
	                    message.redundantDataChunkNum = reader.uint32();
	                    break;
	                case 3:
	                    message.redundantParityChunkNum = reader.uint32();
	                    break;
	                case 4:
	                    message.minChargeSize = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            maxSegmentSize: (0, helpers_1.isSet)(object.maxSegmentSize) ? helpers_1.Long.fromValue(object.maxSegmentSize) : helpers_1.Long.UZERO,
	            redundantDataChunkNum: (0, helpers_1.isSet)(object.redundantDataChunkNum) ? Number(object.redundantDataChunkNum) : 0,
	            redundantParityChunkNum: (0, helpers_1.isSet)(object.redundantParityChunkNum) ? Number(object.redundantParityChunkNum) : 0,
	            minChargeSize: (0, helpers_1.isSet)(object.minChargeSize) ? helpers_1.Long.fromValue(object.minChargeSize) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.maxSegmentSize !== undefined && (obj.maxSegmentSize = (message.maxSegmentSize || helpers_1.Long.UZERO).toString());
	        message.redundantDataChunkNum !== undefined && (obj.redundantDataChunkNum = Math.round(message.redundantDataChunkNum));
	        message.redundantParityChunkNum !== undefined && (obj.redundantParityChunkNum = Math.round(message.redundantParityChunkNum));
	        message.minChargeSize !== undefined && (obj.minChargeSize = (message.minChargeSize || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseVersionedParams();
	        message.maxSegmentSize = object.maxSegmentSize !== undefined && object.maxSegmentSize !== null ? helpers_1.Long.fromValue(object.maxSegmentSize) : helpers_1.Long.UZERO;
	        message.redundantDataChunkNum = object.redundantDataChunkNum ?? 0;
	        message.redundantParityChunkNum = object.redundantParityChunkNum ?? 0;
	        message.minChargeSize = object.minChargeSize !== undefined && object.minChargeSize !== null ? helpers_1.Long.fromValue(object.minChargeSize) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            maxSegmentSize: object?.max_segment_size,
	            redundantDataChunkNum: object?.redundant_data_chunk_num,
	            redundantParityChunkNum: object?.redundant_parity_chunk_num,
	            minChargeSize: object?.min_charge_size
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.max_segment_size = message.maxSegmentSize;
	        obj.redundant_data_chunk_num = message.redundantDataChunkNum;
	        obj.redundant_parity_chunk_num = message.redundantParityChunkNum;
	        obj.min_charge_size = message.minChargeSize;
	        return obj;
	    }
	};
	
} (params$3));

params$3.default;

var types$4 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DeleteInfo = exports.Ids = exports.GroupMetaData = exports.ObjectMetaData = exports.BucketMetaData = exports.Trait = exports.GroupInfo = exports.ObjectInfo = exports.SecondarySpObjectsSize = exports.BillingInfo = exports.BucketInfo = exports.protobufPackage = void 0;
	/* eslint-disable */
	const common_1 = common$3;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "greenfield.storage";
	function createBaseBucketInfo() {
	    return {
	        owner: "",
	        bucketName: "",
	        visibility: 0,
	        id: "",
	        sourceType: 0,
	        createAt: helpers_1.Long.ZERO,
	        paymentAddress: "",
	        primarySpAddress: "",
	        chargedReadQuota: helpers_1.Long.UZERO,
	        billingInfo: undefined,
	        bucketStatus: 0
	    };
	}
	exports.BucketInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.owner !== "") {
	            writer.uint32(10).string(message.owner);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.visibility !== 0) {
	            writer.uint32(24).int32(message.visibility);
	        }
	        if (message.id !== "") {
	            writer.uint32(34).string(message.id);
	        }
	        if (message.sourceType !== 0) {
	            writer.uint32(40).int32(message.sourceType);
	        }
	        if (!message.createAt.isZero()) {
	            writer.uint32(48).int64(message.createAt);
	        }
	        if (message.paymentAddress !== "") {
	            writer.uint32(58).string(message.paymentAddress);
	        }
	        if (message.primarySpAddress !== "") {
	            writer.uint32(66).string(message.primarySpAddress);
	        }
	        if (!message.chargedReadQuota.isZero()) {
	            writer.uint32(72).uint64(message.chargedReadQuota);
	        }
	        if (message.billingInfo !== undefined) {
	            exports.BillingInfo.encode(message.billingInfo, writer.uint32(82).fork()).ldelim();
	        }
	        if (message.bucketStatus !== 0) {
	            writer.uint32(88).int32(message.bucketStatus);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBucketInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.owner = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.visibility = reader.int32();
	                    break;
	                case 4:
	                    message.id = reader.string();
	                    break;
	                case 5:
	                    message.sourceType = reader.int32();
	                    break;
	                case 6:
	                    message.createAt = reader.int64();
	                    break;
	                case 7:
	                    message.paymentAddress = reader.string();
	                    break;
	                case 8:
	                    message.primarySpAddress = reader.string();
	                    break;
	                case 9:
	                    message.chargedReadQuota = reader.uint64();
	                    break;
	                case 10:
	                    message.billingInfo = exports.BillingInfo.decode(reader, reader.uint32());
	                    break;
	                case 11:
	                    message.bucketStatus = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : "",
	            sourceType: (0, helpers_1.isSet)(object.sourceType) ? (0, common_1.sourceTypeFromJSON)(object.sourceType) : 0,
	            createAt: (0, helpers_1.isSet)(object.createAt) ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO,
	            paymentAddress: (0, helpers_1.isSet)(object.paymentAddress) ? String(object.paymentAddress) : "",
	            primarySpAddress: (0, helpers_1.isSet)(object.primarySpAddress) ? String(object.primarySpAddress) : "",
	            chargedReadQuota: (0, helpers_1.isSet)(object.chargedReadQuota) ? helpers_1.Long.fromValue(object.chargedReadQuota) : helpers_1.Long.UZERO,
	            billingInfo: (0, helpers_1.isSet)(object.billingInfo) ? exports.BillingInfo.fromJSON(object.billingInfo) : undefined,
	            bucketStatus: (0, helpers_1.isSet)(object.bucketStatus) ? (0, common_1.bucketStatusFromJSON)(object.bucketStatus) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.owner !== undefined && (obj.owner = message.owner);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        message.id !== undefined && (obj.id = message.id);
	        message.sourceType !== undefined && (obj.sourceType = (0, common_1.sourceTypeToJSON)(message.sourceType));
	        message.createAt !== undefined && (obj.createAt = (message.createAt || helpers_1.Long.ZERO).toString());
	        message.paymentAddress !== undefined && (obj.paymentAddress = message.paymentAddress);
	        message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);
	        message.chargedReadQuota !== undefined && (obj.chargedReadQuota = (message.chargedReadQuota || helpers_1.Long.UZERO).toString());
	        message.billingInfo !== undefined && (obj.billingInfo = message.billingInfo ? exports.BillingInfo.toJSON(message.billingInfo) : undefined);
	        message.bucketStatus !== undefined && (obj.bucketStatus = (0, common_1.bucketStatusToJSON)(message.bucketStatus));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBucketInfo();
	        message.owner = object.owner ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.visibility = object.visibility ?? 0;
	        message.id = object.id ?? "";
	        message.sourceType = object.sourceType ?? 0;
	        message.createAt = object.createAt !== undefined && object.createAt !== null ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO;
	        message.paymentAddress = object.paymentAddress ?? "";
	        message.primarySpAddress = object.primarySpAddress ?? "";
	        message.chargedReadQuota = object.chargedReadQuota !== undefined && object.chargedReadQuota !== null ? helpers_1.Long.fromValue(object.chargedReadQuota) : helpers_1.Long.UZERO;
	        message.billingInfo = object.billingInfo !== undefined && object.billingInfo !== null ? exports.BillingInfo.fromPartial(object.billingInfo) : undefined;
	        message.bucketStatus = object.bucketStatus ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            owner: object?.owner,
	            bucketName: object?.bucket_name,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            id: object?.id,
	            sourceType: (0, helpers_1.isSet)(object.source_type) ? (0, common_1.sourceTypeFromJSON)(object.source_type) : 0,
	            createAt: object?.create_at,
	            paymentAddress: object?.payment_address,
	            primarySpAddress: object?.primary_sp_address,
	            chargedReadQuota: object?.charged_read_quota,
	            billingInfo: object.billing_info ? exports.BillingInfo.fromSDK(object.billing_info) : undefined,
	            bucketStatus: (0, helpers_1.isSet)(object.bucket_status) ? (0, common_1.bucketStatusFromJSON)(object.bucket_status) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.owner = message.owner;
	        obj.bucket_name = message.bucketName;
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        obj.id = message.id;
	        message.sourceType !== undefined && (obj.source_type = (0, common_1.sourceTypeToJSON)(message.sourceType));
	        obj.create_at = message.createAt;
	        obj.payment_address = message.paymentAddress;
	        obj.primary_sp_address = message.primarySpAddress;
	        obj.charged_read_quota = message.chargedReadQuota;
	        message.billingInfo !== undefined && (obj.billing_info = message.billingInfo ? exports.BillingInfo.toSDK(message.billingInfo) : undefined);
	        message.bucketStatus !== undefined && (obj.bucket_status = (0, common_1.bucketStatusToJSON)(message.bucketStatus));
	        return obj;
	    }
	};
	function createBaseBillingInfo() {
	    return {
	        priceTime: helpers_1.Long.ZERO,
	        totalChargeSize: helpers_1.Long.UZERO,
	        secondarySpObjectsSize: []
	    };
	}
	exports.BillingInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.priceTime.isZero()) {
	            writer.uint32(8).int64(message.priceTime);
	        }
	        if (!message.totalChargeSize.isZero()) {
	            writer.uint32(16).uint64(message.totalChargeSize);
	        }
	        for (const v of message.secondarySpObjectsSize) {
	            exports.SecondarySpObjectsSize.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBillingInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.priceTime = reader.int64();
	                    break;
	                case 2:
	                    message.totalChargeSize = reader.uint64();
	                    break;
	                case 3:
	                    message.secondarySpObjectsSize.push(exports.SecondarySpObjectsSize.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            priceTime: (0, helpers_1.isSet)(object.priceTime) ? helpers_1.Long.fromValue(object.priceTime) : helpers_1.Long.ZERO,
	            totalChargeSize: (0, helpers_1.isSet)(object.totalChargeSize) ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO,
	            secondarySpObjectsSize: Array.isArray(object?.secondarySpObjectsSize) ? object.secondarySpObjectsSize.map((e) => exports.SecondarySpObjectsSize.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.priceTime !== undefined && (obj.priceTime = (message.priceTime || helpers_1.Long.ZERO).toString());
	        message.totalChargeSize !== undefined && (obj.totalChargeSize = (message.totalChargeSize || helpers_1.Long.UZERO).toString());
	        if (message.secondarySpObjectsSize) {
	            obj.secondarySpObjectsSize = message.secondarySpObjectsSize.map(e => e ? exports.SecondarySpObjectsSize.toJSON(e) : undefined);
	        }
	        else {
	            obj.secondarySpObjectsSize = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBillingInfo();
	        message.priceTime = object.priceTime !== undefined && object.priceTime !== null ? helpers_1.Long.fromValue(object.priceTime) : helpers_1.Long.ZERO;
	        message.totalChargeSize = object.totalChargeSize !== undefined && object.totalChargeSize !== null ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO;
	        message.secondarySpObjectsSize = object.secondarySpObjectsSize?.map(e => exports.SecondarySpObjectsSize.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            priceTime: object?.price_time,
	            totalChargeSize: object?.total_charge_size,
	            secondarySpObjectsSize: Array.isArray(object?.secondary_sp_objects_size) ? object.secondary_sp_objects_size.map((e) => exports.SecondarySpObjectsSize.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.price_time = message.priceTime;
	        obj.total_charge_size = message.totalChargeSize;
	        if (message.secondarySpObjectsSize) {
	            obj.secondary_sp_objects_size = message.secondarySpObjectsSize.map(e => e ? exports.SecondarySpObjectsSize.toSDK(e) : undefined);
	        }
	        else {
	            obj.secondary_sp_objects_size = [];
	        }
	        return obj;
	    }
	};
	function createBaseSecondarySpObjectsSize() {
	    return {
	        spAddress: "",
	        totalChargeSize: helpers_1.Long.UZERO
	    };
	}
	exports.SecondarySpObjectsSize = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spAddress !== "") {
	            writer.uint32(10).string(message.spAddress);
	        }
	        if (!message.totalChargeSize.isZero()) {
	            writer.uint32(16).uint64(message.totalChargeSize);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSecondarySpObjectsSize();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spAddress = reader.string();
	                    break;
	                case 2:
	                    message.totalChargeSize = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
	            totalChargeSize: (0, helpers_1.isSet)(object.totalChargeSize) ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        message.totalChargeSize !== undefined && (obj.totalChargeSize = (message.totalChargeSize || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSecondarySpObjectsSize();
	        message.spAddress = object.spAddress ?? "";
	        message.totalChargeSize = object.totalChargeSize !== undefined && object.totalChargeSize !== null ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spAddress: object?.sp_address,
	            totalChargeSize: object?.total_charge_size
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sp_address = message.spAddress;
	        obj.total_charge_size = message.totalChargeSize;
	        return obj;
	    }
	};
	function createBaseObjectInfo() {
	    return {
	        owner: "",
	        bucketName: "",
	        objectName: "",
	        id: "",
	        payloadSize: helpers_1.Long.UZERO,
	        visibility: 0,
	        contentType: "",
	        createAt: helpers_1.Long.ZERO,
	        objectStatus: 0,
	        redundancyType: 0,
	        sourceType: 0,
	        checksums: [],
	        secondarySpAddresses: []
	    };
	}
	exports.ObjectInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.owner !== "") {
	            writer.uint32(10).string(message.owner);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        if (message.id !== "") {
	            writer.uint32(34).string(message.id);
	        }
	        if (!message.payloadSize.isZero()) {
	            writer.uint32(40).uint64(message.payloadSize);
	        }
	        if (message.visibility !== 0) {
	            writer.uint32(48).int32(message.visibility);
	        }
	        if (message.contentType !== "") {
	            writer.uint32(58).string(message.contentType);
	        }
	        if (!message.createAt.isZero()) {
	            writer.uint32(64).int64(message.createAt);
	        }
	        if (message.objectStatus !== 0) {
	            writer.uint32(72).int32(message.objectStatus);
	        }
	        if (message.redundancyType !== 0) {
	            writer.uint32(80).int32(message.redundancyType);
	        }
	        if (message.sourceType !== 0) {
	            writer.uint32(88).int32(message.sourceType);
	        }
	        for (const v of message.checksums) {
	            writer.uint32(98).bytes(v);
	        }
	        for (const v of message.secondarySpAddresses) {
	            writer.uint32(106).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseObjectInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.owner = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                case 4:
	                    message.id = reader.string();
	                    break;
	                case 5:
	                    message.payloadSize = reader.uint64();
	                    break;
	                case 6:
	                    message.visibility = reader.int32();
	                    break;
	                case 7:
	                    message.contentType = reader.string();
	                    break;
	                case 8:
	                    message.createAt = reader.int64();
	                    break;
	                case 9:
	                    message.objectStatus = reader.int32();
	                    break;
	                case 10:
	                    message.redundancyType = reader.int32();
	                    break;
	                case 11:
	                    message.sourceType = reader.int32();
	                    break;
	                case 12:
	                    message.checksums.push(reader.bytes());
	                    break;
	                case 13:
	                    message.secondarySpAddresses.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : "",
	            payloadSize: (0, helpers_1.isSet)(object.payloadSize) ? helpers_1.Long.fromValue(object.payloadSize) : helpers_1.Long.UZERO,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            contentType: (0, helpers_1.isSet)(object.contentType) ? String(object.contentType) : "",
	            createAt: (0, helpers_1.isSet)(object.createAt) ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO,
	            objectStatus: (0, helpers_1.isSet)(object.objectStatus) ? (0, common_1.objectStatusFromJSON)(object.objectStatus) : 0,
	            redundancyType: (0, helpers_1.isSet)(object.redundancyType) ? (0, common_1.redundancyTypeFromJSON)(object.redundancyType) : 0,
	            sourceType: (0, helpers_1.isSet)(object.sourceType) ? (0, common_1.sourceTypeFromJSON)(object.sourceType) : 0,
	            checksums: Array.isArray(object?.checksums) ? object.checksums.map((e) => (0, helpers_1.bytesFromBase64)(e)) : [],
	            secondarySpAddresses: Array.isArray(object?.secondarySpAddresses) ? object.secondarySpAddresses.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.owner !== undefined && (obj.owner = message.owner);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        message.id !== undefined && (obj.id = message.id);
	        message.payloadSize !== undefined && (obj.payloadSize = (message.payloadSize || helpers_1.Long.UZERO).toString());
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        message.contentType !== undefined && (obj.contentType = message.contentType);
	        message.createAt !== undefined && (obj.createAt = (message.createAt || helpers_1.Long.ZERO).toString());
	        message.objectStatus !== undefined && (obj.objectStatus = (0, common_1.objectStatusToJSON)(message.objectStatus));
	        message.redundancyType !== undefined && (obj.redundancyType = (0, common_1.redundancyTypeToJSON)(message.redundancyType));
	        message.sourceType !== undefined && (obj.sourceType = (0, common_1.sourceTypeToJSON)(message.sourceType));
	        if (message.checksums) {
	            obj.checksums = message.checksums.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.checksums = [];
	        }
	        if (message.secondarySpAddresses) {
	            obj.secondarySpAddresses = message.secondarySpAddresses.map(e => e);
	        }
	        else {
	            obj.secondarySpAddresses = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseObjectInfo();
	        message.owner = object.owner ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        message.id = object.id ?? "";
	        message.payloadSize = object.payloadSize !== undefined && object.payloadSize !== null ? helpers_1.Long.fromValue(object.payloadSize) : helpers_1.Long.UZERO;
	        message.visibility = object.visibility ?? 0;
	        message.contentType = object.contentType ?? "";
	        message.createAt = object.createAt !== undefined && object.createAt !== null ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO;
	        message.objectStatus = object.objectStatus ?? 0;
	        message.redundancyType = object.redundancyType ?? 0;
	        message.sourceType = object.sourceType ?? 0;
	        message.checksums = object.checksums?.map(e => e) || [];
	        message.secondarySpAddresses = object.secondarySpAddresses?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            owner: object?.owner,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name,
	            id: object?.id,
	            payloadSize: object?.payload_size,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            contentType: object?.content_type,
	            createAt: object?.create_at,
	            objectStatus: (0, helpers_1.isSet)(object.object_status) ? (0, common_1.objectStatusFromJSON)(object.object_status) : 0,
	            redundancyType: (0, helpers_1.isSet)(object.redundancy_type) ? (0, common_1.redundancyTypeFromJSON)(object.redundancy_type) : 0,
	            sourceType: (0, helpers_1.isSet)(object.source_type) ? (0, common_1.sourceTypeFromJSON)(object.source_type) : 0,
	            checksums: Array.isArray(object?.checksums) ? object.checksums.map((e) => e) : [],
	            secondarySpAddresses: Array.isArray(object?.secondary_sp_addresses) ? object.secondary_sp_addresses.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.owner = message.owner;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        obj.id = message.id;
	        obj.payload_size = message.payloadSize;
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        obj.content_type = message.contentType;
	        obj.create_at = message.createAt;
	        message.objectStatus !== undefined && (obj.object_status = (0, common_1.objectStatusToJSON)(message.objectStatus));
	        message.redundancyType !== undefined && (obj.redundancy_type = (0, common_1.redundancyTypeToJSON)(message.redundancyType));
	        message.sourceType !== undefined && (obj.source_type = (0, common_1.sourceTypeToJSON)(message.sourceType));
	        if (message.checksums) {
	            obj.checksums = message.checksums.map(e => e);
	        }
	        else {
	            obj.checksums = [];
	        }
	        if (message.secondarySpAddresses) {
	            obj.secondary_sp_addresses = message.secondarySpAddresses.map(e => e);
	        }
	        else {
	            obj.secondary_sp_addresses = [];
	        }
	        return obj;
	    }
	};
	function createBaseGroupInfo() {
	    return {
	        owner: "",
	        groupName: "",
	        sourceType: 0,
	        id: ""
	    };
	}
	exports.GroupInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.owner !== "") {
	            writer.uint32(10).string(message.owner);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(18).string(message.groupName);
	        }
	        if (message.sourceType !== 0) {
	            writer.uint32(24).int32(message.sourceType);
	        }
	        if (message.id !== "") {
	            writer.uint32(34).string(message.id);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGroupInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.owner = reader.string();
	                    break;
	                case 2:
	                    message.groupName = reader.string();
	                    break;
	                case 3:
	                    message.sourceType = reader.int32();
	                    break;
	                case 4:
	                    message.id = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : "",
	            sourceType: (0, helpers_1.isSet)(object.sourceType) ? (0, common_1.sourceTypeFromJSON)(object.sourceType) : 0,
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.owner !== undefined && (obj.owner = message.owner);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        message.sourceType !== undefined && (obj.sourceType = (0, common_1.sourceTypeToJSON)(message.sourceType));
	        message.id !== undefined && (obj.id = message.id);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGroupInfo();
	        message.owner = object.owner ?? "";
	        message.groupName = object.groupName ?? "";
	        message.sourceType = object.sourceType ?? 0;
	        message.id = object.id ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            owner: object?.owner,
	            groupName: object?.group_name,
	            sourceType: (0, helpers_1.isSet)(object.source_type) ? (0, common_1.sourceTypeFromJSON)(object.source_type) : 0,
	            id: object?.id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.owner = message.owner;
	        obj.group_name = message.groupName;
	        message.sourceType !== undefined && (obj.source_type = (0, common_1.sourceTypeToJSON)(message.sourceType));
	        obj.id = message.id;
	        return obj;
	    }
	};
	function createBaseTrait() {
	    return {
	        traitType: "",
	        value: ""
	    };
	}
	exports.Trait = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.traitType !== "") {
	            writer.uint32(10).string(message.traitType);
	        }
	        if (message.value !== "") {
	            writer.uint32(18).string(message.value);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseTrait();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.traitType = reader.string();
	                    break;
	                case 2:
	                    message.value = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            traitType: (0, helpers_1.isSet)(object.traitType) ? String(object.traitType) : "",
	            value: (0, helpers_1.isSet)(object.value) ? String(object.value) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.traitType !== undefined && (obj.traitType = message.traitType);
	        message.value !== undefined && (obj.value = message.value);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseTrait();
	        message.traitType = object.traitType ?? "";
	        message.value = object.value ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            traitType: object?.trait_type,
	            value: object?.value
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.trait_type = message.traitType;
	        obj.value = message.value;
	        return obj;
	    }
	};
	function createBaseBucketMetaData() {
	    return {
	        description: "",
	        externalUrl: "",
	        bucketName: "",
	        image: "",
	        attributes: []
	    };
	}
	exports.BucketMetaData = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.description !== "") {
	            writer.uint32(10).string(message.description);
	        }
	        if (message.externalUrl !== "") {
	            writer.uint32(18).string(message.externalUrl);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(26).string(message.bucketName);
	        }
	        if (message.image !== "") {
	            writer.uint32(34).string(message.image);
	        }
	        for (const v of message.attributes) {
	            exports.Trait.encode(v, writer.uint32(42).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseBucketMetaData();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.description = reader.string();
	                    break;
	                case 2:
	                    message.externalUrl = reader.string();
	                    break;
	                case 3:
	                    message.bucketName = reader.string();
	                    break;
	                case 4:
	                    message.image = reader.string();
	                    break;
	                case 5:
	                    message.attributes.push(exports.Trait.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
	            externalUrl: (0, helpers_1.isSet)(object.externalUrl) ? String(object.externalUrl) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            image: (0, helpers_1.isSet)(object.image) ? String(object.image) : "",
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.description !== undefined && (obj.description = message.description);
	        message.externalUrl !== undefined && (obj.externalUrl = message.externalUrl);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.image !== undefined && (obj.image = message.image);
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Trait.toJSON(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseBucketMetaData();
	        message.description = object.description ?? "";
	        message.externalUrl = object.externalUrl ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.image = object.image ?? "";
	        message.attributes = object.attributes?.map(e => exports.Trait.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            description: object?.description,
	            externalUrl: object?.external_url,
	            bucketName: object?.bucket_name,
	            image: object?.image,
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.description = message.description;
	        obj.external_url = message.externalUrl;
	        obj.bucket_name = message.bucketName;
	        obj.image = message.image;
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Trait.toSDK(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    }
	};
	function createBaseObjectMetaData() {
	    return {
	        description: "",
	        externalUrl: "",
	        objectName: "",
	        image: "",
	        attributes: []
	    };
	}
	exports.ObjectMetaData = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.description !== "") {
	            writer.uint32(10).string(message.description);
	        }
	        if (message.externalUrl !== "") {
	            writer.uint32(18).string(message.externalUrl);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        if (message.image !== "") {
	            writer.uint32(34).string(message.image);
	        }
	        for (const v of message.attributes) {
	            exports.Trait.encode(v, writer.uint32(42).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseObjectMetaData();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.description = reader.string();
	                    break;
	                case 2:
	                    message.externalUrl = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                case 4:
	                    message.image = reader.string();
	                    break;
	                case 5:
	                    message.attributes.push(exports.Trait.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
	            externalUrl: (0, helpers_1.isSet)(object.externalUrl) ? String(object.externalUrl) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
	            image: (0, helpers_1.isSet)(object.image) ? String(object.image) : "",
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.description !== undefined && (obj.description = message.description);
	        message.externalUrl !== undefined && (obj.externalUrl = message.externalUrl);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        message.image !== undefined && (obj.image = message.image);
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Trait.toJSON(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseObjectMetaData();
	        message.description = object.description ?? "";
	        message.externalUrl = object.externalUrl ?? "";
	        message.objectName = object.objectName ?? "";
	        message.image = object.image ?? "";
	        message.attributes = object.attributes?.map(e => exports.Trait.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            description: object?.description,
	            externalUrl: object?.external_url,
	            objectName: object?.object_name,
	            image: object?.image,
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.description = message.description;
	        obj.external_url = message.externalUrl;
	        obj.object_name = message.objectName;
	        obj.image = message.image;
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Trait.toSDK(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    }
	};
	function createBaseGroupMetaData() {
	    return {
	        description: "",
	        externalUrl: "",
	        groupName: "",
	        image: "",
	        attributes: []
	    };
	}
	exports.GroupMetaData = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.description !== "") {
	            writer.uint32(10).string(message.description);
	        }
	        if (message.externalUrl !== "") {
	            writer.uint32(18).string(message.externalUrl);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(26).string(message.groupName);
	        }
	        if (message.image !== "") {
	            writer.uint32(34).string(message.image);
	        }
	        for (const v of message.attributes) {
	            exports.Trait.encode(v, writer.uint32(42).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGroupMetaData();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.description = reader.string();
	                    break;
	                case 2:
	                    message.externalUrl = reader.string();
	                    break;
	                case 3:
	                    message.groupName = reader.string();
	                    break;
	                case 4:
	                    message.image = reader.string();
	                    break;
	                case 5:
	                    message.attributes.push(exports.Trait.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
	            externalUrl: (0, helpers_1.isSet)(object.externalUrl) ? String(object.externalUrl) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : "",
	            image: (0, helpers_1.isSet)(object.image) ? String(object.image) : "",
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.description !== undefined && (obj.description = message.description);
	        message.externalUrl !== undefined && (obj.externalUrl = message.externalUrl);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        message.image !== undefined && (obj.image = message.image);
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Trait.toJSON(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGroupMetaData();
	        message.description = object.description ?? "";
	        message.externalUrl = object.externalUrl ?? "";
	        message.groupName = object.groupName ?? "";
	        message.image = object.image ?? "";
	        message.attributes = object.attributes?.map(e => exports.Trait.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            description: object?.description,
	            externalUrl: object?.external_url,
	            groupName: object?.group_name,
	            image: object?.image,
	            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.description = message.description;
	        obj.external_url = message.externalUrl;
	        obj.group_name = message.groupName;
	        obj.image = message.image;
	        if (message.attributes) {
	            obj.attributes = message.attributes.map(e => e ? exports.Trait.toSDK(e) : undefined);
	        }
	        else {
	            obj.attributes = [];
	        }
	        return obj;
	    }
	};
	function createBaseIds() {
	    return {
	        id: []
	    };
	}
	exports.Ids = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.id) {
	            writer.uint32(10).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseIds();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.id.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            id: Array.isArray(object?.id) ? object.id.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.id) {
	            obj.id = message.id.map(e => e);
	        }
	        else {
	            obj.id = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseIds();
	        message.id = object.id?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            id: Array.isArray(object?.id) ? object.id.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.id) {
	            obj.id = message.id.map(e => e);
	        }
	        else {
	            obj.id = [];
	        }
	        return obj;
	    }
	};
	function createBaseDeleteInfo() {
	    return {
	        bucketIds: undefined,
	        objectIds: undefined,
	        groupIds: undefined
	    };
	}
	exports.DeleteInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bucketIds !== undefined) {
	            exports.Ids.encode(message.bucketIds, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.objectIds !== undefined) {
	            exports.Ids.encode(message.objectIds, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.groupIds !== undefined) {
	            exports.Ids.encode(message.groupIds, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDeleteInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bucketIds = exports.Ids.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.objectIds = exports.Ids.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.groupIds = exports.Ids.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bucketIds: (0, helpers_1.isSet)(object.bucketIds) ? exports.Ids.fromJSON(object.bucketIds) : undefined,
	            objectIds: (0, helpers_1.isSet)(object.objectIds) ? exports.Ids.fromJSON(object.objectIds) : undefined,
	            groupIds: (0, helpers_1.isSet)(object.groupIds) ? exports.Ids.fromJSON(object.groupIds) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bucketIds !== undefined && (obj.bucketIds = message.bucketIds ? exports.Ids.toJSON(message.bucketIds) : undefined);
	        message.objectIds !== undefined && (obj.objectIds = message.objectIds ? exports.Ids.toJSON(message.objectIds) : undefined);
	        message.groupIds !== undefined && (obj.groupIds = message.groupIds ? exports.Ids.toJSON(message.groupIds) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDeleteInfo();
	        message.bucketIds = object.bucketIds !== undefined && object.bucketIds !== null ? exports.Ids.fromPartial(object.bucketIds) : undefined;
	        message.objectIds = object.objectIds !== undefined && object.objectIds !== null ? exports.Ids.fromPartial(object.objectIds) : undefined;
	        message.groupIds = object.groupIds !== undefined && object.groupIds !== null ? exports.Ids.fromPartial(object.groupIds) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bucketIds: object.bucket_ids ? exports.Ids.fromSDK(object.bucket_ids) : undefined,
	            objectIds: object.object_ids ? exports.Ids.fromSDK(object.object_ids) : undefined,
	            groupIds: object.group_ids ? exports.Ids.fromSDK(object.group_ids) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.bucketIds !== undefined && (obj.bucket_ids = message.bucketIds ? exports.Ids.toSDK(message.bucketIds) : undefined);
	        message.objectIds !== undefined && (obj.object_ids = message.objectIds ? exports.Ids.toSDK(message.objectIds) : undefined);
	        message.groupIds !== undefined && (obj.group_ids = message.groupIds ? exports.Ids.toSDK(message.groupIds) : undefined);
	        return obj;
	    }
	};
	
} (types$4));

types$4.default;

var types$3 = {};

var types$2 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resourceTypeToJSON = exports.resourceTypeFromJSON = exports.ResourceTypeSDKType = exports.ResourceType = exports.protobufPackage = void 0;
	/* eslint-disable */
	exports.protobufPackage = "greenfield.resource";
	var ResourceType;
	(function (ResourceType) {
	    ResourceType[ResourceType["RESOURCE_TYPE_UNSPECIFIED"] = 0] = "RESOURCE_TYPE_UNSPECIFIED";
	    ResourceType[ResourceType["RESOURCE_TYPE_BUCKET"] = 1] = "RESOURCE_TYPE_BUCKET";
	    ResourceType[ResourceType["RESOURCE_TYPE_OBJECT"] = 2] = "RESOURCE_TYPE_OBJECT";
	    ResourceType[ResourceType["RESOURCE_TYPE_GROUP"] = 3] = "RESOURCE_TYPE_GROUP";
	    ResourceType[ResourceType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(ResourceType = exports.ResourceType || (exports.ResourceType = {}));
	exports.ResourceTypeSDKType = ResourceType;
	function resourceTypeFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "RESOURCE_TYPE_UNSPECIFIED":
	            return ResourceType.RESOURCE_TYPE_UNSPECIFIED;
	        case 1:
	        case "RESOURCE_TYPE_BUCKET":
	            return ResourceType.RESOURCE_TYPE_BUCKET;
	        case 2:
	        case "RESOURCE_TYPE_OBJECT":
	            return ResourceType.RESOURCE_TYPE_OBJECT;
	        case 3:
	        case "RESOURCE_TYPE_GROUP":
	            return ResourceType.RESOURCE_TYPE_GROUP;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return ResourceType.UNRECOGNIZED;
	    }
	}
	exports.resourceTypeFromJSON = resourceTypeFromJSON;
	function resourceTypeToJSON(object) {
	    switch (object) {
	        case ResourceType.RESOURCE_TYPE_UNSPECIFIED:
	            return "RESOURCE_TYPE_UNSPECIFIED";
	        case ResourceType.RESOURCE_TYPE_BUCKET:
	            return "RESOURCE_TYPE_BUCKET";
	        case ResourceType.RESOURCE_TYPE_OBJECT:
	            return "RESOURCE_TYPE_OBJECT";
	        case ResourceType.RESOURCE_TYPE_GROUP:
	            return "RESOURCE_TYPE_GROUP";
	        case ResourceType.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.resourceTypeToJSON = resourceTypeToJSON;
	
} (types$2));

types$2.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GroupMember = exports.PolicyGroup_Item = exports.PolicyGroup = exports.Policy = exports.protobufPackage = void 0;
	/* eslint-disable */
	const common_1 = common;
	const types_1 = types$2;
	const timestamp_1 = timestamp;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.permission";
	function createBasePolicy() {
	    return {
	        id: "",
	        principal: undefined,
	        resourceType: 0,
	        resourceId: "",
	        statements: [],
	        expirationTime: undefined
	    };
	}
	exports.Policy = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.id !== "") {
	            writer.uint32(10).string(message.id);
	        }
	        if (message.principal !== undefined) {
	            common_1.Principal.encode(message.principal, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.resourceType !== 0) {
	            writer.uint32(24).int32(message.resourceType);
	        }
	        if (message.resourceId !== "") {
	            writer.uint32(34).string(message.resourceId);
	        }
	        for (const v of message.statements) {
	            common_1.Statement.encode(v, writer.uint32(42).fork()).ldelim();
	        }
	        if (message.expirationTime !== undefined) {
	            timestamp_1.Timestamp.encode(message.expirationTime, writer.uint32(50).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBasePolicy();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.id = reader.string();
	                    break;
	                case 2:
	                    message.principal = common_1.Principal.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.resourceType = reader.int32();
	                    break;
	                case 4:
	                    message.resourceId = reader.string();
	                    break;
	                case 5:
	                    message.statements.push(common_1.Statement.decode(reader, reader.uint32()));
	                    break;
	                case 6:
	                    message.expirationTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : "",
	            principal: (0, helpers_1.isSet)(object.principal) ? common_1.Principal.fromJSON(object.principal) : undefined,
	            resourceType: (0, helpers_1.isSet)(object.resourceType) ? (0, types_1.resourceTypeFromJSON)(object.resourceType) : 0,
	            resourceId: (0, helpers_1.isSet)(object.resourceId) ? String(object.resourceId) : "",
	            statements: Array.isArray(object?.statements) ? object.statements.map((e) => common_1.Statement.fromJSON(e)) : [],
	            expirationTime: (0, helpers_1.isSet)(object.expirationTime) ? (0, helpers_1.fromJsonTimestamp)(object.expirationTime) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.id !== undefined && (obj.id = message.id);
	        message.principal !== undefined && (obj.principal = message.principal ? common_1.Principal.toJSON(message.principal) : undefined);
	        message.resourceType !== undefined && (obj.resourceType = (0, types_1.resourceTypeToJSON)(message.resourceType));
	        message.resourceId !== undefined && (obj.resourceId = message.resourceId);
	        if (message.statements) {
	            obj.statements = message.statements.map(e => e ? common_1.Statement.toJSON(e) : undefined);
	        }
	        else {
	            obj.statements = [];
	        }
	        message.expirationTime !== undefined && (obj.expirationTime = (0, helpers_1.fromTimestamp)(message.expirationTime).toISOString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBasePolicy();
	        message.id = object.id ?? "";
	        message.principal = object.principal !== undefined && object.principal !== null ? common_1.Principal.fromPartial(object.principal) : undefined;
	        message.resourceType = object.resourceType ?? 0;
	        message.resourceId = object.resourceId ?? "";
	        message.statements = object.statements?.map(e => common_1.Statement.fromPartial(e)) || [];
	        message.expirationTime = object.expirationTime !== undefined && object.expirationTime !== null ? timestamp_1.Timestamp.fromPartial(object.expirationTime) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            id: object?.id,
	            principal: object.principal ? common_1.Principal.fromSDK(object.principal) : undefined,
	            resourceType: (0, helpers_1.isSet)(object.resource_type) ? (0, types_1.resourceTypeFromJSON)(object.resource_type) : 0,
	            resourceId: object?.resource_id,
	            statements: Array.isArray(object?.statements) ? object.statements.map((e) => common_1.Statement.fromSDK(e)) : [],
	            expirationTime: object.expiration_time ? timestamp_1.Timestamp.fromSDK(object.expiration_time) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.id = message.id;
	        message.principal !== undefined && (obj.principal = message.principal ? common_1.Principal.toSDK(message.principal) : undefined);
	        message.resourceType !== undefined && (obj.resource_type = (0, types_1.resourceTypeToJSON)(message.resourceType));
	        obj.resource_id = message.resourceId;
	        if (message.statements) {
	            obj.statements = message.statements.map(e => e ? common_1.Statement.toSDK(e) : undefined);
	        }
	        else {
	            obj.statements = [];
	        }
	        message.expirationTime !== undefined && (obj.expiration_time = message.expirationTime ? timestamp_1.Timestamp.toSDK(message.expirationTime) : undefined);
	        return obj;
	    }
	};
	function createBasePolicyGroup() {
	    return {
	        items: []
	    };
	}
	exports.PolicyGroup = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.items) {
	            exports.PolicyGroup_Item.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBasePolicyGroup();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.items.push(exports.PolicyGroup_Item.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            items: Array.isArray(object?.items) ? object.items.map((e) => exports.PolicyGroup_Item.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.items) {
	            obj.items = message.items.map(e => e ? exports.PolicyGroup_Item.toJSON(e) : undefined);
	        }
	        else {
	            obj.items = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBasePolicyGroup();
	        message.items = object.items?.map(e => exports.PolicyGroup_Item.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            items: Array.isArray(object?.items) ? object.items.map((e) => exports.PolicyGroup_Item.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.items) {
	            obj.items = message.items.map(e => e ? exports.PolicyGroup_Item.toSDK(e) : undefined);
	        }
	        else {
	            obj.items = [];
	        }
	        return obj;
	    }
	};
	function createBasePolicyGroup_Item() {
	    return {
	        policyId: "",
	        groupId: ""
	    };
	}
	exports.PolicyGroup_Item = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.policyId !== "") {
	            writer.uint32(10).string(message.policyId);
	        }
	        if (message.groupId !== "") {
	            writer.uint32(18).string(message.groupId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBasePolicyGroup_Item();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.policyId = reader.string();
	                    break;
	                case 2:
	                    message.groupId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            policyId: (0, helpers_1.isSet)(object.policyId) ? String(object.policyId) : "",
	            groupId: (0, helpers_1.isSet)(object.groupId) ? String(object.groupId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.policyId !== undefined && (obj.policyId = message.policyId);
	        message.groupId !== undefined && (obj.groupId = message.groupId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBasePolicyGroup_Item();
	        message.policyId = object.policyId ?? "";
	        message.groupId = object.groupId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            policyId: object?.policy_id,
	            groupId: object?.group_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.policy_id = message.policyId;
	        obj.group_id = message.groupId;
	        return obj;
	    }
	};
	function createBaseGroupMember() {
	    return {
	        id: "",
	        groupId: "",
	        member: ""
	    };
	}
	exports.GroupMember = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.id !== "") {
	            writer.uint32(10).string(message.id);
	        }
	        if (message.groupId !== "") {
	            writer.uint32(18).string(message.groupId);
	        }
	        if (message.member !== "") {
	            writer.uint32(26).string(message.member);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseGroupMember();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.id = reader.string();
	                    break;
	                case 2:
	                    message.groupId = reader.string();
	                    break;
	                case 3:
	                    message.member = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : "",
	            groupId: (0, helpers_1.isSet)(object.groupId) ? String(object.groupId) : "",
	            member: (0, helpers_1.isSet)(object.member) ? String(object.member) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.id !== undefined && (obj.id = message.id);
	        message.groupId !== undefined && (obj.groupId = message.groupId);
	        message.member !== undefined && (obj.member = message.member);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseGroupMember();
	        message.id = object.id ?? "";
	        message.groupId = object.groupId ?? "";
	        message.member = object.member ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            id: object?.id,
	            groupId: object?.group_id,
	            member: object?.member
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.id = message.id;
	        obj.group_id = message.groupId;
	        obj.member = message.member;
	        return obj;
	    }
	};
	
} (types$3));

types$3.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QueryPolicyByIdResponse = exports.QueryPolicyByIdRequest = exports.QueryPolicyForGroupResponse = exports.QueryPolicyForGroupRequest = exports.QueryHeadGroupMemberResponse = exports.QueryHeadGroupMemberRequest = exports.QueryListGroupResponse = exports.QueryListGroupRequest = exports.QueryHeadGroupResponse = exports.QueryHeadGroupRequest = exports.QueryVerifyPermissionResponse = exports.QueryVerifyPermissionRequest = exports.QueryPolicyForAccountResponse = exports.QueryPolicyForAccountRequest = exports.QueryGroupNFTResponse = exports.QueryObjectNFTResponse = exports.QueryBucketNFTResponse = exports.QueryNFTRequest = exports.QueryListObjectsResponse = exports.QueryListObjectsByBucketIdRequest = exports.QueryListObjectsRequest = exports.QueryListBucketsResponse = exports.QueryListBucketsRequest = exports.QueryHeadObjectResponse = exports.QueryHeadObjectByIdRequest = exports.QueryHeadObjectRequest = exports.QueryHeadBucketResponse = exports.QueryHeadBucketByIdRequest = exports.QueryHeadBucketRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const pagination_1 = pagination;
	const common_1 = common;
	const params_1 = params$3;
	const types_1 = types$4;
	const types_2 = types$3;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.storage";
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryHeadBucketRequest() {
	    return {
	        bucketName: ""
	    };
	}
	exports.QueryHeadBucketRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bucketName !== "") {
	            writer.uint32(10).string(message.bucketName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadBucketRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bucketName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadBucketRequest();
	        message.bucketName = object.bucketName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bucketName: object?.bucket_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.bucket_name = message.bucketName;
	        return obj;
	    }
	};
	function createBaseQueryHeadBucketByIdRequest() {
	    return {
	        bucketId: ""
	    };
	}
	exports.QueryHeadBucketByIdRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bucketId !== "") {
	            writer.uint32(10).string(message.bucketId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadBucketByIdRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bucketId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bucketId: (0, helpers_1.isSet)(object.bucketId) ? String(object.bucketId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bucketId !== undefined && (obj.bucketId = message.bucketId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadBucketByIdRequest();
	        message.bucketId = object.bucketId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bucketId: object?.bucket_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.bucket_id = message.bucketId;
	        return obj;
	    }
	};
	function createBaseQueryHeadBucketResponse() {
	    return {
	        bucketInfo: undefined
	    };
	}
	exports.QueryHeadBucketResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bucketInfo !== undefined) {
	            types_1.BucketInfo.encode(message.bucketInfo, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadBucketResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bucketInfo = types_1.BucketInfo.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bucketInfo: (0, helpers_1.isSet)(object.bucketInfo) ? types_1.BucketInfo.fromJSON(object.bucketInfo) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bucketInfo !== undefined && (obj.bucketInfo = message.bucketInfo ? types_1.BucketInfo.toJSON(message.bucketInfo) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadBucketResponse();
	        message.bucketInfo = object.bucketInfo !== undefined && object.bucketInfo !== null ? types_1.BucketInfo.fromPartial(object.bucketInfo) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bucketInfo: object.bucket_info ? types_1.BucketInfo.fromSDK(object.bucket_info) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.bucketInfo !== undefined && (obj.bucket_info = message.bucketInfo ? types_1.BucketInfo.toSDK(message.bucketInfo) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryHeadObjectRequest() {
	    return {
	        bucketName: "",
	        objectName: ""
	    };
	}
	exports.QueryHeadObjectRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bucketName !== "") {
	            writer.uint32(10).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(18).string(message.objectName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadObjectRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bucketName = reader.string();
	                    break;
	                case 2:
	                    message.objectName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadObjectRequest();
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        return obj;
	    }
	};
	function createBaseQueryHeadObjectByIdRequest() {
	    return {
	        objectId: ""
	    };
	}
	exports.QueryHeadObjectByIdRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.objectId !== "") {
	            writer.uint32(10).string(message.objectId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadObjectByIdRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.objectId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            objectId: (0, helpers_1.isSet)(object.objectId) ? String(object.objectId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.objectId !== undefined && (obj.objectId = message.objectId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadObjectByIdRequest();
	        message.objectId = object.objectId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            objectId: object?.object_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.object_id = message.objectId;
	        return obj;
	    }
	};
	function createBaseQueryHeadObjectResponse() {
	    return {
	        objectInfo: undefined
	    };
	}
	exports.QueryHeadObjectResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.objectInfo !== undefined) {
	            types_1.ObjectInfo.encode(message.objectInfo, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.objectInfo = types_1.ObjectInfo.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            objectInfo: (0, helpers_1.isSet)(object.objectInfo) ? types_1.ObjectInfo.fromJSON(object.objectInfo) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.objectInfo !== undefined && (obj.objectInfo = message.objectInfo ? types_1.ObjectInfo.toJSON(message.objectInfo) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadObjectResponse();
	        message.objectInfo = object.objectInfo !== undefined && object.objectInfo !== null ? types_1.ObjectInfo.fromPartial(object.objectInfo) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            objectInfo: object.object_info ? types_1.ObjectInfo.fromSDK(object.object_info) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.objectInfo !== undefined && (obj.object_info = message.objectInfo ? types_1.ObjectInfo.toSDK(message.objectInfo) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryListBucketsRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryListBucketsRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryListBucketsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryListBucketsRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryListBucketsResponse() {
	    return {
	        bucketInfos: [],
	        pagination: undefined
	    };
	}
	exports.QueryListBucketsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.bucketInfos) {
	            types_1.BucketInfo.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryListBucketsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bucketInfos.push(types_1.BucketInfo.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bucketInfos: Array.isArray(object?.bucketInfos) ? object.bucketInfos.map((e) => types_1.BucketInfo.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.bucketInfos) {
	            obj.bucketInfos = message.bucketInfos.map(e => e ? types_1.BucketInfo.toJSON(e) : undefined);
	        }
	        else {
	            obj.bucketInfos = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryListBucketsResponse();
	        message.bucketInfos = object.bucketInfos?.map(e => types_1.BucketInfo.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bucketInfos: Array.isArray(object?.bucket_infos) ? object.bucket_infos.map((e) => types_1.BucketInfo.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.bucketInfos) {
	            obj.bucket_infos = message.bucketInfos.map(e => e ? types_1.BucketInfo.toSDK(e) : undefined);
	        }
	        else {
	            obj.bucket_infos = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryListObjectsRequest() {
	    return {
	        pagination: undefined,
	        bucketName: ""
	    };
	}
	exports.QueryListObjectsRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryListObjectsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryListObjectsRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        message.bucketName = object.bucketName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined,
	            bucketName: object?.bucket_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        obj.bucket_name = message.bucketName;
	        return obj;
	    }
	};
	function createBaseQueryListObjectsByBucketIdRequest() {
	    return {
	        pagination: undefined,
	        bucketId: ""
	    };
	}
	exports.QueryListObjectsByBucketIdRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.bucketId !== "") {
	            writer.uint32(18).string(message.bucketId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryListObjectsByBucketIdRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.bucketId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
	            bucketId: (0, helpers_1.isSet)(object.bucketId) ? String(object.bucketId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        message.bucketId !== undefined && (obj.bucketId = message.bucketId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryListObjectsByBucketIdRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        message.bucketId = object.bucketId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined,
	            bucketId: object?.bucket_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        obj.bucket_id = message.bucketId;
	        return obj;
	    }
	};
	function createBaseQueryListObjectsResponse() {
	    return {
	        objectInfos: [],
	        pagination: undefined
	    };
	}
	exports.QueryListObjectsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.objectInfos) {
	            types_1.ObjectInfo.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryListObjectsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.objectInfos.push(types_1.ObjectInfo.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            objectInfos: Array.isArray(object?.objectInfos) ? object.objectInfos.map((e) => types_1.ObjectInfo.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.objectInfos) {
	            obj.objectInfos = message.objectInfos.map(e => e ? types_1.ObjectInfo.toJSON(e) : undefined);
	        }
	        else {
	            obj.objectInfos = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryListObjectsResponse();
	        message.objectInfos = object.objectInfos?.map(e => types_1.ObjectInfo.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            objectInfos: Array.isArray(object?.object_infos) ? object.object_infos.map((e) => types_1.ObjectInfo.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.objectInfos) {
	            obj.object_infos = message.objectInfos.map(e => e ? types_1.ObjectInfo.toSDK(e) : undefined);
	        }
	        else {
	            obj.object_infos = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryNFTRequest() {
	    return {
	        tokenId: ""
	    };
	}
	exports.QueryNFTRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.tokenId !== "") {
	            writer.uint32(10).string(message.tokenId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryNFTRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.tokenId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            tokenId: (0, helpers_1.isSet)(object.tokenId) ? String(object.tokenId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.tokenId !== undefined && (obj.tokenId = message.tokenId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryNFTRequest();
	        message.tokenId = object.tokenId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            tokenId: object?.token_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.token_id = message.tokenId;
	        return obj;
	    }
	};
	function createBaseQueryBucketNFTResponse() {
	    return {
	        metaData: undefined
	    };
	}
	exports.QueryBucketNFTResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.metaData !== undefined) {
	            types_1.BucketMetaData.encode(message.metaData, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryBucketNFTResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.metaData = types_1.BucketMetaData.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            metaData: (0, helpers_1.isSet)(object.metaData) ? types_1.BucketMetaData.fromJSON(object.metaData) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.metaData !== undefined && (obj.metaData = message.metaData ? types_1.BucketMetaData.toJSON(message.metaData) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryBucketNFTResponse();
	        message.metaData = object.metaData !== undefined && object.metaData !== null ? types_1.BucketMetaData.fromPartial(object.metaData) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            metaData: object.meta_data ? types_1.BucketMetaData.fromSDK(object.meta_data) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.metaData !== undefined && (obj.meta_data = message.metaData ? types_1.BucketMetaData.toSDK(message.metaData) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryObjectNFTResponse() {
	    return {
	        metaData: undefined
	    };
	}
	exports.QueryObjectNFTResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.metaData !== undefined) {
	            types_1.ObjectMetaData.encode(message.metaData, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryObjectNFTResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.metaData = types_1.ObjectMetaData.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            metaData: (0, helpers_1.isSet)(object.metaData) ? types_1.ObjectMetaData.fromJSON(object.metaData) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.metaData !== undefined && (obj.metaData = message.metaData ? types_1.ObjectMetaData.toJSON(message.metaData) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryObjectNFTResponse();
	        message.metaData = object.metaData !== undefined && object.metaData !== null ? types_1.ObjectMetaData.fromPartial(object.metaData) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            metaData: object.meta_data ? types_1.ObjectMetaData.fromSDK(object.meta_data) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.metaData !== undefined && (obj.meta_data = message.metaData ? types_1.ObjectMetaData.toSDK(message.metaData) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryGroupNFTResponse() {
	    return {
	        metaData: undefined
	    };
	}
	exports.QueryGroupNFTResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.metaData !== undefined) {
	            types_1.GroupMetaData.encode(message.metaData, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGroupNFTResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.metaData = types_1.GroupMetaData.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            metaData: (0, helpers_1.isSet)(object.metaData) ? types_1.GroupMetaData.fromJSON(object.metaData) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.metaData !== undefined && (obj.metaData = message.metaData ? types_1.GroupMetaData.toJSON(message.metaData) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGroupNFTResponse();
	        message.metaData = object.metaData !== undefined && object.metaData !== null ? types_1.GroupMetaData.fromPartial(object.metaData) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            metaData: object.meta_data ? types_1.GroupMetaData.fromSDK(object.meta_data) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.metaData !== undefined && (obj.meta_data = message.metaData ? types_1.GroupMetaData.toSDK(message.metaData) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryPolicyForAccountRequest() {
	    return {
	        resource: "",
	        principalAddress: ""
	    };
	}
	exports.QueryPolicyForAccountRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.resource !== "") {
	            writer.uint32(10).string(message.resource);
	        }
	        if (message.principalAddress !== "") {
	            writer.uint32(18).string(message.principalAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryPolicyForAccountRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.resource = reader.string();
	                    break;
	                case 2:
	                    message.principalAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            resource: (0, helpers_1.isSet)(object.resource) ? String(object.resource) : "",
	            principalAddress: (0, helpers_1.isSet)(object.principalAddress) ? String(object.principalAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.resource !== undefined && (obj.resource = message.resource);
	        message.principalAddress !== undefined && (obj.principalAddress = message.principalAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryPolicyForAccountRequest();
	        message.resource = object.resource ?? "";
	        message.principalAddress = object.principalAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            resource: object?.resource,
	            principalAddress: object?.principal_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.resource = message.resource;
	        obj.principal_address = message.principalAddress;
	        return obj;
	    }
	};
	function createBaseQueryPolicyForAccountResponse() {
	    return {
	        policy: undefined
	    };
	}
	exports.QueryPolicyForAccountResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.policy !== undefined) {
	            types_2.Policy.encode(message.policy, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryPolicyForAccountResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.policy = types_2.Policy.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            policy: (0, helpers_1.isSet)(object.policy) ? types_2.Policy.fromJSON(object.policy) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.policy !== undefined && (obj.policy = message.policy ? types_2.Policy.toJSON(message.policy) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryPolicyForAccountResponse();
	        message.policy = object.policy !== undefined && object.policy !== null ? types_2.Policy.fromPartial(object.policy) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            policy: object.policy ? types_2.Policy.fromSDK(object.policy) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.policy !== undefined && (obj.policy = message.policy ? types_2.Policy.toSDK(message.policy) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryVerifyPermissionRequest() {
	    return {
	        operator: "",
	        bucketName: "",
	        objectName: "",
	        actionType: 0
	    };
	}
	exports.QueryVerifyPermissionRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        if (message.actionType !== 0) {
	            writer.uint32(32).int32(message.actionType);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryVerifyPermissionRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                case 4:
	                    message.actionType = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
	            actionType: (0, helpers_1.isSet)(object.actionType) ? (0, common_1.actionTypeFromJSON)(object.actionType) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        message.actionType !== undefined && (obj.actionType = (0, common_1.actionTypeToJSON)(message.actionType));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryVerifyPermissionRequest();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        message.actionType = object.actionType ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name,
	            actionType: (0, helpers_1.isSet)(object.action_type) ? (0, common_1.actionTypeFromJSON)(object.action_type) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        message.actionType !== undefined && (obj.action_type = (0, common_1.actionTypeToJSON)(message.actionType));
	        return obj;
	    }
	};
	function createBaseQueryVerifyPermissionResponse() {
	    return {
	        effect: 0
	    };
	}
	exports.QueryVerifyPermissionResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.effect !== 0) {
	            writer.uint32(8).int32(message.effect);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryVerifyPermissionResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.effect = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            effect: (0, helpers_1.isSet)(object.effect) ? (0, common_1.effectFromJSON)(object.effect) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.effect !== undefined && (obj.effect = (0, common_1.effectToJSON)(message.effect));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryVerifyPermissionResponse();
	        message.effect = object.effect ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            effect: (0, helpers_1.isSet)(object.effect) ? (0, common_1.effectFromJSON)(object.effect) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.effect !== undefined && (obj.effect = (0, common_1.effectToJSON)(message.effect));
	        return obj;
	    }
	};
	function createBaseQueryHeadGroupRequest() {
	    return {
	        groupOwner: "",
	        groupName: ""
	    };
	}
	exports.QueryHeadGroupRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.groupOwner !== "") {
	            writer.uint32(10).string(message.groupOwner);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(18).string(message.groupName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadGroupRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.groupOwner = reader.string();
	                    break;
	                case 2:
	                    message.groupName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            groupOwner: (0, helpers_1.isSet)(object.groupOwner) ? String(object.groupOwner) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.groupOwner !== undefined && (obj.groupOwner = message.groupOwner);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadGroupRequest();
	        message.groupOwner = object.groupOwner ?? "";
	        message.groupName = object.groupName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            groupOwner: object?.group_owner,
	            groupName: object?.group_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.group_owner = message.groupOwner;
	        obj.group_name = message.groupName;
	        return obj;
	    }
	};
	function createBaseQueryHeadGroupResponse() {
	    return {
	        groupInfo: undefined
	    };
	}
	exports.QueryHeadGroupResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.groupInfo !== undefined) {
	            types_1.GroupInfo.encode(message.groupInfo, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadGroupResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.groupInfo = types_1.GroupInfo.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            groupInfo: (0, helpers_1.isSet)(object.groupInfo) ? types_1.GroupInfo.fromJSON(object.groupInfo) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.groupInfo !== undefined && (obj.groupInfo = message.groupInfo ? types_1.GroupInfo.toJSON(message.groupInfo) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadGroupResponse();
	        message.groupInfo = object.groupInfo !== undefined && object.groupInfo !== null ? types_1.GroupInfo.fromPartial(object.groupInfo) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            groupInfo: object.group_info ? types_1.GroupInfo.fromSDK(object.group_info) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.groupInfo !== undefined && (obj.group_info = message.groupInfo ? types_1.GroupInfo.toSDK(message.groupInfo) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryListGroupRequest() {
	    return {
	        pagination: undefined,
	        groupOwner: ""
	    };
	}
	exports.QueryListGroupRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.groupOwner !== "") {
	            writer.uint32(18).string(message.groupOwner);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryListGroupRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.groupOwner = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
	            groupOwner: (0, helpers_1.isSet)(object.groupOwner) ? String(object.groupOwner) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        message.groupOwner !== undefined && (obj.groupOwner = message.groupOwner);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryListGroupRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        message.groupOwner = object.groupOwner ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined,
	            groupOwner: object?.group_owner
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        obj.group_owner = message.groupOwner;
	        return obj;
	    }
	};
	function createBaseQueryListGroupResponse() {
	    return {
	        pagination: undefined,
	        groupInfos: []
	    };
	}
	exports.QueryListGroupResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        for (const v of message.groupInfos) {
	            types_1.GroupInfo.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryListGroupResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                case 2:
	                    message.groupInfos.push(types_1.GroupInfo.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined,
	            groupInfos: Array.isArray(object?.groupInfos) ? object.groupInfos.map((e) => types_1.GroupInfo.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        if (message.groupInfos) {
	            obj.groupInfos = message.groupInfos.map(e => e ? types_1.GroupInfo.toJSON(e) : undefined);
	        }
	        else {
	            obj.groupInfos = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryListGroupResponse();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        message.groupInfos = object.groupInfos?.map(e => types_1.GroupInfo.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined,
	            groupInfos: Array.isArray(object?.group_infos) ? object.group_infos.map((e) => types_1.GroupInfo.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        if (message.groupInfos) {
	            obj.group_infos = message.groupInfos.map(e => e ? types_1.GroupInfo.toSDK(e) : undefined);
	        }
	        else {
	            obj.group_infos = [];
	        }
	        return obj;
	    }
	};
	function createBaseQueryHeadGroupMemberRequest() {
	    return {
	        member: "",
	        groupOwner: "",
	        groupName: ""
	    };
	}
	exports.QueryHeadGroupMemberRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.member !== "") {
	            writer.uint32(10).string(message.member);
	        }
	        if (message.groupOwner !== "") {
	            writer.uint32(18).string(message.groupOwner);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(26).string(message.groupName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadGroupMemberRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.member = reader.string();
	                    break;
	                case 2:
	                    message.groupOwner = reader.string();
	                    break;
	                case 3:
	                    message.groupName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            member: (0, helpers_1.isSet)(object.member) ? String(object.member) : "",
	            groupOwner: (0, helpers_1.isSet)(object.groupOwner) ? String(object.groupOwner) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.member !== undefined && (obj.member = message.member);
	        message.groupOwner !== undefined && (obj.groupOwner = message.groupOwner);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadGroupMemberRequest();
	        message.member = object.member ?? "";
	        message.groupOwner = object.groupOwner ?? "";
	        message.groupName = object.groupName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            member: object?.member,
	            groupOwner: object?.group_owner,
	            groupName: object?.group_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.member = message.member;
	        obj.group_owner = message.groupOwner;
	        obj.group_name = message.groupName;
	        return obj;
	    }
	};
	function createBaseQueryHeadGroupMemberResponse() {
	    return {
	        groupMember: undefined
	    };
	}
	exports.QueryHeadGroupMemberResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.groupMember !== undefined) {
	            types_2.GroupMember.encode(message.groupMember, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryHeadGroupMemberResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.groupMember = types_2.GroupMember.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            groupMember: (0, helpers_1.isSet)(object.groupMember) ? types_2.GroupMember.fromJSON(object.groupMember) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.groupMember !== undefined && (obj.groupMember = message.groupMember ? types_2.GroupMember.toJSON(message.groupMember) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryHeadGroupMemberResponse();
	        message.groupMember = object.groupMember !== undefined && object.groupMember !== null ? types_2.GroupMember.fromPartial(object.groupMember) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            groupMember: object.group_member ? types_2.GroupMember.fromSDK(object.group_member) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.groupMember !== undefined && (obj.group_member = message.groupMember ? types_2.GroupMember.toSDK(message.groupMember) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryPolicyForGroupRequest() {
	    return {
	        resource: "",
	        principalGroupId: ""
	    };
	}
	exports.QueryPolicyForGroupRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.resource !== "") {
	            writer.uint32(10).string(message.resource);
	        }
	        if (message.principalGroupId !== "") {
	            writer.uint32(18).string(message.principalGroupId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryPolicyForGroupRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.resource = reader.string();
	                    break;
	                case 2:
	                    message.principalGroupId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            resource: (0, helpers_1.isSet)(object.resource) ? String(object.resource) : "",
	            principalGroupId: (0, helpers_1.isSet)(object.principalGroupId) ? String(object.principalGroupId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.resource !== undefined && (obj.resource = message.resource);
	        message.principalGroupId !== undefined && (obj.principalGroupId = message.principalGroupId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryPolicyForGroupRequest();
	        message.resource = object.resource ?? "";
	        message.principalGroupId = object.principalGroupId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            resource: object?.resource,
	            principalGroupId: object?.principal_group_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.resource = message.resource;
	        obj.principal_group_id = message.principalGroupId;
	        return obj;
	    }
	};
	function createBaseQueryPolicyForGroupResponse() {
	    return {
	        policy: undefined
	    };
	}
	exports.QueryPolicyForGroupResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.policy !== undefined) {
	            types_2.Policy.encode(message.policy, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryPolicyForGroupResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.policy = types_2.Policy.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            policy: (0, helpers_1.isSet)(object.policy) ? types_2.Policy.fromJSON(object.policy) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.policy !== undefined && (obj.policy = message.policy ? types_2.Policy.toJSON(message.policy) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryPolicyForGroupResponse();
	        message.policy = object.policy !== undefined && object.policy !== null ? types_2.Policy.fromPartial(object.policy) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            policy: object.policy ? types_2.Policy.fromSDK(object.policy) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.policy !== undefined && (obj.policy = message.policy ? types_2.Policy.toSDK(message.policy) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryPolicyByIdRequest() {
	    return {
	        policyId: ""
	    };
	}
	exports.QueryPolicyByIdRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.policyId !== "") {
	            writer.uint32(10).string(message.policyId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryPolicyByIdRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.policyId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            policyId: (0, helpers_1.isSet)(object.policyId) ? String(object.policyId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.policyId !== undefined && (obj.policyId = message.policyId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryPolicyByIdRequest();
	        message.policyId = object.policyId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            policyId: object?.policy_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.policy_id = message.policyId;
	        return obj;
	    }
	};
	function createBaseQueryPolicyByIdResponse() {
	    return {
	        policy: undefined
	    };
	}
	exports.QueryPolicyByIdResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.policy !== undefined) {
	            types_2.Policy.encode(message.policy, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryPolicyByIdResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.policy = types_2.Policy.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            policy: (0, helpers_1.isSet)(object.policy) ? types_2.Policy.fromJSON(object.policy) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.policy !== undefined && (obj.policy = message.policy ? types_2.Policy.toJSON(message.policy) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryPolicyByIdResponse();
	        message.policy = object.policy !== undefined && object.policy !== null ? types_2.Policy.fromPartial(object.policy) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            policy: object.policy ? types_2.Policy.fromSDK(object.policy) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.policy !== undefined && (obj.policy = message.policy ? types_2.Policy.toSDK(message.policy) : undefined);
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Params = this.Params.bind(this);
	        this.HeadBucket = this.HeadBucket.bind(this);
	        this.HeadBucketById = this.HeadBucketById.bind(this);
	        this.HeadBucketNFT = this.HeadBucketNFT.bind(this);
	        this.HeadObject = this.HeadObject.bind(this);
	        this.HeadObjectById = this.HeadObjectById.bind(this);
	        this.HeadObjectNFT = this.HeadObjectNFT.bind(this);
	        this.ListBuckets = this.ListBuckets.bind(this);
	        this.ListObjects = this.ListObjects.bind(this);
	        this.ListObjectsByBucketId = this.ListObjectsByBucketId.bind(this);
	        this.HeadGroupNFT = this.HeadGroupNFT.bind(this);
	        this.QueryPolicyForAccount = this.QueryPolicyForAccount.bind(this);
	        this.VerifyPermission = this.VerifyPermission.bind(this);
	        this.HeadGroup = this.HeadGroup.bind(this);
	        this.ListGroup = this.ListGroup.bind(this);
	        this.HeadGroupMember = this.HeadGroupMember.bind(this);
	        this.QueryPolicyForGroup = this.QueryPolicyForGroup.bind(this);
	        this.QueryPolicyById = this.QueryPolicyById.bind(this);
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    HeadBucket(request) {
	        const data = exports.QueryHeadBucketRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadBucket", data);
	        return promise.then(data => exports.QueryHeadBucketResponse.decode(new _m0.Reader(data)));
	    }
	    HeadBucketById(request) {
	        const data = exports.QueryHeadBucketByIdRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadBucketById", data);
	        return promise.then(data => exports.QueryHeadBucketResponse.decode(new _m0.Reader(data)));
	    }
	    HeadBucketNFT(request) {
	        const data = exports.QueryNFTRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadBucketNFT", data);
	        return promise.then(data => exports.QueryBucketNFTResponse.decode(new _m0.Reader(data)));
	    }
	    HeadObject(request) {
	        const data = exports.QueryHeadObjectRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadObject", data);
	        return promise.then(data => exports.QueryHeadObjectResponse.decode(new _m0.Reader(data)));
	    }
	    HeadObjectById(request) {
	        const data = exports.QueryHeadObjectByIdRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadObjectById", data);
	        return promise.then(data => exports.QueryHeadObjectResponse.decode(new _m0.Reader(data)));
	    }
	    HeadObjectNFT(request) {
	        const data = exports.QueryNFTRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadObjectNFT", data);
	        return promise.then(data => exports.QueryObjectNFTResponse.decode(new _m0.Reader(data)));
	    }
	    ListBuckets(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryListBucketsRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "ListBuckets", data);
	        return promise.then(data => exports.QueryListBucketsResponse.decode(new _m0.Reader(data)));
	    }
	    ListObjects(request) {
	        const data = exports.QueryListObjectsRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "ListObjects", data);
	        return promise.then(data => exports.QueryListObjectsResponse.decode(new _m0.Reader(data)));
	    }
	    ListObjectsByBucketId(request) {
	        const data = exports.QueryListObjectsByBucketIdRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "ListObjectsByBucketId", data);
	        return promise.then(data => exports.QueryListObjectsResponse.decode(new _m0.Reader(data)));
	    }
	    HeadGroupNFT(request) {
	        const data = exports.QueryNFTRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadGroupNFT", data);
	        return promise.then(data => exports.QueryGroupNFTResponse.decode(new _m0.Reader(data)));
	    }
	    QueryPolicyForAccount(request) {
	        const data = exports.QueryPolicyForAccountRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "QueryPolicyForAccount", data);
	        return promise.then(data => exports.QueryPolicyForAccountResponse.decode(new _m0.Reader(data)));
	    }
	    VerifyPermission(request) {
	        const data = exports.QueryVerifyPermissionRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "VerifyPermission", data);
	        return promise.then(data => exports.QueryVerifyPermissionResponse.decode(new _m0.Reader(data)));
	    }
	    HeadGroup(request) {
	        const data = exports.QueryHeadGroupRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadGroup", data);
	        return promise.then(data => exports.QueryHeadGroupResponse.decode(new _m0.Reader(data)));
	    }
	    ListGroup(request) {
	        const data = exports.QueryListGroupRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "ListGroup", data);
	        return promise.then(data => exports.QueryListGroupResponse.decode(new _m0.Reader(data)));
	    }
	    HeadGroupMember(request) {
	        const data = exports.QueryHeadGroupMemberRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "HeadGroupMember", data);
	        return promise.then(data => exports.QueryHeadGroupMemberResponse.decode(new _m0.Reader(data)));
	    }
	    QueryPolicyForGroup(request) {
	        const data = exports.QueryPolicyForGroupRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "QueryPolicyForGroup", data);
	        return promise.then(data => exports.QueryPolicyForGroupResponse.decode(new _m0.Reader(data)));
	    }
	    QueryPolicyById(request) {
	        const data = exports.QueryPolicyByIdRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Query", "QueryPolicyById", data);
	        return promise.then(data => exports.QueryPolicyByIdResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$5));

query$5.default;

var tx$5 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgMirrorGroupResponse = exports.MsgMirrorGroup = exports.MsgMirrorBucketResponse = exports.MsgUpdateObjectInfo = exports.MsgUpdateObjectInfoResponse = exports.MsgMirrorBucket = exports.MsgMirrorObjectResponse = exports.MsgMirrorObject = exports.MsgDeletePolicyResponse = exports.MsgDeletePolicy = exports.MsgPutPolicyResponse = exports.MsgPutPolicy = exports.MsgCancelCreateObjectResponse = exports.MsgCancelCreateObject = exports.MsgUpdateBucketInfoResponse = exports.MsgUpdateBucketInfo = exports.MsgLeaveGroupResponse = exports.MsgLeaveGroup = exports.MsgUpdateGroupMemberResponse = exports.MsgUpdateGroupMember = exports.MsgDeleteGroupResponse = exports.MsgDeleteGroup = exports.MsgCreateGroupResponse = exports.MsgCreateGroup = exports.MsgDiscontinueObjectResponse = exports.MsgDiscontinueObject = exports.MsgDeleteObjectResponse = exports.MsgDeleteObject = exports.MsgCopyObjectResponse = exports.MsgCopyObject = exports.MsgRejectSealObjectResponse = exports.MsgRejectSealObject = exports.MsgSealObjectResponse = exports.MsgSealObject = exports.MsgCreateObjectResponse = exports.MsgCreateObject = exports.MsgDiscontinueBucketResponse = exports.MsgDiscontinueBucket = exports.MsgDeleteBucketResponse = exports.MsgDeleteBucket = exports.MsgCreateBucketResponse = exports.MsgCreateBucket = exports.protobufPackage = void 0;
	/* eslint-disable */
	const common_1 = common$3;
	const wrapper_1 = wrapper;
	const common_2 = common;
	const timestamp_1 = timestamp;
	const params_1 = params$3;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "greenfield.storage";
	function createBaseMsgCreateBucket() {
	    return {
	        creator: "",
	        bucketName: "",
	        visibility: 0,
	        paymentAddress: "",
	        primarySpAddress: "",
	        primarySpApproval: undefined,
	        chargedReadQuota: helpers_1.Long.UZERO
	    };
	}
	exports.MsgCreateBucket = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.visibility !== 0) {
	            writer.uint32(24).int32(message.visibility);
	        }
	        if (message.paymentAddress !== "") {
	            writer.uint32(34).string(message.paymentAddress);
	        }
	        if (message.primarySpAddress !== "") {
	            writer.uint32(50).string(message.primarySpAddress);
	        }
	        if (message.primarySpApproval !== undefined) {
	            common_1.Approval.encode(message.primarySpApproval, writer.uint32(58).fork()).ldelim();
	        }
	        if (!message.chargedReadQuota.isZero()) {
	            writer.uint32(64).uint64(message.chargedReadQuota);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateBucket();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.visibility = reader.int32();
	                    break;
	                case 4:
	                    message.paymentAddress = reader.string();
	                    break;
	                case 6:
	                    message.primarySpAddress = reader.string();
	                    break;
	                case 7:
	                    message.primarySpApproval = common_1.Approval.decode(reader, reader.uint32());
	                    break;
	                case 8:
	                    message.chargedReadQuota = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            paymentAddress: (0, helpers_1.isSet)(object.paymentAddress) ? String(object.paymentAddress) : "",
	            primarySpAddress: (0, helpers_1.isSet)(object.primarySpAddress) ? String(object.primarySpAddress) : "",
	            primarySpApproval: (0, helpers_1.isSet)(object.primarySpApproval) ? common_1.Approval.fromJSON(object.primarySpApproval) : undefined,
	            chargedReadQuota: (0, helpers_1.isSet)(object.chargedReadQuota) ? helpers_1.Long.fromValue(object.chargedReadQuota) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        message.paymentAddress !== undefined && (obj.paymentAddress = message.paymentAddress);
	        message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);
	        message.primarySpApproval !== undefined && (obj.primarySpApproval = message.primarySpApproval ? common_1.Approval.toJSON(message.primarySpApproval) : undefined);
	        message.chargedReadQuota !== undefined && (obj.chargedReadQuota = (message.chargedReadQuota || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreateBucket();
	        message.creator = object.creator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.visibility = object.visibility ?? 0;
	        message.paymentAddress = object.paymentAddress ?? "";
	        message.primarySpAddress = object.primarySpAddress ?? "";
	        message.primarySpApproval = object.primarySpApproval !== undefined && object.primarySpApproval !== null ? common_1.Approval.fromPartial(object.primarySpApproval) : undefined;
	        message.chargedReadQuota = object.chargedReadQuota !== undefined && object.chargedReadQuota !== null ? helpers_1.Long.fromValue(object.chargedReadQuota) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator,
	            bucketName: object?.bucket_name,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            paymentAddress: object?.payment_address,
	            primarySpAddress: object?.primary_sp_address,
	            primarySpApproval: object.primary_sp_approval ? common_1.Approval.fromSDK(object.primary_sp_approval) : undefined,
	            chargedReadQuota: object?.charged_read_quota
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        obj.bucket_name = message.bucketName;
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        obj.payment_address = message.paymentAddress;
	        obj.primary_sp_address = message.primarySpAddress;
	        message.primarySpApproval !== undefined && (obj.primary_sp_approval = message.primarySpApproval ? common_1.Approval.toSDK(message.primarySpApproval) : undefined);
	        obj.charged_read_quota = message.chargedReadQuota;
	        return obj;
	    }
	};
	function createBaseMsgCreateBucketResponse() {
	    return {
	        bucketId: ""
	    };
	}
	exports.MsgCreateBucketResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.bucketId !== "") {
	            writer.uint32(10).string(message.bucketId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateBucketResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.bucketId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            bucketId: (0, helpers_1.isSet)(object.bucketId) ? String(object.bucketId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.bucketId !== undefined && (obj.bucketId = message.bucketId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreateBucketResponse();
	        message.bucketId = object.bucketId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            bucketId: object?.bucket_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.bucket_id = message.bucketId;
	        return obj;
	    }
	};
	function createBaseMsgDeleteBucket() {
	    return {
	        operator: "",
	        bucketName: ""
	    };
	}
	exports.MsgDeleteBucket = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeleteBucket();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDeleteBucket();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        return obj;
	    }
	};
	function createBaseMsgDeleteBucketResponse() {
	    return {};
	}
	exports.MsgDeleteBucketResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeleteBucketResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDeleteBucketResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgDiscontinueBucket() {
	    return {
	        operator: "",
	        bucketName: "",
	        reason: ""
	    };
	}
	exports.MsgDiscontinueBucket = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.reason !== "") {
	            writer.uint32(26).string(message.reason);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDiscontinueBucket();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.reason = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            reason: (0, helpers_1.isSet)(object.reason) ? String(object.reason) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.reason !== undefined && (obj.reason = message.reason);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDiscontinueBucket();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.reason = object.reason ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            reason: object?.reason
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        obj.reason = message.reason;
	        return obj;
	    }
	};
	function createBaseMsgDiscontinueBucketResponse() {
	    return {};
	}
	exports.MsgDiscontinueBucketResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDiscontinueBucketResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDiscontinueBucketResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgCreateObject() {
	    return {
	        creator: "",
	        bucketName: "",
	        objectName: "",
	        payloadSize: helpers_1.Long.UZERO,
	        visibility: 0,
	        contentType: "",
	        primarySpApproval: undefined,
	        expectChecksums: [],
	        redundancyType: 0,
	        expectSecondarySpAddresses: []
	    };
	}
	exports.MsgCreateObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        if (!message.payloadSize.isZero()) {
	            writer.uint32(32).uint64(message.payloadSize);
	        }
	        if (message.visibility !== 0) {
	            writer.uint32(40).int32(message.visibility);
	        }
	        if (message.contentType !== "") {
	            writer.uint32(50).string(message.contentType);
	        }
	        if (message.primarySpApproval !== undefined) {
	            common_1.Approval.encode(message.primarySpApproval, writer.uint32(58).fork()).ldelim();
	        }
	        for (const v of message.expectChecksums) {
	            writer.uint32(66).bytes(v);
	        }
	        if (message.redundancyType !== 0) {
	            writer.uint32(72).int32(message.redundancyType);
	        }
	        for (const v of message.expectSecondarySpAddresses) {
	            writer.uint32(82).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                case 4:
	                    message.payloadSize = reader.uint64();
	                    break;
	                case 5:
	                    message.visibility = reader.int32();
	                    break;
	                case 6:
	                    message.contentType = reader.string();
	                    break;
	                case 7:
	                    message.primarySpApproval = common_1.Approval.decode(reader, reader.uint32());
	                    break;
	                case 8:
	                    message.expectChecksums.push(reader.bytes());
	                    break;
	                case 9:
	                    message.redundancyType = reader.int32();
	                    break;
	                case 10:
	                    message.expectSecondarySpAddresses.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
	            payloadSize: (0, helpers_1.isSet)(object.payloadSize) ? helpers_1.Long.fromValue(object.payloadSize) : helpers_1.Long.UZERO,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            contentType: (0, helpers_1.isSet)(object.contentType) ? String(object.contentType) : "",
	            primarySpApproval: (0, helpers_1.isSet)(object.primarySpApproval) ? common_1.Approval.fromJSON(object.primarySpApproval) : undefined,
	            expectChecksums: Array.isArray(object?.expectChecksums) ? object.expectChecksums.map((e) => (0, helpers_1.bytesFromBase64)(e)) : [],
	            redundancyType: (0, helpers_1.isSet)(object.redundancyType) ? (0, common_1.redundancyTypeFromJSON)(object.redundancyType) : 0,
	            expectSecondarySpAddresses: Array.isArray(object?.expectSecondarySpAddresses) ? object.expectSecondarySpAddresses.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        message.payloadSize !== undefined && (obj.payloadSize = (message.payloadSize || helpers_1.Long.UZERO).toString());
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        message.contentType !== undefined && (obj.contentType = message.contentType);
	        message.primarySpApproval !== undefined && (obj.primarySpApproval = message.primarySpApproval ? common_1.Approval.toJSON(message.primarySpApproval) : undefined);
	        if (message.expectChecksums) {
	            obj.expectChecksums = message.expectChecksums.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.expectChecksums = [];
	        }
	        message.redundancyType !== undefined && (obj.redundancyType = (0, common_1.redundancyTypeToJSON)(message.redundancyType));
	        if (message.expectSecondarySpAddresses) {
	            obj.expectSecondarySpAddresses = message.expectSecondarySpAddresses.map(e => e);
	        }
	        else {
	            obj.expectSecondarySpAddresses = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreateObject();
	        message.creator = object.creator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        message.payloadSize = object.payloadSize !== undefined && object.payloadSize !== null ? helpers_1.Long.fromValue(object.payloadSize) : helpers_1.Long.UZERO;
	        message.visibility = object.visibility ?? 0;
	        message.contentType = object.contentType ?? "";
	        message.primarySpApproval = object.primarySpApproval !== undefined && object.primarySpApproval !== null ? common_1.Approval.fromPartial(object.primarySpApproval) : undefined;
	        message.expectChecksums = object.expectChecksums?.map(e => e) || [];
	        message.redundancyType = object.redundancyType ?? 0;
	        message.expectSecondarySpAddresses = object.expectSecondarySpAddresses?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name,
	            payloadSize: object?.payload_size,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
	            contentType: object?.content_type,
	            primarySpApproval: object.primary_sp_approval ? common_1.Approval.fromSDK(object.primary_sp_approval) : undefined,
	            expectChecksums: Array.isArray(object?.expect_checksums) ? object.expect_checksums.map((e) => e) : [],
	            redundancyType: (0, helpers_1.isSet)(object.redundancy_type) ? (0, common_1.redundancyTypeFromJSON)(object.redundancy_type) : 0,
	            expectSecondarySpAddresses: Array.isArray(object?.expect_secondary_sp_addresses) ? object.expect_secondary_sp_addresses.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        obj.payload_size = message.payloadSize;
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        obj.content_type = message.contentType;
	        message.primarySpApproval !== undefined && (obj.primary_sp_approval = message.primarySpApproval ? common_1.Approval.toSDK(message.primarySpApproval) : undefined);
	        if (message.expectChecksums) {
	            obj.expect_checksums = message.expectChecksums.map(e => e);
	        }
	        else {
	            obj.expect_checksums = [];
	        }
	        message.redundancyType !== undefined && (obj.redundancy_type = (0, common_1.redundancyTypeToJSON)(message.redundancyType));
	        if (message.expectSecondarySpAddresses) {
	            obj.expect_secondary_sp_addresses = message.expectSecondarySpAddresses.map(e => e);
	        }
	        else {
	            obj.expect_secondary_sp_addresses = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgCreateObjectResponse() {
	    return {
	        objectId: ""
	    };
	}
	exports.MsgCreateObjectResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.objectId !== "") {
	            writer.uint32(10).string(message.objectId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.objectId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            objectId: (0, helpers_1.isSet)(object.objectId) ? String(object.objectId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.objectId !== undefined && (obj.objectId = message.objectId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreateObjectResponse();
	        message.objectId = object.objectId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            objectId: object?.object_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.object_id = message.objectId;
	        return obj;
	    }
	};
	function createBaseMsgSealObject() {
	    return {
	        operator: "",
	        bucketName: "",
	        objectName: "",
	        secondarySpAddresses: [],
	        secondarySpSignatures: []
	    };
	}
	exports.MsgSealObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        for (const v of message.secondarySpAddresses) {
	            writer.uint32(34).string(v);
	        }
	        for (const v of message.secondarySpSignatures) {
	            writer.uint32(42).bytes(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSealObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                case 4:
	                    message.secondarySpAddresses.push(reader.string());
	                    break;
	                case 5:
	                    message.secondarySpSignatures.push(reader.bytes());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
	            secondarySpAddresses: Array.isArray(object?.secondarySpAddresses) ? object.secondarySpAddresses.map((e) => String(e)) : [],
	            secondarySpSignatures: Array.isArray(object?.secondarySpSignatures) ? object.secondarySpSignatures.map((e) => (0, helpers_1.bytesFromBase64)(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        if (message.secondarySpAddresses) {
	            obj.secondarySpAddresses = message.secondarySpAddresses.map(e => e);
	        }
	        else {
	            obj.secondarySpAddresses = [];
	        }
	        if (message.secondarySpSignatures) {
	            obj.secondarySpSignatures = message.secondarySpSignatures.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
	        }
	        else {
	            obj.secondarySpSignatures = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgSealObject();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        message.secondarySpAddresses = object.secondarySpAddresses?.map(e => e) || [];
	        message.secondarySpSignatures = object.secondarySpSignatures?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name,
	            secondarySpAddresses: Array.isArray(object?.secondary_sp_addresses) ? object.secondary_sp_addresses.map((e) => e) : [],
	            secondarySpSignatures: Array.isArray(object?.secondary_sp_signatures) ? object.secondary_sp_signatures.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        if (message.secondarySpAddresses) {
	            obj.secondary_sp_addresses = message.secondarySpAddresses.map(e => e);
	        }
	        else {
	            obj.secondary_sp_addresses = [];
	        }
	        if (message.secondarySpSignatures) {
	            obj.secondary_sp_signatures = message.secondarySpSignatures.map(e => e);
	        }
	        else {
	            obj.secondary_sp_signatures = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgSealObjectResponse() {
	    return {};
	}
	exports.MsgSealObjectResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSealObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgSealObjectResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgRejectSealObject() {
	    return {
	        operator: "",
	        bucketName: "",
	        objectName: ""
	    };
	}
	exports.MsgRejectSealObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgRejectSealObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgRejectSealObject();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        return obj;
	    }
	};
	function createBaseMsgRejectSealObjectResponse() {
	    return {};
	}
	exports.MsgRejectSealObjectResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgRejectSealObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgRejectSealObjectResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgCopyObject() {
	    return {
	        operator: "",
	        srcBucketName: "",
	        dstBucketName: "",
	        srcObjectName: "",
	        dstObjectName: "",
	        dstPrimarySpApproval: undefined
	    };
	}
	exports.MsgCopyObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.srcBucketName !== "") {
	            writer.uint32(18).string(message.srcBucketName);
	        }
	        if (message.dstBucketName !== "") {
	            writer.uint32(26).string(message.dstBucketName);
	        }
	        if (message.srcObjectName !== "") {
	            writer.uint32(34).string(message.srcObjectName);
	        }
	        if (message.dstObjectName !== "") {
	            writer.uint32(42).string(message.dstObjectName);
	        }
	        if (message.dstPrimarySpApproval !== undefined) {
	            common_1.Approval.encode(message.dstPrimarySpApproval, writer.uint32(50).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCopyObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.srcBucketName = reader.string();
	                    break;
	                case 3:
	                    message.dstBucketName = reader.string();
	                    break;
	                case 4:
	                    message.srcObjectName = reader.string();
	                    break;
	                case 5:
	                    message.dstObjectName = reader.string();
	                    break;
	                case 6:
	                    message.dstPrimarySpApproval = common_1.Approval.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            srcBucketName: (0, helpers_1.isSet)(object.srcBucketName) ? String(object.srcBucketName) : "",
	            dstBucketName: (0, helpers_1.isSet)(object.dstBucketName) ? String(object.dstBucketName) : "",
	            srcObjectName: (0, helpers_1.isSet)(object.srcObjectName) ? String(object.srcObjectName) : "",
	            dstObjectName: (0, helpers_1.isSet)(object.dstObjectName) ? String(object.dstObjectName) : "",
	            dstPrimarySpApproval: (0, helpers_1.isSet)(object.dstPrimarySpApproval) ? common_1.Approval.fromJSON(object.dstPrimarySpApproval) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.srcBucketName !== undefined && (obj.srcBucketName = message.srcBucketName);
	        message.dstBucketName !== undefined && (obj.dstBucketName = message.dstBucketName);
	        message.srcObjectName !== undefined && (obj.srcObjectName = message.srcObjectName);
	        message.dstObjectName !== undefined && (obj.dstObjectName = message.dstObjectName);
	        message.dstPrimarySpApproval !== undefined && (obj.dstPrimarySpApproval = message.dstPrimarySpApproval ? common_1.Approval.toJSON(message.dstPrimarySpApproval) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCopyObject();
	        message.operator = object.operator ?? "";
	        message.srcBucketName = object.srcBucketName ?? "";
	        message.dstBucketName = object.dstBucketName ?? "";
	        message.srcObjectName = object.srcObjectName ?? "";
	        message.dstObjectName = object.dstObjectName ?? "";
	        message.dstPrimarySpApproval = object.dstPrimarySpApproval !== undefined && object.dstPrimarySpApproval !== null ? common_1.Approval.fromPartial(object.dstPrimarySpApproval) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            srcBucketName: object?.src_bucket_name,
	            dstBucketName: object?.dst_bucket_name,
	            srcObjectName: object?.src_object_name,
	            dstObjectName: object?.dst_object_name,
	            dstPrimarySpApproval: object.dst_primary_sp_approval ? common_1.Approval.fromSDK(object.dst_primary_sp_approval) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.src_bucket_name = message.srcBucketName;
	        obj.dst_bucket_name = message.dstBucketName;
	        obj.src_object_name = message.srcObjectName;
	        obj.dst_object_name = message.dstObjectName;
	        message.dstPrimarySpApproval !== undefined && (obj.dst_primary_sp_approval = message.dstPrimarySpApproval ? common_1.Approval.toSDK(message.dstPrimarySpApproval) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgCopyObjectResponse() {
	    return {
	        objectId: ""
	    };
	}
	exports.MsgCopyObjectResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.objectId !== "") {
	            writer.uint32(10).string(message.objectId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCopyObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.objectId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            objectId: (0, helpers_1.isSet)(object.objectId) ? String(object.objectId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.objectId !== undefined && (obj.objectId = message.objectId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCopyObjectResponse();
	        message.objectId = object.objectId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            objectId: object?.object_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.object_id = message.objectId;
	        return obj;
	    }
	};
	function createBaseMsgDeleteObject() {
	    return {
	        operator: "",
	        bucketName: "",
	        objectName: ""
	    };
	}
	exports.MsgDeleteObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeleteObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDeleteObject();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        return obj;
	    }
	};
	function createBaseMsgDeleteObjectResponse() {
	    return {};
	}
	exports.MsgDeleteObjectResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeleteObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDeleteObjectResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgDiscontinueObject() {
	    return {
	        operator: "",
	        bucketName: "",
	        objectIds: [],
	        reason: ""
	    };
	}
	exports.MsgDiscontinueObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        for (const v of message.objectIds) {
	            writer.uint32(26).string(v);
	        }
	        if (message.reason !== "") {
	            writer.uint32(34).string(message.reason);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDiscontinueObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectIds.push(reader.string());
	                    break;
	                case 4:
	                    message.reason = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectIds: Array.isArray(object?.objectIds) ? object.objectIds.map((e) => String(e)) : [],
	            reason: (0, helpers_1.isSet)(object.reason) ? String(object.reason) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        if (message.objectIds) {
	            obj.objectIds = message.objectIds.map(e => e);
	        }
	        else {
	            obj.objectIds = [];
	        }
	        message.reason !== undefined && (obj.reason = message.reason);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDiscontinueObject();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectIds = object.objectIds?.map(e => e) || [];
	        message.reason = object.reason ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            objectIds: Array.isArray(object?.object_ids) ? object.object_ids.map((e) => e) : [],
	            reason: object?.reason
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        if (message.objectIds) {
	            obj.object_ids = message.objectIds.map(e => e);
	        }
	        else {
	            obj.object_ids = [];
	        }
	        obj.reason = message.reason;
	        return obj;
	    }
	};
	function createBaseMsgDiscontinueObjectResponse() {
	    return {};
	}
	exports.MsgDiscontinueObjectResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDiscontinueObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDiscontinueObjectResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgCreateGroup() {
	    return {
	        creator: "",
	        groupName: "",
	        members: []
	    };
	}
	exports.MsgCreateGroup = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(18).string(message.groupName);
	        }
	        for (const v of message.members) {
	            writer.uint32(26).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateGroup();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                case 2:
	                    message.groupName = reader.string();
	                    break;
	                case 3:
	                    message.members.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : "",
	            members: Array.isArray(object?.members) ? object.members.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        if (message.members) {
	            obj.members = message.members.map(e => e);
	        }
	        else {
	            obj.members = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreateGroup();
	        message.creator = object.creator ?? "";
	        message.groupName = object.groupName ?? "";
	        message.members = object.members?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator,
	            groupName: object?.group_name,
	            members: Array.isArray(object?.members) ? object.members.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        obj.group_name = message.groupName;
	        if (message.members) {
	            obj.members = message.members.map(e => e);
	        }
	        else {
	            obj.members = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgCreateGroupResponse() {
	    return {
	        groupId: ""
	    };
	}
	exports.MsgCreateGroupResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.groupId !== "") {
	            writer.uint32(10).string(message.groupId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateGroupResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.groupId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            groupId: (0, helpers_1.isSet)(object.groupId) ? String(object.groupId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.groupId !== undefined && (obj.groupId = message.groupId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreateGroupResponse();
	        message.groupId = object.groupId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            groupId: object?.group_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.group_id = message.groupId;
	        return obj;
	    }
	};
	function createBaseMsgDeleteGroup() {
	    return {
	        operator: "",
	        groupName: ""
	    };
	}
	exports.MsgDeleteGroup = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(18).string(message.groupName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeleteGroup();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.groupName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDeleteGroup();
	        message.operator = object.operator ?? "";
	        message.groupName = object.groupName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            groupName: object?.group_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.group_name = message.groupName;
	        return obj;
	    }
	};
	function createBaseMsgDeleteGroupResponse() {
	    return {};
	}
	exports.MsgDeleteGroupResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeleteGroupResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDeleteGroupResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateGroupMember() {
	    return {
	        operator: "",
	        groupOwner: "",
	        groupName: "",
	        membersToAdd: [],
	        membersToDelete: []
	    };
	}
	exports.MsgUpdateGroupMember = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.groupOwner !== "") {
	            writer.uint32(18).string(message.groupOwner);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(26).string(message.groupName);
	        }
	        for (const v of message.membersToAdd) {
	            writer.uint32(34).string(v);
	        }
	        for (const v of message.membersToDelete) {
	            writer.uint32(42).string(v);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateGroupMember();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.groupOwner = reader.string();
	                    break;
	                case 3:
	                    message.groupName = reader.string();
	                    break;
	                case 4:
	                    message.membersToAdd.push(reader.string());
	                    break;
	                case 5:
	                    message.membersToDelete.push(reader.string());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            groupOwner: (0, helpers_1.isSet)(object.groupOwner) ? String(object.groupOwner) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : "",
	            membersToAdd: Array.isArray(object?.membersToAdd) ? object.membersToAdd.map((e) => String(e)) : [],
	            membersToDelete: Array.isArray(object?.membersToDelete) ? object.membersToDelete.map((e) => String(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.groupOwner !== undefined && (obj.groupOwner = message.groupOwner);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        if (message.membersToAdd) {
	            obj.membersToAdd = message.membersToAdd.map(e => e);
	        }
	        else {
	            obj.membersToAdd = [];
	        }
	        if (message.membersToDelete) {
	            obj.membersToDelete = message.membersToDelete.map(e => e);
	        }
	        else {
	            obj.membersToDelete = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateGroupMember();
	        message.operator = object.operator ?? "";
	        message.groupOwner = object.groupOwner ?? "";
	        message.groupName = object.groupName ?? "";
	        message.membersToAdd = object.membersToAdd?.map(e => e) || [];
	        message.membersToDelete = object.membersToDelete?.map(e => e) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            groupOwner: object?.group_owner,
	            groupName: object?.group_name,
	            membersToAdd: Array.isArray(object?.members_to_add) ? object.members_to_add.map((e) => e) : [],
	            membersToDelete: Array.isArray(object?.members_to_delete) ? object.members_to_delete.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.group_owner = message.groupOwner;
	        obj.group_name = message.groupName;
	        if (message.membersToAdd) {
	            obj.members_to_add = message.membersToAdd.map(e => e);
	        }
	        else {
	            obj.members_to_add = [];
	        }
	        if (message.membersToDelete) {
	            obj.members_to_delete = message.membersToDelete.map(e => e);
	        }
	        else {
	            obj.members_to_delete = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgUpdateGroupMemberResponse() {
	    return {};
	}
	exports.MsgUpdateGroupMemberResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateGroupMemberResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateGroupMemberResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgLeaveGroup() {
	    return {
	        member: "",
	        groupOwner: "",
	        groupName: ""
	    };
	}
	exports.MsgLeaveGroup = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.member !== "") {
	            writer.uint32(10).string(message.member);
	        }
	        if (message.groupOwner !== "") {
	            writer.uint32(18).string(message.groupOwner);
	        }
	        if (message.groupName !== "") {
	            writer.uint32(26).string(message.groupName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgLeaveGroup();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.member = reader.string();
	                    break;
	                case 2:
	                    message.groupOwner = reader.string();
	                    break;
	                case 3:
	                    message.groupName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            member: (0, helpers_1.isSet)(object.member) ? String(object.member) : "",
	            groupOwner: (0, helpers_1.isSet)(object.groupOwner) ? String(object.groupOwner) : "",
	            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.member !== undefined && (obj.member = message.member);
	        message.groupOwner !== undefined && (obj.groupOwner = message.groupOwner);
	        message.groupName !== undefined && (obj.groupName = message.groupName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgLeaveGroup();
	        message.member = object.member ?? "";
	        message.groupOwner = object.groupOwner ?? "";
	        message.groupName = object.groupName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            member: object?.member,
	            groupOwner: object?.group_owner,
	            groupName: object?.group_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.member = message.member;
	        obj.group_owner = message.groupOwner;
	        obj.group_name = message.groupName;
	        return obj;
	    }
	};
	function createBaseMsgLeaveGroupResponse() {
	    return {};
	}
	exports.MsgLeaveGroupResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgLeaveGroupResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgLeaveGroupResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateBucketInfo() {
	    return {
	        operator: "",
	        bucketName: "",
	        chargedReadQuota: undefined,
	        paymentAddress: "",
	        visibility: 0
	    };
	}
	exports.MsgUpdateBucketInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.chargedReadQuota !== undefined) {
	            wrapper_1.UInt64Value.encode(message.chargedReadQuota, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.paymentAddress !== "") {
	            writer.uint32(34).string(message.paymentAddress);
	        }
	        if (message.visibility !== 0) {
	            writer.uint32(40).int32(message.visibility);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateBucketInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.chargedReadQuota = wrapper_1.UInt64Value.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.paymentAddress = reader.string();
	                    break;
	                case 5:
	                    message.visibility = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            chargedReadQuota: (0, helpers_1.isSet)(object.chargedReadQuota) ? wrapper_1.UInt64Value.fromJSON(object.chargedReadQuota) : undefined,
	            paymentAddress: (0, helpers_1.isSet)(object.paymentAddress) ? String(object.paymentAddress) : "",
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.chargedReadQuota !== undefined && (obj.chargedReadQuota = message.chargedReadQuota ? wrapper_1.UInt64Value.toJSON(message.chargedReadQuota) : undefined);
	        message.paymentAddress !== undefined && (obj.paymentAddress = message.paymentAddress);
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateBucketInfo();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.chargedReadQuota = object.chargedReadQuota !== undefined && object.chargedReadQuota !== null ? wrapper_1.UInt64Value.fromPartial(object.chargedReadQuota) : undefined;
	        message.paymentAddress = object.paymentAddress ?? "";
	        message.visibility = object.visibility ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            chargedReadQuota: object.charged_read_quota ? wrapper_1.UInt64Value.fromSDK(object.charged_read_quota) : undefined,
	            paymentAddress: object?.payment_address,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        message.chargedReadQuota !== undefined && (obj.charged_read_quota = message.chargedReadQuota ? wrapper_1.UInt64Value.toSDK(message.chargedReadQuota) : undefined);
	        obj.payment_address = message.paymentAddress;
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        return obj;
	    }
	};
	function createBaseMsgUpdateBucketInfoResponse() {
	    return {};
	}
	exports.MsgUpdateBucketInfoResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateBucketInfoResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateBucketInfoResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgCancelCreateObject() {
	    return {
	        operator: "",
	        bucketName: "",
	        objectName: ""
	    };
	}
	exports.MsgCancelCreateObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCancelCreateObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCancelCreateObject();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        return obj;
	    }
	};
	function createBaseMsgCancelCreateObjectResponse() {
	    return {};
	}
	exports.MsgCancelCreateObjectResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCancelCreateObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgCancelCreateObjectResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgPutPolicy() {
	    return {
	        operator: "",
	        principal: undefined,
	        resource: "",
	        statements: [],
	        expirationTime: undefined
	    };
	}
	exports.MsgPutPolicy = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.principal !== undefined) {
	            common_2.Principal.encode(message.principal, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.resource !== "") {
	            writer.uint32(26).string(message.resource);
	        }
	        for (const v of message.statements) {
	            common_2.Statement.encode(v, writer.uint32(34).fork()).ldelim();
	        }
	        if (message.expirationTime !== undefined) {
	            timestamp_1.Timestamp.encode(message.expirationTime, writer.uint32(58).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgPutPolicy();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.principal = common_2.Principal.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.resource = reader.string();
	                    break;
	                case 4:
	                    message.statements.push(common_2.Statement.decode(reader, reader.uint32()));
	                    break;
	                case 7:
	                    message.expirationTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            principal: (0, helpers_1.isSet)(object.principal) ? common_2.Principal.fromJSON(object.principal) : undefined,
	            resource: (0, helpers_1.isSet)(object.resource) ? String(object.resource) : "",
	            statements: Array.isArray(object?.statements) ? object.statements.map((e) => common_2.Statement.fromJSON(e)) : [],
	            expirationTime: (0, helpers_1.isSet)(object.expirationTime) ? (0, helpers_1.fromJsonTimestamp)(object.expirationTime) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.principal !== undefined && (obj.principal = message.principal ? common_2.Principal.toJSON(message.principal) : undefined);
	        message.resource !== undefined && (obj.resource = message.resource);
	        if (message.statements) {
	            obj.statements = message.statements.map(e => e ? common_2.Statement.toJSON(e) : undefined);
	        }
	        else {
	            obj.statements = [];
	        }
	        message.expirationTime !== undefined && (obj.expirationTime = (0, helpers_1.fromTimestamp)(message.expirationTime).toISOString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgPutPolicy();
	        message.operator = object.operator ?? "";
	        message.principal = object.principal !== undefined && object.principal !== null ? common_2.Principal.fromPartial(object.principal) : undefined;
	        message.resource = object.resource ?? "";
	        message.statements = object.statements?.map(e => common_2.Statement.fromPartial(e)) || [];
	        message.expirationTime = object.expirationTime !== undefined && object.expirationTime !== null ? timestamp_1.Timestamp.fromPartial(object.expirationTime) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            principal: object.principal ? common_2.Principal.fromSDK(object.principal) : undefined,
	            resource: object?.resource,
	            statements: Array.isArray(object?.statements) ? object.statements.map((e) => common_2.Statement.fromSDK(e)) : [],
	            expirationTime: object.expiration_time ? timestamp_1.Timestamp.fromSDK(object.expiration_time) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        message.principal !== undefined && (obj.principal = message.principal ? common_2.Principal.toSDK(message.principal) : undefined);
	        obj.resource = message.resource;
	        if (message.statements) {
	            obj.statements = message.statements.map(e => e ? common_2.Statement.toSDK(e) : undefined);
	        }
	        else {
	            obj.statements = [];
	        }
	        message.expirationTime !== undefined && (obj.expiration_time = message.expirationTime ? timestamp_1.Timestamp.toSDK(message.expirationTime) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgPutPolicyResponse() {
	    return {
	        policyId: ""
	    };
	}
	exports.MsgPutPolicyResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.policyId !== "") {
	            writer.uint32(34).string(message.policyId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgPutPolicyResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 4:
	                    message.policyId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            policyId: (0, helpers_1.isSet)(object.policyId) ? String(object.policyId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.policyId !== undefined && (obj.policyId = message.policyId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgPutPolicyResponse();
	        message.policyId = object.policyId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            policyId: object?.policy_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.policy_id = message.policyId;
	        return obj;
	    }
	};
	function createBaseMsgDeletePolicy() {
	    return {
	        operator: "",
	        principal: undefined,
	        resource: ""
	    };
	}
	exports.MsgDeletePolicy = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.principal !== undefined) {
	            common_2.Principal.encode(message.principal, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.resource !== "") {
	            writer.uint32(26).string(message.resource);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeletePolicy();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.principal = common_2.Principal.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.resource = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            principal: (0, helpers_1.isSet)(object.principal) ? common_2.Principal.fromJSON(object.principal) : undefined,
	            resource: (0, helpers_1.isSet)(object.resource) ? String(object.resource) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.principal !== undefined && (obj.principal = message.principal ? common_2.Principal.toJSON(message.principal) : undefined);
	        message.resource !== undefined && (obj.resource = message.resource);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDeletePolicy();
	        message.operator = object.operator ?? "";
	        message.principal = object.principal !== undefined && object.principal !== null ? common_2.Principal.fromPartial(object.principal) : undefined;
	        message.resource = object.resource ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            principal: object.principal ? common_2.Principal.fromSDK(object.principal) : undefined,
	            resource: object?.resource
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        message.principal !== undefined && (obj.principal = message.principal ? common_2.Principal.toSDK(message.principal) : undefined);
	        obj.resource = message.resource;
	        return obj;
	    }
	};
	function createBaseMsgDeletePolicyResponse() {
	    return {
	        policyId: ""
	    };
	}
	exports.MsgDeletePolicyResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.policyId !== "") {
	            writer.uint32(34).string(message.policyId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeletePolicyResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 4:
	                    message.policyId = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            policyId: (0, helpers_1.isSet)(object.policyId) ? String(object.policyId) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.policyId !== undefined && (obj.policyId = message.policyId);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDeletePolicyResponse();
	        message.policyId = object.policyId ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            policyId: object?.policy_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.policy_id = message.policyId;
	        return obj;
	    }
	};
	function createBaseMsgMirrorObject() {
	    return {
	        operator: "",
	        id: ""
	    };
	}
	exports.MsgMirrorObject = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.id !== "") {
	            writer.uint32(18).string(message.id);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMirrorObject();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.id = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.id !== undefined && (obj.id = message.id);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgMirrorObject();
	        message.operator = object.operator ?? "";
	        message.id = object.id ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            id: object?.id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.id = message.id;
	        return obj;
	    }
	};
	function createBaseMsgMirrorObjectResponse() {
	    return {};
	}
	exports.MsgMirrorObjectResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMirrorObjectResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgMirrorObjectResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgMirrorBucket() {
	    return {
	        operator: "",
	        id: ""
	    };
	}
	exports.MsgMirrorBucket = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.id !== "") {
	            writer.uint32(18).string(message.id);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMirrorBucket();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.id = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.id !== undefined && (obj.id = message.id);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgMirrorBucket();
	        message.operator = object.operator ?? "";
	        message.id = object.id ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            id: object?.id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.id = message.id;
	        return obj;
	    }
	};
	function createBaseMsgUpdateObjectInfoResponse() {
	    return {};
	}
	exports.MsgUpdateObjectInfoResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateObjectInfoResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateObjectInfoResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateObjectInfo() {
	    return {
	        operator: "",
	        bucketName: "",
	        objectName: "",
	        visibility: 0
	    };
	}
	exports.MsgUpdateObjectInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(18).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(26).string(message.objectName);
	        }
	        if (message.visibility !== 0) {
	            writer.uint32(32).int32(message.visibility);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateObjectInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.bucketName = reader.string();
	                    break;
	                case 3:
	                    message.objectName = reader.string();
	                    break;
	                case 4:
	                    message.visibility = reader.int32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateObjectInfo();
	        message.operator = object.operator ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        message.visibility = object.visibility ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name,
	            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
	        return obj;
	    }
	};
	function createBaseMsgMirrorBucketResponse() {
	    return {};
	}
	exports.MsgMirrorBucketResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMirrorBucketResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgMirrorBucketResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgMirrorGroup() {
	    return {
	        operator: "",
	        id: ""
	    };
	}
	exports.MsgMirrorGroup = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operator !== "") {
	            writer.uint32(10).string(message.operator);
	        }
	        if (message.id !== "") {
	            writer.uint32(18).string(message.id);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMirrorGroup();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operator = reader.string();
	                    break;
	                case 2:
	                    message.id = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operator: (0, helpers_1.isSet)(object.operator) ? String(object.operator) : "",
	            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operator !== undefined && (obj.operator = message.operator);
	        message.id !== undefined && (obj.id = message.id);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgMirrorGroup();
	        message.operator = object.operator ?? "";
	        message.id = object.id ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operator: object?.operator,
	            id: object?.id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator = message.operator;
	        obj.id = message.id;
	        return obj;
	    }
	};
	function createBaseMsgMirrorGroupResponse() {
	    return {};
	}
	exports.MsgMirrorGroupResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgMirrorGroupResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgMirrorGroupResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.CreateBucket = this.CreateBucket.bind(this);
	        this.DeleteBucket = this.DeleteBucket.bind(this);
	        this.UpdateBucketInfo = this.UpdateBucketInfo.bind(this);
	        this.MirrorBucket = this.MirrorBucket.bind(this);
	        this.DiscontinueBucket = this.DiscontinueBucket.bind(this);
	        this.CreateObject = this.CreateObject.bind(this);
	        this.SealObject = this.SealObject.bind(this);
	        this.RejectSealObject = this.RejectSealObject.bind(this);
	        this.CopyObject = this.CopyObject.bind(this);
	        this.DeleteObject = this.DeleteObject.bind(this);
	        this.CancelCreateObject = this.CancelCreateObject.bind(this);
	        this.MirrorObject = this.MirrorObject.bind(this);
	        this.DiscontinueObject = this.DiscontinueObject.bind(this);
	        this.UpdateObjectInfo = this.UpdateObjectInfo.bind(this);
	        this.CreateGroup = this.CreateGroup.bind(this);
	        this.DeleteGroup = this.DeleteGroup.bind(this);
	        this.UpdateGroupMember = this.UpdateGroupMember.bind(this);
	        this.LeaveGroup = this.LeaveGroup.bind(this);
	        this.MirrorGroup = this.MirrorGroup.bind(this);
	        this.PutPolicy = this.PutPolicy.bind(this);
	        this.DeletePolicy = this.DeletePolicy.bind(this);
	        this.UpdateParams = this.UpdateParams.bind(this);
	    }
	    CreateBucket(request) {
	        const data = exports.MsgCreateBucket.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "CreateBucket", data);
	        return promise.then(data => exports.MsgCreateBucketResponse.decode(new _m0.Reader(data)));
	    }
	    DeleteBucket(request) {
	        const data = exports.MsgDeleteBucket.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "DeleteBucket", data);
	        return promise.then(data => exports.MsgDeleteBucketResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateBucketInfo(request) {
	        const data = exports.MsgUpdateBucketInfo.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "UpdateBucketInfo", data);
	        return promise.then(data => exports.MsgUpdateBucketInfoResponse.decode(new _m0.Reader(data)));
	    }
	    MirrorBucket(request) {
	        const data = exports.MsgMirrorBucket.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "MirrorBucket", data);
	        return promise.then(data => exports.MsgMirrorBucketResponse.decode(new _m0.Reader(data)));
	    }
	    DiscontinueBucket(request) {
	        const data = exports.MsgDiscontinueBucket.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "DiscontinueBucket", data);
	        return promise.then(data => exports.MsgDiscontinueBucketResponse.decode(new _m0.Reader(data)));
	    }
	    CreateObject(request) {
	        const data = exports.MsgCreateObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "CreateObject", data);
	        return promise.then(data => exports.MsgCreateObjectResponse.decode(new _m0.Reader(data)));
	    }
	    SealObject(request) {
	        const data = exports.MsgSealObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "SealObject", data);
	        return promise.then(data => exports.MsgSealObjectResponse.decode(new _m0.Reader(data)));
	    }
	    RejectSealObject(request) {
	        const data = exports.MsgRejectSealObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "RejectSealObject", data);
	        return promise.then(data => exports.MsgRejectSealObjectResponse.decode(new _m0.Reader(data)));
	    }
	    CopyObject(request) {
	        const data = exports.MsgCopyObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "CopyObject", data);
	        return promise.then(data => exports.MsgCopyObjectResponse.decode(new _m0.Reader(data)));
	    }
	    DeleteObject(request) {
	        const data = exports.MsgDeleteObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "DeleteObject", data);
	        return promise.then(data => exports.MsgDeleteObjectResponse.decode(new _m0.Reader(data)));
	    }
	    CancelCreateObject(request) {
	        const data = exports.MsgCancelCreateObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "CancelCreateObject", data);
	        return promise.then(data => exports.MsgCancelCreateObjectResponse.decode(new _m0.Reader(data)));
	    }
	    MirrorObject(request) {
	        const data = exports.MsgMirrorObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "MirrorObject", data);
	        return promise.then(data => exports.MsgMirrorObjectResponse.decode(new _m0.Reader(data)));
	    }
	    DiscontinueObject(request) {
	        const data = exports.MsgDiscontinueObject.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "DiscontinueObject", data);
	        return promise.then(data => exports.MsgDiscontinueObjectResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateObjectInfo(request) {
	        const data = exports.MsgUpdateObjectInfo.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "UpdateObjectInfo", data);
	        return promise.then(data => exports.MsgUpdateObjectInfoResponse.decode(new _m0.Reader(data)));
	    }
	    CreateGroup(request) {
	        const data = exports.MsgCreateGroup.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "CreateGroup", data);
	        return promise.then(data => exports.MsgCreateGroupResponse.decode(new _m0.Reader(data)));
	    }
	    DeleteGroup(request) {
	        const data = exports.MsgDeleteGroup.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "DeleteGroup", data);
	        return promise.then(data => exports.MsgDeleteGroupResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateGroupMember(request) {
	        const data = exports.MsgUpdateGroupMember.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "UpdateGroupMember", data);
	        return promise.then(data => exports.MsgUpdateGroupMemberResponse.decode(new _m0.Reader(data)));
	    }
	    LeaveGroup(request) {
	        const data = exports.MsgLeaveGroup.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "LeaveGroup", data);
	        return promise.then(data => exports.MsgLeaveGroupResponse.decode(new _m0.Reader(data)));
	    }
	    MirrorGroup(request) {
	        const data = exports.MsgMirrorGroup.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "MirrorGroup", data);
	        return promise.then(data => exports.MsgMirrorGroupResponse.decode(new _m0.Reader(data)));
	    }
	    PutPolicy(request) {
	        const data = exports.MsgPutPolicy.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "PutPolicy", data);
	        return promise.then(data => exports.MsgPutPolicyResponse.decode(new _m0.Reader(data)));
	    }
	    DeletePolicy(request) {
	        const data = exports.MsgDeletePolicy.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "DeletePolicy", data);
	        return promise.then(data => exports.MsgDeletePolicyResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("greenfield.storage.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx$5));

tx$5.default;

class Bucket extends Account {
    // private sp: ISp = new Sp(this.rpcUrl, this.chainId);
    /* private async getRandomSpInfo(): Promise<ISpInfo> {
      const spList = await this.sp.getStorageProviders();
      if (!spList || spList.length === 0) {
        return {} as ISpInfo;
      }
  
      const randomIndex = Math.floor(Math.random() * spList.length);
      const selectSp = spList[randomIndex];
      const secondarySpAddresses = spList
        .filter((_, index) => index !== randomIndex)
        .map((sp) => sp.operatorAddress);
      const { endpoint, operatorAddress, sealAddress } = selectSp;
  
      return {
        endpoint,
        primarySpAddress: operatorAddress,
        sealAddress,
        secondarySpAddresses,
      };
    } */
    getCreateBucketApproval({ bucketName, creator, visibility = 'VISIBILITY_TYPE_PUBLIC_READ', chargedReadQuota, spInfo, duration, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!spInfo.primarySpAddress) {
                    throw new Error('Primary sp address is missing');
                }
                if (!isValidBucketName(bucketName)) ;
                if (!creator) {
                    throw new Error('Empty creator address');
                }
                const endpoint = spInfo.endpoint;
                const msg = {
                    bucket_name: bucketName,
                    creator,
                    visibility,
                    primary_sp_address: spInfo.primarySpAddress,
                    primary_sp_approval: {
                        expired_height: '0',
                        sig: '',
                    },
                    charged_read_quota: chargedReadQuota,
                    payment_address: '',
                };
                const url = endpoint + '/greenfield/admin/v1/get-approval?action=CreateBucket';
                const unSignedMessageInHex = encodeObjectToHexString(msg);
                const headers = new Headers({
                    // TODO: replace when offchain release
                    Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${MOCK_SIGNATURE}`,
                    'X-Gnfd-Unsigned-Msg': unSignedMessageInHex,
                });
                const result = yield fetchWithTimeout(url, {
                    headers,
                    method: METHOD_GET,
                }, duration);
                const { status } = result;
                if (!result.ok) {
                    return {
                        code: -1,
                        message: 'Get create bucket approval error.',
                        statusCode: status,
                    };
                }
                const resultContentType = result.headers.get('Content-Type');
                if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                    const xmlText = yield result.text();
                    const xml = yield new window.DOMParser().parseFromString(xmlText, 'text/xml');
                    return {
                        code: -1,
                        xml,
                        message: 'Get create bucket approval error.',
                        statusCode: status,
                    };
                }
                const signedMsgString = result.headers.get('X-Gnfd-Signed-Msg') || '';
                const signedMsg = decodeObjectFromHexString(signedMsgString);
                return {
                    code: 0,
                    message: 'Get create bucket approval success.',
                    body: signedMsgString,
                    statusCode: status,
                    signedMsg: signedMsg,
                };
            }
            catch (error) {
                return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
            }
        });
    }
    createBucket(params, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const { signedMsg } = yield this.getCreateBucketApproval(params);
            if (!signedMsg) {
                throw new Error('Get create bucket approval error');
            }
            const sig = signedMsg.primary_sp_approval.sig;
            const expiredHeight = signedMsg.primary_sp_approval.expired_height;
            const msg = {
                bucketName: signedMsg.bucket_name,
                creator: signedMsg.creator,
                visibility: common$3.visibilityTypeFromJSON(signedMsg.visibility),
                primarySpAddress: signedMsg.primary_sp_address,
                primarySpApproval: {
                    expiredHeight: Long__default["default"].fromString(expiredHeight),
                    sig: bytesFromBase64_1(sig),
                },
                chargedReadQuota: signedMsg.charged_read_quota
                    ? Long__default["default"].fromString('0')
                    : Long__default["default"].fromString(signedMsg.charged_read_quota),
                paymentAddress: '',
            };
            const typeUrl = '/bnbchain.greenfield.storage.MsgCreateBucket';
            const msgBytes = tx$5.MsgCreateBucket.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.creator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgCreateBucketSDKTypeEIP712, Object.assign(Object.assign({}, signedMsg), { type: typeUrl, charged_read_quota: signedMsg.charged_read_quota, visibility: signedMsg.visibility, primary_sp_approval: {
                    expired_height: expiredHeight,
                    sig,
                } }), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    deleteBucket(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgDeleteBucket';
            const msgBytes = tx$5.MsgDeleteBucket.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgDeleteBucketSDKTypeEIP712, tx$5.MsgDeleteBucket.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    headBucket(bucketName) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return yield rpc.HeadBucket({
                bucketName,
            });
        });
    }
    headBucketById(bucketId) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return yield rpc.HeadBucketById({
                bucketId,
            });
        });
    }
    getVerifyPermission(bucketName, operator, actionType) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return rpc.VerifyPermission({
                bucketName,
                operator,
                objectName: '',
                actionType,
            });
        });
    }
    getUserBuckets(configParam) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { address, duration = 30000, endpoint } = configParam;
                if (!isValidAddress(address)) ;
                if (!isValidUrl(endpoint)) {
                    throw new Error('Invalid endpoint');
                }
                const url = endpoint;
                const signature = MOCK_SIGNATURE;
                const headers = new Headers({
                    // todo place the correct authorization string
                    Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                    'X-Gnfd-User-Address': address,
                });
                const result = yield fetchWithTimeout(url, {
                    headers,
                    method: METHOD_GET,
                }, duration);
                const { status } = result;
                if (!result.ok) {
                    return { code: -1, message: 'Get bucket error.', statusCode: status };
                }
                const { buckets } = yield result.json();
                return {
                    code: 0,
                    message: 'Get bucket success.',
                    statusCode: status,
                    body: buckets,
                };
            }
            catch (error) {
                return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
            }
        });
    }
    getBucketReadQuota(configParam) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { bucketName, endpoint, duration = 30000, year, month } = configParam;
                // todo generate real signature
                const signature = MOCK_SIGNATURE;
                if (!isValidUrl(endpoint)) {
                    throw new Error('Invalid endpoint');
                }
                if (!isValidBucketName(bucketName)) ;
                const currentDate = new Date();
                const finalYear = year ? year : currentDate.getFullYear();
                const finalMonth = month ? month : currentDate.getMonth() + 1;
                const formattedMonth = finalMonth.toString().padStart(2, '0'); // format month to 2 digits, like "01"
                const url = generateUrlByBucketName(endpoint, bucketName) +
                    `/?read-quota&year-month=${finalYear}-${formattedMonth}`;
                const headers = new Headers({
                    Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                });
                const result = yield fetchWithTimeout(url, {
                    headers,
                    method: METHOD_GET,
                }, duration);
                const { status } = result;
                if (!result.ok) {
                    return { code: -1, message: 'Get Bucket Quota error.', statusCode: status };
                }
                const resultContentType = result.headers.get('Content-Type');
                // Will receive xml when get object met error
                if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                    const xmlText = yield result.text();
                    const xml = yield new window.DOMParser().parseFromString(xmlText, 'text/xml');
                    const ReadQuotaSize = xml.getElementsByTagName('ReadQuotaSize')[0]
                        .textContent;
                    const SPFreeReadQuotaSize = xml.getElementsByTagName('SPFreeReadQuotaSize')[0].textContent;
                    const ReadConsumedSize = xml.getElementsByTagName('ReadConsumedSize')[0]
                        .textContent;
                    return {
                        code: 0,
                        body: {
                            readQuota: Number(ReadQuotaSize !== null && ReadQuotaSize !== void 0 ? ReadQuotaSize : '0'),
                            freeQuota: Number(SPFreeReadQuotaSize !== null && SPFreeReadQuotaSize !== void 0 ? SPFreeReadQuotaSize : '0'),
                            consumedQuota: Number(ReadConsumedSize !== null && ReadConsumedSize !== void 0 ? ReadConsumedSize : '0'),
                        },
                        message: 'Get bucket read quota.',
                        statusCode: status,
                    };
                }
                else {
                    return {
                        code: -1,
                        message: 'Get bucket read quota error.',
                        statusCode: status,
                    };
                }
            }
            catch (error) {
                return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
            }
        });
    }
    updateBucketInfo(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgUpdateBucketInfo';
            const msgBytes = tx$5.MsgUpdateBucketInfo.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgUpdateBucketInfoSDKTypeEIP712, tx$5.MsgUpdateBucketInfo.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    putBucketPolicy(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgPutPolicy';
            const msgBytes = tx$5.MsgPutPolicy.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgPutPolicySDKTypeEIP712, tx$5.MsgPutPolicy.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    deleteBucketPolicy(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgDeletePolicy';
            const msgBytes = tx$5.MsgDeletePolicy.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgDeletePolicySDKTypeEIP712, tx$5.MsgDeletePolicy.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
}

const MsgAttestSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "challenger"
    },
    {
      "type": "string",
      "name": "sp_operator_address"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "segment_index"
    },
    {
      "type": "bool",
      "name": "random_index"
    },
    {
      "type": "string",
      "name": "submitter"
    },
    {
      "type": "uint64",
      "name": "challenge_id"
    },
    {
      "type": "string",
      "name": "object_id"
    },
    {
      "type": "string",
      "name": "sp_operator_address"
    },
    {
      "type": "string",
      "name": "vote_result"
    },
    {
      "type": "string",
      "name": "challenger_address"
    },
    {
      "type": "uint64[]",
      "name": "vote_validator_set"
    },
    {
      "type": "bytes",
      "name": "vote_agg_signature"
    }
  ]
};

const MsgSubmitSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "challenger"
    },
    {
      "type": "string",
      "name": "sp_operator_address"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "segment_index"
    },
    {
      "type": "bool",
      "name": "random_index"
    }
  ]
};

var query$4 = {};

var params$2 = {};

var __createBinding$4 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$4 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$4 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
    __setModuleDefault$4(result, mod);
    return result;
};
Object.defineProperty(params$2, "__esModule", { value: true });
params$2.Params = params$2.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$4 = helpers;
const _m0$4 = __importStar$4(minimal$1.exports);
params$2.protobufPackage = "greenfield.challenge";
function createBaseParams$4() {
    return {
        challengeCountPerBlock: helpers_1$4.Long.UZERO,
        challengeKeepAlivePeriod: helpers_1$4.Long.UZERO,
        slashCoolingOffPeriod: helpers_1$4.Long.UZERO,
        slashAmountSizeRate: "",
        slashAmountMin: "",
        slashAmountMax: "",
        rewardValidatorRatio: "",
        rewardSubmitterRatio: "",
        rewardSubmitterThreshold: "",
        heartbeatInterval: helpers_1$4.Long.UZERO,
        attestationInturnInterval: helpers_1$4.Long.UZERO,
        attestationKeptCount: helpers_1$4.Long.UZERO
    };
}
params$2.Params = {
    encode(message, writer = _m0$4.Writer.create()) {
        if (!message.challengeCountPerBlock.isZero()) {
            writer.uint32(8).uint64(message.challengeCountPerBlock);
        }
        if (!message.challengeKeepAlivePeriod.isZero()) {
            writer.uint32(16).uint64(message.challengeKeepAlivePeriod);
        }
        if (!message.slashCoolingOffPeriod.isZero()) {
            writer.uint32(24).uint64(message.slashCoolingOffPeriod);
        }
        if (message.slashAmountSizeRate !== "") {
            writer.uint32(34).string(message.slashAmountSizeRate);
        }
        if (message.slashAmountMin !== "") {
            writer.uint32(42).string(message.slashAmountMin);
        }
        if (message.slashAmountMax !== "") {
            writer.uint32(50).string(message.slashAmountMax);
        }
        if (message.rewardValidatorRatio !== "") {
            writer.uint32(58).string(message.rewardValidatorRatio);
        }
        if (message.rewardSubmitterRatio !== "") {
            writer.uint32(66).string(message.rewardSubmitterRatio);
        }
        if (message.rewardSubmitterThreshold !== "") {
            writer.uint32(74).string(message.rewardSubmitterThreshold);
        }
        if (!message.heartbeatInterval.isZero()) {
            writer.uint32(80).uint64(message.heartbeatInterval);
        }
        if (!message.attestationInturnInterval.isZero()) {
            writer.uint32(88).uint64(message.attestationInturnInterval);
        }
        if (!message.attestationKeptCount.isZero()) {
            writer.uint32(96).uint64(message.attestationKeptCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$4.Reader ? input : new _m0$4.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$4();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.challengeCountPerBlock = reader.uint64();
                    break;
                case 2:
                    message.challengeKeepAlivePeriod = reader.uint64();
                    break;
                case 3:
                    message.slashCoolingOffPeriod = reader.uint64();
                    break;
                case 4:
                    message.slashAmountSizeRate = reader.string();
                    break;
                case 5:
                    message.slashAmountMin = reader.string();
                    break;
                case 6:
                    message.slashAmountMax = reader.string();
                    break;
                case 7:
                    message.rewardValidatorRatio = reader.string();
                    break;
                case 8:
                    message.rewardSubmitterRatio = reader.string();
                    break;
                case 9:
                    message.rewardSubmitterThreshold = reader.string();
                    break;
                case 10:
                    message.heartbeatInterval = reader.uint64();
                    break;
                case 11:
                    message.attestationInturnInterval = reader.uint64();
                    break;
                case 12:
                    message.attestationKeptCount = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            challengeCountPerBlock: (0, helpers_1$4.isSet)(object.challengeCountPerBlock) ? helpers_1$4.Long.fromValue(object.challengeCountPerBlock) : helpers_1$4.Long.UZERO,
            challengeKeepAlivePeriod: (0, helpers_1$4.isSet)(object.challengeKeepAlivePeriod) ? helpers_1$4.Long.fromValue(object.challengeKeepAlivePeriod) : helpers_1$4.Long.UZERO,
            slashCoolingOffPeriod: (0, helpers_1$4.isSet)(object.slashCoolingOffPeriod) ? helpers_1$4.Long.fromValue(object.slashCoolingOffPeriod) : helpers_1$4.Long.UZERO,
            slashAmountSizeRate: (0, helpers_1$4.isSet)(object.slashAmountSizeRate) ? String(object.slashAmountSizeRate) : "",
            slashAmountMin: (0, helpers_1$4.isSet)(object.slashAmountMin) ? String(object.slashAmountMin) : "",
            slashAmountMax: (0, helpers_1$4.isSet)(object.slashAmountMax) ? String(object.slashAmountMax) : "",
            rewardValidatorRatio: (0, helpers_1$4.isSet)(object.rewardValidatorRatio) ? String(object.rewardValidatorRatio) : "",
            rewardSubmitterRatio: (0, helpers_1$4.isSet)(object.rewardSubmitterRatio) ? String(object.rewardSubmitterRatio) : "",
            rewardSubmitterThreshold: (0, helpers_1$4.isSet)(object.rewardSubmitterThreshold) ? String(object.rewardSubmitterThreshold) : "",
            heartbeatInterval: (0, helpers_1$4.isSet)(object.heartbeatInterval) ? helpers_1$4.Long.fromValue(object.heartbeatInterval) : helpers_1$4.Long.UZERO,
            attestationInturnInterval: (0, helpers_1$4.isSet)(object.attestationInturnInterval) ? helpers_1$4.Long.fromValue(object.attestationInturnInterval) : helpers_1$4.Long.UZERO,
            attestationKeptCount: (0, helpers_1$4.isSet)(object.attestationKeptCount) ? helpers_1$4.Long.fromValue(object.attestationKeptCount) : helpers_1$4.Long.UZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.challengeCountPerBlock !== undefined && (obj.challengeCountPerBlock = (message.challengeCountPerBlock || helpers_1$4.Long.UZERO).toString());
        message.challengeKeepAlivePeriod !== undefined && (obj.challengeKeepAlivePeriod = (message.challengeKeepAlivePeriod || helpers_1$4.Long.UZERO).toString());
        message.slashCoolingOffPeriod !== undefined && (obj.slashCoolingOffPeriod = (message.slashCoolingOffPeriod || helpers_1$4.Long.UZERO).toString());
        message.slashAmountSizeRate !== undefined && (obj.slashAmountSizeRate = message.slashAmountSizeRate);
        message.slashAmountMin !== undefined && (obj.slashAmountMin = message.slashAmountMin);
        message.slashAmountMax !== undefined && (obj.slashAmountMax = message.slashAmountMax);
        message.rewardValidatorRatio !== undefined && (obj.rewardValidatorRatio = message.rewardValidatorRatio);
        message.rewardSubmitterRatio !== undefined && (obj.rewardSubmitterRatio = message.rewardSubmitterRatio);
        message.rewardSubmitterThreshold !== undefined && (obj.rewardSubmitterThreshold = message.rewardSubmitterThreshold);
        message.heartbeatInterval !== undefined && (obj.heartbeatInterval = (message.heartbeatInterval || helpers_1$4.Long.UZERO).toString());
        message.attestationInturnInterval !== undefined && (obj.attestationInturnInterval = (message.attestationInturnInterval || helpers_1$4.Long.UZERO).toString());
        message.attestationKeptCount !== undefined && (obj.attestationKeptCount = (message.attestationKeptCount || helpers_1$4.Long.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseParams$4();
        message.challengeCountPerBlock = object.challengeCountPerBlock !== undefined && object.challengeCountPerBlock !== null ? helpers_1$4.Long.fromValue(object.challengeCountPerBlock) : helpers_1$4.Long.UZERO;
        message.challengeKeepAlivePeriod = object.challengeKeepAlivePeriod !== undefined && object.challengeKeepAlivePeriod !== null ? helpers_1$4.Long.fromValue(object.challengeKeepAlivePeriod) : helpers_1$4.Long.UZERO;
        message.slashCoolingOffPeriod = object.slashCoolingOffPeriod !== undefined && object.slashCoolingOffPeriod !== null ? helpers_1$4.Long.fromValue(object.slashCoolingOffPeriod) : helpers_1$4.Long.UZERO;
        message.slashAmountSizeRate = object.slashAmountSizeRate ?? "";
        message.slashAmountMin = object.slashAmountMin ?? "";
        message.slashAmountMax = object.slashAmountMax ?? "";
        message.rewardValidatorRatio = object.rewardValidatorRatio ?? "";
        message.rewardSubmitterRatio = object.rewardSubmitterRatio ?? "";
        message.rewardSubmitterThreshold = object.rewardSubmitterThreshold ?? "";
        message.heartbeatInterval = object.heartbeatInterval !== undefined && object.heartbeatInterval !== null ? helpers_1$4.Long.fromValue(object.heartbeatInterval) : helpers_1$4.Long.UZERO;
        message.attestationInturnInterval = object.attestationInturnInterval !== undefined && object.attestationInturnInterval !== null ? helpers_1$4.Long.fromValue(object.attestationInturnInterval) : helpers_1$4.Long.UZERO;
        message.attestationKeptCount = object.attestationKeptCount !== undefined && object.attestationKeptCount !== null ? helpers_1$4.Long.fromValue(object.attestationKeptCount) : helpers_1$4.Long.UZERO;
        return message;
    },
    fromSDK(object) {
        return {
            challengeCountPerBlock: object?.challenge_count_per_block,
            challengeKeepAlivePeriod: object?.challenge_keep_alive_period,
            slashCoolingOffPeriod: object?.slash_cooling_off_period,
            slashAmountSizeRate: object?.slash_amount_size_rate,
            slashAmountMin: object?.slash_amount_min,
            slashAmountMax: object?.slash_amount_max,
            rewardValidatorRatio: object?.reward_validator_ratio,
            rewardSubmitterRatio: object?.reward_submitter_ratio,
            rewardSubmitterThreshold: object?.reward_submitter_threshold,
            heartbeatInterval: object?.heartbeat_interval,
            attestationInturnInterval: object?.attestation_inturn_interval,
            attestationKeptCount: object?.attestation_kept_count
        };
    },
    toSDK(message) {
        const obj = {};
        obj.challenge_count_per_block = message.challengeCountPerBlock;
        obj.challenge_keep_alive_period = message.challengeKeepAlivePeriod;
        obj.slash_cooling_off_period = message.slashCoolingOffPeriod;
        obj.slash_amount_size_rate = message.slashAmountSizeRate;
        obj.slash_amount_min = message.slashAmountMin;
        obj.slash_amount_max = message.slashAmountMax;
        obj.reward_validator_ratio = message.rewardValidatorRatio;
        obj.reward_submitter_ratio = message.rewardSubmitterRatio;
        obj.reward_submitter_threshold = message.rewardSubmitterThreshold;
        obj.heartbeat_interval = message.heartbeatInterval;
        obj.attestation_inturn_interval = message.attestationInturnInterval;
        obj.attestation_kept_count = message.attestationKeptCount;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.SubmitInterval = exports.QueryInturnAttestationSubmitterResponse = exports.QueryInturnAttestationSubmitterRequest = exports.QueryLatestAttestedChallengesResponse = exports.QueryLatestAttestedChallengesRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const params_1 = params$2;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.challenge";
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryLatestAttestedChallengesRequest() {
	    return {};
	}
	exports.QueryLatestAttestedChallengesRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryLatestAttestedChallengesRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryLatestAttestedChallengesRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryLatestAttestedChallengesResponse() {
	    return {
	        challengeIds: []
	    };
	}
	exports.QueryLatestAttestedChallengesResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        writer.uint32(10).fork();
	        for (const v of message.challengeIds) {
	            writer.uint64(v);
	        }
	        writer.ldelim();
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryLatestAttestedChallengesResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    if ((tag & 7) === 2) {
	                        const end2 = reader.uint32() + reader.pos;
	                        while (reader.pos < end2) {
	                            message.challengeIds.push(reader.uint64());
	                        }
	                    }
	                    else {
	                        message.challengeIds.push(reader.uint64());
	                    }
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            challengeIds: Array.isArray(object?.challengeIds) ? object.challengeIds.map((e) => helpers_1.Long.fromValue(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.challengeIds) {
	            obj.challengeIds = message.challengeIds.map(e => (e || helpers_1.Long.UZERO).toString());
	        }
	        else {
	            obj.challengeIds = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryLatestAttestedChallengesResponse();
	        message.challengeIds = object.challengeIds?.map(e => helpers_1.Long.fromValue(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            challengeIds: Array.isArray(object?.challengeIds) ? object.challengeIds.map((e) => e) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.challengeIds) {
	            obj.challengeIds = message.challengeIds.map(e => e);
	        }
	        else {
	            obj.challengeIds = [];
	        }
	        return obj;
	    }
	};
	function createBaseQueryInturnAttestationSubmitterRequest() {
	    return {};
	}
	exports.QueryInturnAttestationSubmitterRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryInturnAttestationSubmitterRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryInturnAttestationSubmitterRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryInturnAttestationSubmitterResponse() {
	    return {
	        blsPubKey: "",
	        submitInterval: undefined
	    };
	}
	exports.QueryInturnAttestationSubmitterResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.blsPubKey !== "") {
	            writer.uint32(10).string(message.blsPubKey);
	        }
	        if (message.submitInterval !== undefined) {
	            exports.SubmitInterval.encode(message.submitInterval, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryInturnAttestationSubmitterResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blsPubKey = reader.string();
	                    break;
	                case 2:
	                    message.submitInterval = exports.SubmitInterval.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blsPubKey: (0, helpers_1.isSet)(object.blsPubKey) ? String(object.blsPubKey) : "",
	            submitInterval: (0, helpers_1.isSet)(object.submitInterval) ? exports.SubmitInterval.fromJSON(object.submitInterval) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blsPubKey !== undefined && (obj.blsPubKey = message.blsPubKey);
	        message.submitInterval !== undefined && (obj.submitInterval = message.submitInterval ? exports.SubmitInterval.toJSON(message.submitInterval) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryInturnAttestationSubmitterResponse();
	        message.blsPubKey = object.blsPubKey ?? "";
	        message.submitInterval = object.submitInterval !== undefined && object.submitInterval !== null ? exports.SubmitInterval.fromPartial(object.submitInterval) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blsPubKey: object?.bls_pub_key,
	            submitInterval: object.submit_interval ? exports.SubmitInterval.fromSDK(object.submit_interval) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.bls_pub_key = message.blsPubKey;
	        message.submitInterval !== undefined && (obj.submit_interval = message.submitInterval ? exports.SubmitInterval.toSDK(message.submitInterval) : undefined);
	        return obj;
	    }
	};
	function createBaseSubmitInterval() {
	    return {
	        start: helpers_1.Long.UZERO,
	        end: helpers_1.Long.UZERO
	    };
	}
	exports.SubmitInterval = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.start.isZero()) {
	            writer.uint32(8).uint64(message.start);
	        }
	        if (!message.end.isZero()) {
	            writer.uint32(16).uint64(message.end);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSubmitInterval();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.start = reader.uint64();
	                    break;
	                case 2:
	                    message.end = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            start: (0, helpers_1.isSet)(object.start) ? helpers_1.Long.fromValue(object.start) : helpers_1.Long.UZERO,
	            end: (0, helpers_1.isSet)(object.end) ? helpers_1.Long.fromValue(object.end) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.start !== undefined && (obj.start = (message.start || helpers_1.Long.UZERO).toString());
	        message.end !== undefined && (obj.end = (message.end || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSubmitInterval();
	        message.start = object.start !== undefined && object.start !== null ? helpers_1.Long.fromValue(object.start) : helpers_1.Long.UZERO;
	        message.end = object.end !== undefined && object.end !== null ? helpers_1.Long.fromValue(object.end) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            start: object?.start,
	            end: object?.end
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.start = message.start;
	        obj.end = message.end;
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Params = this.Params.bind(this);
	        this.LatestAttestedChallenges = this.LatestAttestedChallenges.bind(this);
	        this.InturnAttestationSubmitter = this.InturnAttestationSubmitter.bind(this);
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.challenge.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    LatestAttestedChallenges(request = {}) {
	        const data = exports.QueryLatestAttestedChallengesRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.challenge.Query", "LatestAttestedChallenges", data);
	        return promise.then(data => exports.QueryLatestAttestedChallengesResponse.decode(new _m0.Reader(data)));
	    }
	    InturnAttestationSubmitter(request = {}) {
	        const data = exports.QueryInturnAttestationSubmitterRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.challenge.Query", "InturnAttestationSubmitter", data);
	        return promise.then(data => exports.QueryInturnAttestationSubmitterResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$4));

query$4.default;

var tx$4 = {};

var types$1 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AttestedChallengeIds = exports.Challenge = exports.Slash = exports.voteResultToJSON = exports.voteResultFromJSON = exports.VoteResultSDKType = exports.VoteResult = exports.protobufPackage = void 0;
	/* eslint-disable */
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "greenfield.challenge";
	/** VoteResult defines the result attestation for a challenge. */
	var VoteResult;
	(function (VoteResult) {
	    /** CHALLENGE_FAILED - The challenge failed. */
	    VoteResult[VoteResult["CHALLENGE_FAILED"] = 0] = "CHALLENGE_FAILED";
	    /** CHALLENGE_SUCCEED - The challenge succeed. */
	    VoteResult[VoteResult["CHALLENGE_SUCCEED"] = 1] = "CHALLENGE_SUCCEED";
	    VoteResult[VoteResult["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(VoteResult = exports.VoteResult || (exports.VoteResult = {}));
	exports.VoteResultSDKType = VoteResult;
	function voteResultFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "CHALLENGE_FAILED":
	            return VoteResult.CHALLENGE_FAILED;
	        case 1:
	        case "CHALLENGE_SUCCEED":
	            return VoteResult.CHALLENGE_SUCCEED;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return VoteResult.UNRECOGNIZED;
	    }
	}
	exports.voteResultFromJSON = voteResultFromJSON;
	function voteResultToJSON(object) {
	    switch (object) {
	        case VoteResult.CHALLENGE_FAILED:
	            return "CHALLENGE_FAILED";
	        case VoteResult.CHALLENGE_SUCCEED:
	            return "CHALLENGE_SUCCEED";
	        case VoteResult.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.voteResultToJSON = voteResultToJSON;
	function createBaseSlash() {
	    return {
	        spOperatorAddress: new Uint8Array(),
	        objectId: "",
	        height: helpers_1.Long.UZERO
	    };
	}
	exports.Slash = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spOperatorAddress.length !== 0) {
	            writer.uint32(10).bytes(message.spOperatorAddress);
	        }
	        if (message.objectId !== "") {
	            writer.uint32(18).string(message.objectId);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(24).uint64(message.height);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSlash();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spOperatorAddress = reader.bytes();
	                    break;
	                case 2:
	                    message.objectId = reader.string();
	                    break;
	                case 3:
	                    message.height = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spOperatorAddress: (0, helpers_1.isSet)(object.spOperatorAddress) ? (0, helpers_1.bytesFromBase64)(object.spOperatorAddress) : new Uint8Array(),
	            objectId: (0, helpers_1.isSet)(object.objectId) ? String(object.objectId) : "",
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spOperatorAddress !== undefined && (obj.spOperatorAddress = (0, helpers_1.base64FromBytes)(message.spOperatorAddress !== undefined ? message.spOperatorAddress : new Uint8Array()));
	        message.objectId !== undefined && (obj.objectId = message.objectId);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSlash();
	        message.spOperatorAddress = object.spOperatorAddress ?? new Uint8Array();
	        message.objectId = object.objectId ?? "";
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spOperatorAddress: object?.sp_operator_address,
	            objectId: object?.object_id,
	            height: object?.height
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sp_operator_address = message.spOperatorAddress;
	        obj.object_id = message.objectId;
	        obj.height = message.height;
	        return obj;
	    }
	};
	function createBaseChallenge() {
	    return {
	        id: helpers_1.Long.UZERO,
	        expiredHeight: helpers_1.Long.UZERO
	    };
	}
	exports.Challenge = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.id.isZero()) {
	            writer.uint32(8).uint64(message.id);
	        }
	        if (!message.expiredHeight.isZero()) {
	            writer.uint32(16).uint64(message.expiredHeight);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseChallenge();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.id = reader.uint64();
	                    break;
	                case 2:
	                    message.expiredHeight = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            id: (0, helpers_1.isSet)(object.id) ? helpers_1.Long.fromValue(object.id) : helpers_1.Long.UZERO,
	            expiredHeight: (0, helpers_1.isSet)(object.expiredHeight) ? helpers_1.Long.fromValue(object.expiredHeight) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.id !== undefined && (obj.id = (message.id || helpers_1.Long.UZERO).toString());
	        message.expiredHeight !== undefined && (obj.expiredHeight = (message.expiredHeight || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseChallenge();
	        message.id = object.id !== undefined && object.id !== null ? helpers_1.Long.fromValue(object.id) : helpers_1.Long.UZERO;
	        message.expiredHeight = object.expiredHeight !== undefined && object.expiredHeight !== null ? helpers_1.Long.fromValue(object.expiredHeight) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            id: object?.id,
	            expiredHeight: object?.expired_height
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.id = message.id;
	        obj.expired_height = message.expiredHeight;
	        return obj;
	    }
	};
	function createBaseAttestedChallengeIds() {
	    return {
	        size: helpers_1.Long.UZERO,
	        ids: [],
	        cursor: helpers_1.Long.ZERO
	    };
	}
	exports.AttestedChallengeIds = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.size.isZero()) {
	            writer.uint32(8).uint64(message.size);
	        }
	        writer.uint32(18).fork();
	        for (const v of message.ids) {
	            writer.uint64(v);
	        }
	        writer.ldelim();
	        if (!message.cursor.isZero()) {
	            writer.uint32(24).int64(message.cursor);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseAttestedChallengeIds();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.size = reader.uint64();
	                    break;
	                case 2:
	                    if ((tag & 7) === 2) {
	                        const end2 = reader.uint32() + reader.pos;
	                        while (reader.pos < end2) {
	                            message.ids.push(reader.uint64());
	                        }
	                    }
	                    else {
	                        message.ids.push(reader.uint64());
	                    }
	                    break;
	                case 3:
	                    message.cursor = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            size: (0, helpers_1.isSet)(object.size) ? helpers_1.Long.fromValue(object.size) : helpers_1.Long.UZERO,
	            ids: Array.isArray(object?.ids) ? object.ids.map((e) => helpers_1.Long.fromValue(e)) : [],
	            cursor: (0, helpers_1.isSet)(object.cursor) ? helpers_1.Long.fromValue(object.cursor) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.size !== undefined && (obj.size = (message.size || helpers_1.Long.UZERO).toString());
	        if (message.ids) {
	            obj.ids = message.ids.map(e => (e || helpers_1.Long.UZERO).toString());
	        }
	        else {
	            obj.ids = [];
	        }
	        message.cursor !== undefined && (obj.cursor = (message.cursor || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseAttestedChallengeIds();
	        message.size = object.size !== undefined && object.size !== null ? helpers_1.Long.fromValue(object.size) : helpers_1.Long.UZERO;
	        message.ids = object.ids?.map(e => helpers_1.Long.fromValue(e)) || [];
	        message.cursor = object.cursor !== undefined && object.cursor !== null ? helpers_1.Long.fromValue(object.cursor) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            size: object?.size,
	            ids: Array.isArray(object?.ids) ? object.ids.map((e) => e) : [],
	            cursor: object?.cursor
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.size = message.size;
	        if (message.ids) {
	            obj.ids = message.ids.map(e => e);
	        }
	        else {
	            obj.ids = [];
	        }
	        obj.cursor = message.cursor;
	        return obj;
	    }
	};
	
} (types$1));

types$1.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgAttestResponse = exports.MsgAttest = exports.MsgSubmitResponse = exports.MsgSubmit = exports.protobufPackage = void 0;
	/* eslint-disable */
	const types_1 = types$1;
	const params_1 = params$2;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.challenge";
	function createBaseMsgSubmit() {
	    return {
	        challenger: "",
	        spOperatorAddress: "",
	        bucketName: "",
	        objectName: "",
	        segmentIndex: 0,
	        randomIndex: false
	    };
	}
	exports.MsgSubmit = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.challenger !== "") {
	            writer.uint32(10).string(message.challenger);
	        }
	        if (message.spOperatorAddress !== "") {
	            writer.uint32(18).string(message.spOperatorAddress);
	        }
	        if (message.bucketName !== "") {
	            writer.uint32(26).string(message.bucketName);
	        }
	        if (message.objectName !== "") {
	            writer.uint32(34).string(message.objectName);
	        }
	        if (message.segmentIndex !== 0) {
	            writer.uint32(40).uint32(message.segmentIndex);
	        }
	        if (message.randomIndex === true) {
	            writer.uint32(48).bool(message.randomIndex);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSubmit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.challenger = reader.string();
	                    break;
	                case 2:
	                    message.spOperatorAddress = reader.string();
	                    break;
	                case 3:
	                    message.bucketName = reader.string();
	                    break;
	                case 4:
	                    message.objectName = reader.string();
	                    break;
	                case 5:
	                    message.segmentIndex = reader.uint32();
	                    break;
	                case 6:
	                    message.randomIndex = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            challenger: (0, helpers_1.isSet)(object.challenger) ? String(object.challenger) : "",
	            spOperatorAddress: (0, helpers_1.isSet)(object.spOperatorAddress) ? String(object.spOperatorAddress) : "",
	            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
	            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
	            segmentIndex: (0, helpers_1.isSet)(object.segmentIndex) ? Number(object.segmentIndex) : 0,
	            randomIndex: (0, helpers_1.isSet)(object.randomIndex) ? Boolean(object.randomIndex) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.challenger !== undefined && (obj.challenger = message.challenger);
	        message.spOperatorAddress !== undefined && (obj.spOperatorAddress = message.spOperatorAddress);
	        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
	        message.objectName !== undefined && (obj.objectName = message.objectName);
	        message.segmentIndex !== undefined && (obj.segmentIndex = Math.round(message.segmentIndex));
	        message.randomIndex !== undefined && (obj.randomIndex = message.randomIndex);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgSubmit();
	        message.challenger = object.challenger ?? "";
	        message.spOperatorAddress = object.spOperatorAddress ?? "";
	        message.bucketName = object.bucketName ?? "";
	        message.objectName = object.objectName ?? "";
	        message.segmentIndex = object.segmentIndex ?? 0;
	        message.randomIndex = object.randomIndex ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            challenger: object?.challenger,
	            spOperatorAddress: object?.sp_operator_address,
	            bucketName: object?.bucket_name,
	            objectName: object?.object_name,
	            segmentIndex: object?.segment_index,
	            randomIndex: object?.random_index
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.challenger = message.challenger;
	        obj.sp_operator_address = message.spOperatorAddress;
	        obj.bucket_name = message.bucketName;
	        obj.object_name = message.objectName;
	        obj.segment_index = message.segmentIndex;
	        obj.random_index = message.randomIndex;
	        return obj;
	    }
	};
	function createBaseMsgSubmitResponse() {
	    return {};
	}
	exports.MsgSubmitResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSubmitResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgSubmitResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgAttest() {
	    return {
	        submitter: "",
	        challengeId: helpers_1.Long.UZERO,
	        objectId: "",
	        spOperatorAddress: "",
	        voteResult: 0,
	        challengerAddress: "",
	        voteValidatorSet: [],
	        voteAggSignature: new Uint8Array()
	    };
	}
	exports.MsgAttest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.submitter !== "") {
	            writer.uint32(10).string(message.submitter);
	        }
	        if (!message.challengeId.isZero()) {
	            writer.uint32(16).uint64(message.challengeId);
	        }
	        if (message.objectId !== "") {
	            writer.uint32(26).string(message.objectId);
	        }
	        if (message.spOperatorAddress !== "") {
	            writer.uint32(34).string(message.spOperatorAddress);
	        }
	        if (message.voteResult !== 0) {
	            writer.uint32(40).int32(message.voteResult);
	        }
	        if (message.challengerAddress !== "") {
	            writer.uint32(50).string(message.challengerAddress);
	        }
	        writer.uint32(58).fork();
	        for (const v of message.voteValidatorSet) {
	            writer.fixed64(v);
	        }
	        writer.ldelim();
	        if (message.voteAggSignature.length !== 0) {
	            writer.uint32(66).bytes(message.voteAggSignature);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgAttest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.submitter = reader.string();
	                    break;
	                case 2:
	                    message.challengeId = reader.uint64();
	                    break;
	                case 3:
	                    message.objectId = reader.string();
	                    break;
	                case 4:
	                    message.spOperatorAddress = reader.string();
	                    break;
	                case 5:
	                    message.voteResult = reader.int32();
	                    break;
	                case 6:
	                    message.challengerAddress = reader.string();
	                    break;
	                case 7:
	                    if ((tag & 7) === 2) {
	                        const end2 = reader.uint32() + reader.pos;
	                        while (reader.pos < end2) {
	                            message.voteValidatorSet.push(reader.fixed64());
	                        }
	                    }
	                    else {
	                        message.voteValidatorSet.push(reader.fixed64());
	                    }
	                    break;
	                case 8:
	                    message.voteAggSignature = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            submitter: (0, helpers_1.isSet)(object.submitter) ? String(object.submitter) : "",
	            challengeId: (0, helpers_1.isSet)(object.challengeId) ? helpers_1.Long.fromValue(object.challengeId) : helpers_1.Long.UZERO,
	            objectId: (0, helpers_1.isSet)(object.objectId) ? String(object.objectId) : "",
	            spOperatorAddress: (0, helpers_1.isSet)(object.spOperatorAddress) ? String(object.spOperatorAddress) : "",
	            voteResult: (0, helpers_1.isSet)(object.voteResult) ? (0, types_1.voteResultFromJSON)(object.voteResult) : 0,
	            challengerAddress: (0, helpers_1.isSet)(object.challengerAddress) ? String(object.challengerAddress) : "",
	            voteValidatorSet: Array.isArray(object?.voteValidatorSet) ? object.voteValidatorSet.map((e) => helpers_1.Long.fromValue(e)) : [],
	            voteAggSignature: (0, helpers_1.isSet)(object.voteAggSignature) ? (0, helpers_1.bytesFromBase64)(object.voteAggSignature) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.submitter !== undefined && (obj.submitter = message.submitter);
	        message.challengeId !== undefined && (obj.challengeId = (message.challengeId || helpers_1.Long.UZERO).toString());
	        message.objectId !== undefined && (obj.objectId = message.objectId);
	        message.spOperatorAddress !== undefined && (obj.spOperatorAddress = message.spOperatorAddress);
	        message.voteResult !== undefined && (obj.voteResult = (0, types_1.voteResultToJSON)(message.voteResult));
	        message.challengerAddress !== undefined && (obj.challengerAddress = message.challengerAddress);
	        if (message.voteValidatorSet) {
	            obj.voteValidatorSet = message.voteValidatorSet.map(e => (e || helpers_1.Long.ZERO).toString());
	        }
	        else {
	            obj.voteValidatorSet = [];
	        }
	        message.voteAggSignature !== undefined && (obj.voteAggSignature = (0, helpers_1.base64FromBytes)(message.voteAggSignature !== undefined ? message.voteAggSignature : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgAttest();
	        message.submitter = object.submitter ?? "";
	        message.challengeId = object.challengeId !== undefined && object.challengeId !== null ? helpers_1.Long.fromValue(object.challengeId) : helpers_1.Long.UZERO;
	        message.objectId = object.objectId ?? "";
	        message.spOperatorAddress = object.spOperatorAddress ?? "";
	        message.voteResult = object.voteResult ?? 0;
	        message.challengerAddress = object.challengerAddress ?? "";
	        message.voteValidatorSet = object.voteValidatorSet?.map(e => helpers_1.Long.fromValue(e)) || [];
	        message.voteAggSignature = object.voteAggSignature ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            submitter: object?.submitter,
	            challengeId: object?.challenge_id,
	            objectId: object?.object_id,
	            spOperatorAddress: object?.sp_operator_address,
	            voteResult: (0, helpers_1.isSet)(object.vote_result) ? (0, types_1.voteResultFromJSON)(object.vote_result) : 0,
	            challengerAddress: object?.challenger_address,
	            voteValidatorSet: Array.isArray(object?.vote_validator_set) ? object.vote_validator_set.map((e) => e) : [],
	            voteAggSignature: object?.vote_agg_signature
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.submitter = message.submitter;
	        obj.challenge_id = message.challengeId;
	        obj.object_id = message.objectId;
	        obj.sp_operator_address = message.spOperatorAddress;
	        message.voteResult !== undefined && (obj.vote_result = (0, types_1.voteResultToJSON)(message.voteResult));
	        obj.challenger_address = message.challengerAddress;
	        if (message.voteValidatorSet) {
	            obj.vote_validator_set = message.voteValidatorSet.map(e => e);
	        }
	        else {
	            obj.vote_validator_set = [];
	        }
	        obj.vote_agg_signature = message.voteAggSignature;
	        return obj;
	    }
	};
	function createBaseMsgAttestResponse() {
	    return {};
	}
	exports.MsgAttestResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgAttestResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgAttestResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Submit = this.Submit.bind(this);
	        this.Attest = this.Attest.bind(this);
	        this.UpdateParams = this.UpdateParams.bind(this);
	    }
	    Submit(request) {
	        const data = exports.MsgSubmit.encode(request).finish();
	        const promise = this.rpc.request("greenfield.challenge.Msg", "Submit", data);
	        return promise.then(data => exports.MsgSubmitResponse.decode(new _m0.Reader(data)));
	    }
	    Attest(request) {
	        const data = exports.MsgAttest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.challenge.Msg", "Attest", data);
	        return promise.then(data => exports.MsgAttestResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("greenfield.challenge.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx$4));

tx$4.default;

class Challenge extends Account {
    submitChallenge(address, msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.challenge.MsgSubmit';
            const msgBytes = tx$4.MsgSubmit.encode(msg).finish();
            const accountInfo = yield this.getAccount(address);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgSubmitSDKTypeEIP712, tx$4.MsgSubmit.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    attestChallenge(address, msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.challenge.MsgAttest';
            const msgBytes = tx$4.MsgAttest.encode(msg).finish();
            const accountInfo = yield this.getAccount(address);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgAttestSDKTypeEIP712, tx$4.MsgAttest.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    latestAttestedChallenges() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$4.QueryClientImpl(rpcClient);
            return yield rpc.LatestAttestedChallenges();
        });
    }
    inturnAttestationSubmitter() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$4.QueryClientImpl(rpcClient);
            return yield rpc.InturnAttestationSubmitter();
        });
    }
}

var query$3 = {};

var params$1 = {};

var __createBinding$3 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$3 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$3 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
    __setModuleDefault$3(result, mod);
    return result;
};
Object.defineProperty(params$1, "__esModule", { value: true });
params$1.Params = params$1.protobufPackage = void 0;
/* eslint-disable */
const _m0$3 = __importStar$3(minimal$1.exports);
const helpers_1$3 = helpers;
params$1.protobufPackage = "greenfield.bridge";
function createBaseParams$3() {
    return {
        transferOutRelayerFee: "",
        transferOutAckRelayerFee: ""
    };
}
params$1.Params = {
    encode(message, writer = _m0$3.Writer.create()) {
        if (message.transferOutRelayerFee !== "") {
            writer.uint32(10).string(message.transferOutRelayerFee);
        }
        if (message.transferOutAckRelayerFee !== "") {
            writer.uint32(18).string(message.transferOutAckRelayerFee);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$3.Reader ? input : new _m0$3.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$3();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transferOutRelayerFee = reader.string();
                    break;
                case 2:
                    message.transferOutAckRelayerFee = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferOutRelayerFee: (0, helpers_1$3.isSet)(object.transferOutRelayerFee) ? String(object.transferOutRelayerFee) : "",
            transferOutAckRelayerFee: (0, helpers_1$3.isSet)(object.transferOutAckRelayerFee) ? String(object.transferOutAckRelayerFee) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.transferOutRelayerFee !== undefined && (obj.transferOutRelayerFee = message.transferOutRelayerFee);
        message.transferOutAckRelayerFee !== undefined && (obj.transferOutAckRelayerFee = message.transferOutAckRelayerFee);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseParams$3();
        message.transferOutRelayerFee = object.transferOutRelayerFee ?? "";
        message.transferOutAckRelayerFee = object.transferOutAckRelayerFee ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            transferOutRelayerFee: object?.transfer_out_relayer_fee,
            transferOutAckRelayerFee: object?.transfer_out_ack_relayer_fee
        };
    },
    toSDK(message) {
        const obj = {};
        obj.transfer_out_relayer_fee = message.transferOutRelayerFee;
        obj.transfer_out_ack_relayer_fee = message.transferOutAckRelayerFee;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const params_1 = params$1;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.bridge";
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Params = this.Params.bind(this);
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.bridge.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$3));

query$3.default;

const MsgTransferOutSDKTypeEIP712$1 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'from',
            type: 'string',
        },
        {
            name: 'to',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'TypeAmount',
        },
    ],
};

var query$2 = {};

var crosschain = {};

var __createBinding$2 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$2 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$2 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
    __setModuleDefault$2(result, mod);
    return result;
};
Object.defineProperty(crosschain, "__esModule", { value: true });
crosschain.Params = crosschain.protobufPackage = void 0;
/* eslint-disable */
const _m0$2 = __importStar$2(minimal$1.exports);
const helpers_1$2 = helpers;
crosschain.protobufPackage = "cosmos.crosschain.v1";
function createBaseParams$2() {
    return {
        initModuleBalance: ""
    };
}
crosschain.Params = {
    encode(message, writer = _m0$2.Writer.create()) {
        if (message.initModuleBalance !== "") {
            writer.uint32(10).string(message.initModuleBalance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$2.Reader ? input : new _m0$2.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.initModuleBalance = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            initModuleBalance: (0, helpers_1$2.isSet)(object.initModuleBalance) ? String(object.initModuleBalance) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.initModuleBalance !== undefined && (obj.initModuleBalance = message.initModuleBalance);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseParams$2();
        message.initModuleBalance = object.initModuleBalance ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            initModuleBalance: object?.init_module_balance
        };
    },
    toSDK(message) {
        const obj = {};
        obj.init_module_balance = message.initModuleBalance;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QueryReceiveSequenceResponse = exports.QueryReceiveSequenceRequest = exports.QuerySendSequenceResponse = exports.QuerySendSequenceRequest = exports.QueryCrossChainPackageResponse = exports.QueryCrossChainPackageRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const crosschain_1 = crosschain;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.crosschain.v1";
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            crosschain_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = crosschain_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? crosschain_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? crosschain_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? crosschain_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? crosschain_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? crosschain_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryCrossChainPackageRequest() {
	    return {
	        channelId: 0,
	        sequence: helpers_1.Long.UZERO
	    };
	}
	exports.QueryCrossChainPackageRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.channelId !== 0) {
	            writer.uint32(8).uint32(message.channelId);
	        }
	        if (!message.sequence.isZero()) {
	            writer.uint32(16).uint64(message.sequence);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryCrossChainPackageRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.channelId = reader.uint32();
	                    break;
	                case 2:
	                    message.sequence = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            channelId: (0, helpers_1.isSet)(object.channelId) ? Number(object.channelId) : 0,
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.channelId !== undefined && (obj.channelId = Math.round(message.channelId));
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryCrossChainPackageRequest();
	        message.channelId = object.channelId ?? 0;
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            channelId: object?.channel_id,
	            sequence: object?.sequence
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.channel_id = message.channelId;
	        obj.sequence = message.sequence;
	        return obj;
	    }
	};
	function createBaseQueryCrossChainPackageResponse() {
	    return {
	        package: new Uint8Array()
	    };
	}
	exports.QueryCrossChainPackageResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.package.length !== 0) {
	            writer.uint32(10).bytes(message.package);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryCrossChainPackageResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.package = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            package: (0, helpers_1.isSet)(object.package) ? (0, helpers_1.bytesFromBase64)(object.package) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.package !== undefined && (obj.package = (0, helpers_1.base64FromBytes)(message.package !== undefined ? message.package : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryCrossChainPackageResponse();
	        message.package = object.package ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            package: object?.package
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.package = message.package;
	        return obj;
	    }
	};
	function createBaseQuerySendSequenceRequest() {
	    return {
	        channelId: 0
	    };
	}
	exports.QuerySendSequenceRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.channelId !== 0) {
	            writer.uint32(8).uint32(message.channelId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySendSequenceRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.channelId = reader.uint32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            channelId: (0, helpers_1.isSet)(object.channelId) ? Number(object.channelId) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.channelId !== undefined && (obj.channelId = Math.round(message.channelId));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySendSequenceRequest();
	        message.channelId = object.channelId ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            channelId: object?.channel_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.channel_id = message.channelId;
	        return obj;
	    }
	};
	function createBaseQuerySendSequenceResponse() {
	    return {
	        sequence: helpers_1.Long.UZERO
	    };
	}
	exports.QuerySendSequenceResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.sequence.isZero()) {
	            writer.uint32(8).uint64(message.sequence);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQuerySendSequenceResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.sequence = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQuerySendSequenceResponse();
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            sequence: object?.sequence
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sequence = message.sequence;
	        return obj;
	    }
	};
	function createBaseQueryReceiveSequenceRequest() {
	    return {
	        channelId: 0
	    };
	}
	exports.QueryReceiveSequenceRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.channelId !== 0) {
	            writer.uint32(8).uint32(message.channelId);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryReceiveSequenceRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.channelId = reader.uint32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            channelId: (0, helpers_1.isSet)(object.channelId) ? Number(object.channelId) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.channelId !== undefined && (obj.channelId = Math.round(message.channelId));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryReceiveSequenceRequest();
	        message.channelId = object.channelId ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            channelId: object?.channel_id
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.channel_id = message.channelId;
	        return obj;
	    }
	};
	function createBaseQueryReceiveSequenceResponse() {
	    return {
	        sequence: helpers_1.Long.UZERO
	    };
	}
	exports.QueryReceiveSequenceResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.sequence.isZero()) {
	            writer.uint32(8).uint64(message.sequence);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryReceiveSequenceResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.sequence = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryReceiveSequenceResponse();
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            sequence: object?.sequence
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sequence = message.sequence;
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Params = this.Params.bind(this);
	        this.CrossChainPackage = this.CrossChainPackage.bind(this);
	        this.SendSequence = this.SendSequence.bind(this);
	        this.ReceiveSequence = this.ReceiveSequence.bind(this);
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.crosschain.v1.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    CrossChainPackage(request) {
	        const data = exports.QueryCrossChainPackageRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.crosschain.v1.Query", "CrossChainPackage", data);
	        return promise.then(data => exports.QueryCrossChainPackageResponse.decode(new _m0.Reader(data)));
	    }
	    SendSequence(request) {
	        const data = exports.QuerySendSequenceRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.crosschain.v1.Query", "SendSequence", data);
	        return promise.then(data => exports.QuerySendSequenceResponse.decode(new _m0.Reader(data)));
	    }
	    ReceiveSequence(request) {
	        const data = exports.QueryReceiveSequenceRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.crosschain.v1.Query", "ReceiveSequence", data);
	        return promise.then(data => exports.QueryReceiveSequenceResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$2));

query$2.default;

var query$1 = {};

var oracle = {};

var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(oracle, "__esModule", { value: true });
oracle.RelayInterval = oracle.Params = oracle.protobufPackage = void 0;
/* eslint-disable */
const helpers_1$1 = helpers;
const _m0$1 = __importStar$1(minimal$1.exports);
oracle.protobufPackage = "cosmos.oracle.v1";
function createBaseParams$1() {
    return {
        relayerTimeout: helpers_1$1.Long.UZERO,
        relayerInterval: helpers_1$1.Long.UZERO,
        relayerRewardShare: 0
    };
}
oracle.Params = {
    encode(message, writer = _m0$1.Writer.create()) {
        if (!message.relayerTimeout.isZero()) {
            writer.uint32(8).uint64(message.relayerTimeout);
        }
        if (!message.relayerInterval.isZero()) {
            writer.uint32(16).uint64(message.relayerInterval);
        }
        if (message.relayerRewardShare !== 0) {
            writer.uint32(24).uint32(message.relayerRewardShare);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$1.Reader ? input : new _m0$1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.relayerTimeout = reader.uint64();
                    break;
                case 2:
                    message.relayerInterval = reader.uint64();
                    break;
                case 3:
                    message.relayerRewardShare = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            relayerTimeout: (0, helpers_1$1.isSet)(object.relayerTimeout) ? helpers_1$1.Long.fromValue(object.relayerTimeout) : helpers_1$1.Long.UZERO,
            relayerInterval: (0, helpers_1$1.isSet)(object.relayerInterval) ? helpers_1$1.Long.fromValue(object.relayerInterval) : helpers_1$1.Long.UZERO,
            relayerRewardShare: (0, helpers_1$1.isSet)(object.relayerRewardShare) ? Number(object.relayerRewardShare) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.relayerTimeout !== undefined && (obj.relayerTimeout = (message.relayerTimeout || helpers_1$1.Long.UZERO).toString());
        message.relayerInterval !== undefined && (obj.relayerInterval = (message.relayerInterval || helpers_1$1.Long.UZERO).toString());
        message.relayerRewardShare !== undefined && (obj.relayerRewardShare = Math.round(message.relayerRewardShare));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseParams$1();
        message.relayerTimeout = object.relayerTimeout !== undefined && object.relayerTimeout !== null ? helpers_1$1.Long.fromValue(object.relayerTimeout) : helpers_1$1.Long.UZERO;
        message.relayerInterval = object.relayerInterval !== undefined && object.relayerInterval !== null ? helpers_1$1.Long.fromValue(object.relayerInterval) : helpers_1$1.Long.UZERO;
        message.relayerRewardShare = object.relayerRewardShare ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            relayerTimeout: object?.relayer_timeout,
            relayerInterval: object?.relayer_interval,
            relayerRewardShare: object?.relayer_reward_share
        };
    },
    toSDK(message) {
        const obj = {};
        obj.relayer_timeout = message.relayerTimeout;
        obj.relayer_interval = message.relayerInterval;
        obj.relayer_reward_share = message.relayerRewardShare;
        return obj;
    }
};
function createBaseRelayInterval() {
    return {
        start: helpers_1$1.Long.UZERO,
        end: helpers_1$1.Long.UZERO
    };
}
oracle.RelayInterval = {
    encode(message, writer = _m0$1.Writer.create()) {
        if (!message.start.isZero()) {
            writer.uint32(8).uint64(message.start);
        }
        if (!message.end.isZero()) {
            writer.uint32(16).uint64(message.end);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0$1.Reader ? input : new _m0$1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRelayInterval();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.start = reader.uint64();
                    break;
                case 2:
                    message.end = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: (0, helpers_1$1.isSet)(object.start) ? helpers_1$1.Long.fromValue(object.start) : helpers_1$1.Long.UZERO,
            end: (0, helpers_1$1.isSet)(object.end) ? helpers_1$1.Long.fromValue(object.end) : helpers_1$1.Long.UZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.start !== undefined && (obj.start = (message.start || helpers_1$1.Long.UZERO).toString());
        message.end !== undefined && (obj.end = (message.end || helpers_1$1.Long.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRelayInterval();
        message.start = object.start !== undefined && object.start !== null ? helpers_1$1.Long.fromValue(object.start) : helpers_1$1.Long.UZERO;
        message.end = object.end !== undefined && object.end !== null ? helpers_1$1.Long.fromValue(object.end) : helpers_1$1.Long.UZERO;
        return message;
    },
    fromSDK(object) {
        return {
            start: object?.start,
            end: object?.end
        };
    },
    toSDK(message) {
        const obj = {};
        obj.start = message.start;
        obj.end = message.end;
        return obj;
    }
};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QueryInturnRelayerResponse = exports.QueryInturnRelayerRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const oracle_1 = oracle;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.oracle.v1";
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            oracle_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = oracle_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? oracle_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? oracle_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? oracle_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? oracle_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? oracle_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryInturnRelayerRequest() {
	    return {};
	}
	exports.QueryInturnRelayerRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryInturnRelayerRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryInturnRelayerRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryInturnRelayerResponse() {
	    return {
	        blsPubKey: "",
	        relayInterval: undefined
	    };
	}
	exports.QueryInturnRelayerResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.blsPubKey !== "") {
	            writer.uint32(10).string(message.blsPubKey);
	        }
	        if (message.relayInterval !== undefined) {
	            oracle_1.RelayInterval.encode(message.relayInterval, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryInturnRelayerResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.blsPubKey = reader.string();
	                    break;
	                case 2:
	                    message.relayInterval = oracle_1.RelayInterval.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            blsPubKey: (0, helpers_1.isSet)(object.blsPubKey) ? String(object.blsPubKey) : "",
	            relayInterval: (0, helpers_1.isSet)(object.relayInterval) ? oracle_1.RelayInterval.fromJSON(object.relayInterval) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.blsPubKey !== undefined && (obj.blsPubKey = message.blsPubKey);
	        message.relayInterval !== undefined && (obj.relayInterval = message.relayInterval ? oracle_1.RelayInterval.toJSON(message.relayInterval) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryInturnRelayerResponse();
	        message.blsPubKey = object.blsPubKey ?? "";
	        message.relayInterval = object.relayInterval !== undefined && object.relayInterval !== null ? oracle_1.RelayInterval.fromPartial(object.relayInterval) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            blsPubKey: object?.bls_pub_key,
	            relayInterval: object.relay_interval ? oracle_1.RelayInterval.fromSDK(object.relay_interval) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.bls_pub_key = message.blsPubKey;
	        message.relayInterval !== undefined && (obj.relay_interval = message.relayInterval ? oracle_1.RelayInterval.toSDK(message.relayInterval) : undefined);
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Params = this.Params.bind(this);
	        this.InturnRelayer = this.InturnRelayer.bind(this);
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.oracle.v1.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    InturnRelayer(request = {}) {
	        const data = exports.QueryInturnRelayerRequest.encode(request).finish();
	        const promise = this.rpc.request("cosmos.oracle.v1.Query", "InturnRelayer", data);
	        return promise.then(data => exports.QueryInturnRelayerResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query$1));

query$1.default;

var tx$3 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgClaimResponse = exports.MsgClaim = exports.protobufPackage = void 0;
	/* eslint-disable */
	const oracle_1 = oracle;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "cosmos.oracle.v1";
	function createBaseMsgClaim() {
	    return {
	        fromAddress: "",
	        srcChainId: 0,
	        destChainId: 0,
	        sequence: helpers_1.Long.UZERO,
	        timestamp: helpers_1.Long.UZERO,
	        payload: new Uint8Array(),
	        voteAddressSet: [],
	        aggSignature: new Uint8Array()
	    };
	}
	exports.MsgClaim = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.fromAddress !== "") {
	            writer.uint32(10).string(message.fromAddress);
	        }
	        if (message.srcChainId !== 0) {
	            writer.uint32(16).uint32(message.srcChainId);
	        }
	        if (message.destChainId !== 0) {
	            writer.uint32(24).uint32(message.destChainId);
	        }
	        if (!message.sequence.isZero()) {
	            writer.uint32(32).uint64(message.sequence);
	        }
	        if (!message.timestamp.isZero()) {
	            writer.uint32(40).uint64(message.timestamp);
	        }
	        if (message.payload.length !== 0) {
	            writer.uint32(50).bytes(message.payload);
	        }
	        writer.uint32(58).fork();
	        for (const v of message.voteAddressSet) {
	            writer.fixed64(v);
	        }
	        writer.ldelim();
	        if (message.aggSignature.length !== 0) {
	            writer.uint32(66).bytes(message.aggSignature);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgClaim();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.fromAddress = reader.string();
	                    break;
	                case 2:
	                    message.srcChainId = reader.uint32();
	                    break;
	                case 3:
	                    message.destChainId = reader.uint32();
	                    break;
	                case 4:
	                    message.sequence = reader.uint64();
	                    break;
	                case 5:
	                    message.timestamp = reader.uint64();
	                    break;
	                case 6:
	                    message.payload = reader.bytes();
	                    break;
	                case 7:
	                    if ((tag & 7) === 2) {
	                        const end2 = reader.uint32() + reader.pos;
	                        while (reader.pos < end2) {
	                            message.voteAddressSet.push(reader.fixed64());
	                        }
	                    }
	                    else {
	                        message.voteAddressSet.push(reader.fixed64());
	                    }
	                    break;
	                case 8:
	                    message.aggSignature = reader.bytes();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            fromAddress: (0, helpers_1.isSet)(object.fromAddress) ? String(object.fromAddress) : "",
	            srcChainId: (0, helpers_1.isSet)(object.srcChainId) ? Number(object.srcChainId) : 0,
	            destChainId: (0, helpers_1.isSet)(object.destChainId) ? Number(object.destChainId) : 0,
	            sequence: (0, helpers_1.isSet)(object.sequence) ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO,
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? helpers_1.Long.fromValue(object.timestamp) : helpers_1.Long.UZERO,
	            payload: (0, helpers_1.isSet)(object.payload) ? (0, helpers_1.bytesFromBase64)(object.payload) : new Uint8Array(),
	            voteAddressSet: Array.isArray(object?.voteAddressSet) ? object.voteAddressSet.map((e) => helpers_1.Long.fromValue(e)) : [],
	            aggSignature: (0, helpers_1.isSet)(object.aggSignature) ? (0, helpers_1.bytesFromBase64)(object.aggSignature) : new Uint8Array()
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);
	        message.srcChainId !== undefined && (obj.srcChainId = Math.round(message.srcChainId));
	        message.destChainId !== undefined && (obj.destChainId = Math.round(message.destChainId));
	        message.sequence !== undefined && (obj.sequence = (message.sequence || helpers_1.Long.UZERO).toString());
	        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || helpers_1.Long.UZERO).toString());
	        message.payload !== undefined && (obj.payload = (0, helpers_1.base64FromBytes)(message.payload !== undefined ? message.payload : new Uint8Array()));
	        if (message.voteAddressSet) {
	            obj.voteAddressSet = message.voteAddressSet.map(e => (e || helpers_1.Long.ZERO).toString());
	        }
	        else {
	            obj.voteAddressSet = [];
	        }
	        message.aggSignature !== undefined && (obj.aggSignature = (0, helpers_1.base64FromBytes)(message.aggSignature !== undefined ? message.aggSignature : new Uint8Array()));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgClaim();
	        message.fromAddress = object.fromAddress ?? "";
	        message.srcChainId = object.srcChainId ?? 0;
	        message.destChainId = object.destChainId ?? 0;
	        message.sequence = object.sequence !== undefined && object.sequence !== null ? helpers_1.Long.fromValue(object.sequence) : helpers_1.Long.UZERO;
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? helpers_1.Long.fromValue(object.timestamp) : helpers_1.Long.UZERO;
	        message.payload = object.payload ?? new Uint8Array();
	        message.voteAddressSet = object.voteAddressSet?.map(e => helpers_1.Long.fromValue(e)) || [];
	        message.aggSignature = object.aggSignature ?? new Uint8Array();
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            fromAddress: object?.from_address,
	            srcChainId: object?.src_chain_id,
	            destChainId: object?.dest_chain_id,
	            sequence: object?.sequence,
	            timestamp: object?.timestamp,
	            payload: object?.payload,
	            voteAddressSet: Array.isArray(object?.vote_address_set) ? object.vote_address_set.map((e) => e) : [],
	            aggSignature: object?.agg_signature
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.from_address = message.fromAddress;
	        obj.src_chain_id = message.srcChainId;
	        obj.dest_chain_id = message.destChainId;
	        obj.sequence = message.sequence;
	        obj.timestamp = message.timestamp;
	        obj.payload = message.payload;
	        if (message.voteAddressSet) {
	            obj.vote_address_set = message.voteAddressSet.map(e => e);
	        }
	        else {
	            obj.vote_address_set = [];
	        }
	        obj.agg_signature = message.aggSignature;
	        return obj;
	    }
	};
	function createBaseMsgClaimResponse() {
	    return {};
	}
	exports.MsgClaimResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgClaimResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgClaimResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            oracle_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = oracle_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? oracle_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? oracle_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? oracle_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? oracle_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? oracle_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Claim = this.Claim.bind(this);
	        this.UpdateParams = this.UpdateParams.bind(this);
	    }
	    Claim(request) {
	        const data = exports.MsgClaim.encode(request).finish();
	        const promise = this.rpc.request("cosmos.oracle.v1.Msg", "Claim", data);
	        return promise.then(data => exports.MsgClaimResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("cosmos.oracle.v1.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx$3));

tx$3.default;

const MsgClaimSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from_address"
    },
    {
      "type": "uint64",
      "name": "src_chain_id"
    },
    {
      "type": "uint64",
      "name": "dest_chain_id"
    },
    {
      "type": "uint64",
      "name": "sequence"
    },
    {
      "type": "uint64",
      "name": "timestamp"
    },
    {
      "type": "bytes",
      "name": "payload"
    },
    {
      "type": "uint64[]",
      "name": "vote_address_set"
    },
    {
      "type": "bytes",
      "name": "agg_signature"
    }
  ]
};

const MsgMirrorBucketSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgMirrorGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgMirrorObjectSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

var tx$2 = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgTransferOutResponse = exports.MsgTransferOut = exports.protobufPackage = void 0;
	/* eslint-disable */
	const coin_1 = coin;
	const params_1 = params$1;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.bridge";
	function createBaseMsgTransferOut() {
	    return {
	        from: "",
	        to: "",
	        amount: undefined
	    };
	}
	exports.MsgTransferOut = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.from !== "") {
	            writer.uint32(10).string(message.from);
	        }
	        if (message.to !== "") {
	            writer.uint32(18).string(message.to);
	        }
	        if (message.amount !== undefined) {
	            coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgTransferOut();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.from = reader.string();
	                    break;
	                case 2:
	                    message.to = reader.string();
	                    break;
	                case 3:
	                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            from: (0, helpers_1.isSet)(object.from) ? String(object.from) : "",
	            to: (0, helpers_1.isSet)(object.to) ? String(object.to) : "",
	            amount: (0, helpers_1.isSet)(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.from !== undefined && (obj.from = message.from);
	        message.to !== undefined && (obj.to = message.to);
	        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgTransferOut();
	        message.from = object.from ?? "";
	        message.to = object.to ?? "";
	        message.amount = object.amount !== undefined && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            from: object?.from,
	            to: object?.to,
	            amount: object.amount ? coin_1.Coin.fromSDK(object.amount) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.from = message.from;
	        obj.to = message.to;
	        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toSDK(message.amount) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgTransferOutResponse() {
	    return {};
	}
	exports.MsgTransferOutResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgTransferOutResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgTransferOutResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.TransferOut = this.TransferOut.bind(this);
	        this.UpdateParams = this.UpdateParams.bind(this);
	    }
	    TransferOut(request) {
	        const data = exports.MsgTransferOut.encode(request).finish();
	        const promise = this.rpc.request("greenfield.bridge.Msg", "TransferOut", data);
	        return promise.then(data => exports.MsgTransferOutResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("greenfield.bridge.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx$2));

tx$2.default;

class CrossChain extends Account {
    transferOut(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.bridge.MsgTransferOut';
            const msgBytes = tx$2.MsgTransferOut.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.from);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgTransferOutSDKTypeEIP712$1, tx$2.MsgTransferOut.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    claims(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/cosmos.oracle.v1.MsgClaim';
            const msgBytes = tx$3.MsgClaim.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.fromAddress);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgClaimSDKTypeEIP712, tx$3.MsgClaim.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    getChannelSendSequence(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$2.QueryClientImpl(rpcClient);
            return yield rpc.SendSequence({
                channelId,
            });
        });
    }
    getChannelReceiveSequence(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$2.QueryClientImpl(rpcClient);
            return yield rpc.ReceiveSequence({
                channelId,
            });
        });
    }
    getInturnRelayer() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$1.QueryClientImpl(rpcClient);
            return yield rpc.InturnRelayer();
        });
    }
    getCrosschainPackage(channelId, sequence) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$2.QueryClientImpl(rpcClient);
            return yield rpc.CrossChainPackage({
                channelId,
                sequence: Long__default["default"].fromNumber(sequence),
            });
        });
    }
    mirrorGroup(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgMirrorGroup';
            const msgBytes = tx$5.MsgMirrorGroup.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgMirrorGroupSDKTypeEIP712, tx$5.MsgMirrorGroup.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    mirrorBucket(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgMirrorBucket';
            const msgBytes = tx$5.MsgMirrorBucket.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgMirrorBucketSDKTypeEIP712, tx$5.MsgMirrorBucket.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    mirrorObject(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgMirrorObject';
            const msgBytes = tx$5.MsgMirrorObject.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgMirrorObjectSDKTypeEIP712, tx$5.MsgMirrorObject.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    getParams() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$3.QueryClientImpl(rpcClient);
            return rpc.Params();
        });
    }
}

var tx$1 = {};

var distribution = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CommunityPoolSpendProposalWithDeposit = exports.DelegationDelegatorReward = exports.DelegatorStartingInfo = exports.CommunityPoolSpendProposal = exports.FeePool = exports.ValidatorSlashEvents = exports.ValidatorSlashEvent = exports.ValidatorOutstandingRewards = exports.ValidatorAccumulatedCommission = exports.ValidatorCurrentRewards = exports.ValidatorHistoricalRewards = exports.Params = exports.protobufPackage = void 0;
	/* eslint-disable */
	const coin_1 = coin;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.distribution.v1beta1";
	function createBaseParams() {
	    return {
	        communityTax: "",
	        baseProposerReward: "",
	        bonusProposerReward: "",
	        withdrawAddrEnabled: false
	    };
	}
	exports.Params = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.communityTax !== "") {
	            writer.uint32(10).string(message.communityTax);
	        }
	        if (message.baseProposerReward !== "") {
	            writer.uint32(18).string(message.baseProposerReward);
	        }
	        if (message.bonusProposerReward !== "") {
	            writer.uint32(26).string(message.bonusProposerReward);
	        }
	        if (message.withdrawAddrEnabled === true) {
	            writer.uint32(32).bool(message.withdrawAddrEnabled);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.communityTax = reader.string();
	                    break;
	                case 2:
	                    message.baseProposerReward = reader.string();
	                    break;
	                case 3:
	                    message.bonusProposerReward = reader.string();
	                    break;
	                case 4:
	                    message.withdrawAddrEnabled = reader.bool();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            communityTax: (0, helpers_1.isSet)(object.communityTax) ? String(object.communityTax) : "",
	            baseProposerReward: (0, helpers_1.isSet)(object.baseProposerReward) ? String(object.baseProposerReward) : "",
	            bonusProposerReward: (0, helpers_1.isSet)(object.bonusProposerReward) ? String(object.bonusProposerReward) : "",
	            withdrawAddrEnabled: (0, helpers_1.isSet)(object.withdrawAddrEnabled) ? Boolean(object.withdrawAddrEnabled) : false
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.communityTax !== undefined && (obj.communityTax = message.communityTax);
	        message.baseProposerReward !== undefined && (obj.baseProposerReward = message.baseProposerReward);
	        message.bonusProposerReward !== undefined && (obj.bonusProposerReward = message.bonusProposerReward);
	        message.withdrawAddrEnabled !== undefined && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseParams();
	        message.communityTax = object.communityTax ?? "";
	        message.baseProposerReward = object.baseProposerReward ?? "";
	        message.bonusProposerReward = object.bonusProposerReward ?? "";
	        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            communityTax: object?.community_tax,
	            baseProposerReward: object?.base_proposer_reward,
	            bonusProposerReward: object?.bonus_proposer_reward,
	            withdrawAddrEnabled: object?.withdraw_addr_enabled
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.community_tax = message.communityTax;
	        obj.base_proposer_reward = message.baseProposerReward;
	        obj.bonus_proposer_reward = message.bonusProposerReward;
	        obj.withdraw_addr_enabled = message.withdrawAddrEnabled;
	        return obj;
	    }
	};
	function createBaseValidatorHistoricalRewards() {
	    return {
	        cumulativeRewardRatio: [],
	        referenceCount: 0
	    };
	}
	exports.ValidatorHistoricalRewards = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.cumulativeRewardRatio) {
	            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.referenceCount !== 0) {
	            writer.uint32(16).uint32(message.referenceCount);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorHistoricalRewards();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.referenceCount = reader.uint32();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            cumulativeRewardRatio: Array.isArray(object?.cumulativeRewardRatio) ? object.cumulativeRewardRatio.map((e) => coin_1.DecCoin.fromJSON(e)) : [],
	            referenceCount: (0, helpers_1.isSet)(object.referenceCount) ? Number(object.referenceCount) : 0
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.cumulativeRewardRatio) {
	            obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map(e => e ? coin_1.DecCoin.toJSON(e) : undefined);
	        }
	        else {
	            obj.cumulativeRewardRatio = [];
	        }
	        message.referenceCount !== undefined && (obj.referenceCount = Math.round(message.referenceCount));
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorHistoricalRewards();
	        message.cumulativeRewardRatio = object.cumulativeRewardRatio?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
	        message.referenceCount = object.referenceCount ?? 0;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            cumulativeRewardRatio: Array.isArray(object?.cumulative_reward_ratio) ? object.cumulative_reward_ratio.map((e) => coin_1.DecCoin.fromSDK(e)) : [],
	            referenceCount: object?.reference_count
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.cumulativeRewardRatio) {
	            obj.cumulative_reward_ratio = message.cumulativeRewardRatio.map(e => e ? coin_1.DecCoin.toSDK(e) : undefined);
	        }
	        else {
	            obj.cumulative_reward_ratio = [];
	        }
	        obj.reference_count = message.referenceCount;
	        return obj;
	    }
	};
	function createBaseValidatorCurrentRewards() {
	    return {
	        rewards: [],
	        period: helpers_1.Long.UZERO
	    };
	}
	exports.ValidatorCurrentRewards = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.rewards) {
	            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (!message.period.isZero()) {
	            writer.uint32(16).uint64(message.period);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorCurrentRewards();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.period = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            rewards: Array.isArray(object?.rewards) ? object.rewards.map((e) => coin_1.DecCoin.fromJSON(e)) : [],
	            period: (0, helpers_1.isSet)(object.period) ? helpers_1.Long.fromValue(object.period) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.rewards) {
	            obj.rewards = message.rewards.map(e => e ? coin_1.DecCoin.toJSON(e) : undefined);
	        }
	        else {
	            obj.rewards = [];
	        }
	        message.period !== undefined && (obj.period = (message.period || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorCurrentRewards();
	        message.rewards = object.rewards?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
	        message.period = object.period !== undefined && object.period !== null ? helpers_1.Long.fromValue(object.period) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            rewards: Array.isArray(object?.rewards) ? object.rewards.map((e) => coin_1.DecCoin.fromSDK(e)) : [],
	            period: object?.period
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.rewards) {
	            obj.rewards = message.rewards.map(e => e ? coin_1.DecCoin.toSDK(e) : undefined);
	        }
	        else {
	            obj.rewards = [];
	        }
	        obj.period = message.period;
	        return obj;
	    }
	};
	function createBaseValidatorAccumulatedCommission() {
	    return {
	        commission: []
	    };
	}
	exports.ValidatorAccumulatedCommission = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.commission) {
	            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorAccumulatedCommission();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            commission: Array.isArray(object?.commission) ? object.commission.map((e) => coin_1.DecCoin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.commission) {
	            obj.commission = message.commission.map(e => e ? coin_1.DecCoin.toJSON(e) : undefined);
	        }
	        else {
	            obj.commission = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorAccumulatedCommission();
	        message.commission = object.commission?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            commission: Array.isArray(object?.commission) ? object.commission.map((e) => coin_1.DecCoin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.commission) {
	            obj.commission = message.commission.map(e => e ? coin_1.DecCoin.toSDK(e) : undefined);
	        }
	        else {
	            obj.commission = [];
	        }
	        return obj;
	    }
	};
	function createBaseValidatorOutstandingRewards() {
	    return {
	        rewards: []
	    };
	}
	exports.ValidatorOutstandingRewards = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.rewards) {
	            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorOutstandingRewards();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            rewards: Array.isArray(object?.rewards) ? object.rewards.map((e) => coin_1.DecCoin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.rewards) {
	            obj.rewards = message.rewards.map(e => e ? coin_1.DecCoin.toJSON(e) : undefined);
	        }
	        else {
	            obj.rewards = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorOutstandingRewards();
	        message.rewards = object.rewards?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            rewards: Array.isArray(object?.rewards) ? object.rewards.map((e) => coin_1.DecCoin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.rewards) {
	            obj.rewards = message.rewards.map(e => e ? coin_1.DecCoin.toSDK(e) : undefined);
	        }
	        else {
	            obj.rewards = [];
	        }
	        return obj;
	    }
	};
	function createBaseValidatorSlashEvent() {
	    return {
	        validatorPeriod: helpers_1.Long.UZERO,
	        fraction: ""
	    };
	}
	exports.ValidatorSlashEvent = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.validatorPeriod.isZero()) {
	            writer.uint32(8).uint64(message.validatorPeriod);
	        }
	        if (message.fraction !== "") {
	            writer.uint32(18).string(message.fraction);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorSlashEvent();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validatorPeriod = reader.uint64();
	                    break;
	                case 2:
	                    message.fraction = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validatorPeriod: (0, helpers_1.isSet)(object.validatorPeriod) ? helpers_1.Long.fromValue(object.validatorPeriod) : helpers_1.Long.UZERO,
	            fraction: (0, helpers_1.isSet)(object.fraction) ? String(object.fraction) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.validatorPeriod !== undefined && (obj.validatorPeriod = (message.validatorPeriod || helpers_1.Long.UZERO).toString());
	        message.fraction !== undefined && (obj.fraction = message.fraction);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorSlashEvent();
	        message.validatorPeriod = object.validatorPeriod !== undefined && object.validatorPeriod !== null ? helpers_1.Long.fromValue(object.validatorPeriod) : helpers_1.Long.UZERO;
	        message.fraction = object.fraction ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validatorPeriod: object?.validator_period,
	            fraction: object?.fraction
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.validator_period = message.validatorPeriod;
	        obj.fraction = message.fraction;
	        return obj;
	    }
	};
	function createBaseValidatorSlashEvents() {
	    return {
	        validatorSlashEvents: []
	    };
	}
	exports.ValidatorSlashEvents = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.validatorSlashEvents) {
	            exports.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseValidatorSlashEvents();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validatorSlashEvents.push(exports.ValidatorSlashEvent.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validatorSlashEvents: Array.isArray(object?.validatorSlashEvents) ? object.validatorSlashEvents.map((e) => exports.ValidatorSlashEvent.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.validatorSlashEvents) {
	            obj.validatorSlashEvents = message.validatorSlashEvents.map(e => e ? exports.ValidatorSlashEvent.toJSON(e) : undefined);
	        }
	        else {
	            obj.validatorSlashEvents = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseValidatorSlashEvents();
	        message.validatorSlashEvents = object.validatorSlashEvents?.map(e => exports.ValidatorSlashEvent.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validatorSlashEvents: Array.isArray(object?.validator_slash_events) ? object.validator_slash_events.map((e) => exports.ValidatorSlashEvent.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.validatorSlashEvents) {
	            obj.validator_slash_events = message.validatorSlashEvents.map(e => e ? exports.ValidatorSlashEvent.toSDK(e) : undefined);
	        }
	        else {
	            obj.validator_slash_events = [];
	        }
	        return obj;
	    }
	};
	function createBaseFeePool() {
	    return {
	        communityPool: []
	    };
	}
	exports.FeePool = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.communityPool) {
	            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseFeePool();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            communityPool: Array.isArray(object?.communityPool) ? object.communityPool.map((e) => coin_1.DecCoin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.communityPool) {
	            obj.communityPool = message.communityPool.map(e => e ? coin_1.DecCoin.toJSON(e) : undefined);
	        }
	        else {
	            obj.communityPool = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseFeePool();
	        message.communityPool = object.communityPool?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            communityPool: Array.isArray(object?.community_pool) ? object.community_pool.map((e) => coin_1.DecCoin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.communityPool) {
	            obj.community_pool = message.communityPool.map(e => e ? coin_1.DecCoin.toSDK(e) : undefined);
	        }
	        else {
	            obj.community_pool = [];
	        }
	        return obj;
	    }
	};
	function createBaseCommunityPoolSpendProposal() {
	    return {
	        title: "",
	        description: "",
	        recipient: "",
	        amount: []
	    };
	}
	exports.CommunityPoolSpendProposal = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.title !== "") {
	            writer.uint32(10).string(message.title);
	        }
	        if (message.description !== "") {
	            writer.uint32(18).string(message.description);
	        }
	        if (message.recipient !== "") {
	            writer.uint32(26).string(message.recipient);
	        }
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseCommunityPoolSpendProposal();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.title = reader.string();
	                    break;
	                case 2:
	                    message.description = reader.string();
	                    break;
	                case 3:
	                    message.recipient = reader.string();
	                    break;
	                case 4:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            title: (0, helpers_1.isSet)(object.title) ? String(object.title) : "",
	            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
	            recipient: (0, helpers_1.isSet)(object.recipient) ? String(object.recipient) : "",
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.title !== undefined && (obj.title = message.title);
	        message.description !== undefined && (obj.description = message.description);
	        message.recipient !== undefined && (obj.recipient = message.recipient);
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseCommunityPoolSpendProposal();
	        message.title = object.title ?? "";
	        message.description = object.description ?? "";
	        message.recipient = object.recipient ?? "";
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            title: object?.title,
	            description: object?.description,
	            recipient: object?.recipient,
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.title = message.title;
	        obj.description = message.description;
	        obj.recipient = message.recipient;
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    }
	};
	function createBaseDelegatorStartingInfo() {
	    return {
	        previousPeriod: helpers_1.Long.UZERO,
	        stake: "",
	        height: helpers_1.Long.UZERO
	    };
	}
	exports.DelegatorStartingInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.previousPeriod.isZero()) {
	            writer.uint32(8).uint64(message.previousPeriod);
	        }
	        if (message.stake !== "") {
	            writer.uint32(18).string(message.stake);
	        }
	        if (!message.height.isZero()) {
	            writer.uint32(24).uint64(message.height);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDelegatorStartingInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.previousPeriod = reader.uint64();
	                    break;
	                case 2:
	                    message.stake = reader.string();
	                    break;
	                case 3:
	                    message.height = reader.uint64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            previousPeriod: (0, helpers_1.isSet)(object.previousPeriod) ? helpers_1.Long.fromValue(object.previousPeriod) : helpers_1.Long.UZERO,
	            stake: (0, helpers_1.isSet)(object.stake) ? String(object.stake) : "",
	            height: (0, helpers_1.isSet)(object.height) ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.previousPeriod !== undefined && (obj.previousPeriod = (message.previousPeriod || helpers_1.Long.UZERO).toString());
	        message.stake !== undefined && (obj.stake = message.stake);
	        message.height !== undefined && (obj.height = (message.height || helpers_1.Long.UZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDelegatorStartingInfo();
	        message.previousPeriod = object.previousPeriod !== undefined && object.previousPeriod !== null ? helpers_1.Long.fromValue(object.previousPeriod) : helpers_1.Long.UZERO;
	        message.stake = object.stake ?? "";
	        message.height = object.height !== undefined && object.height !== null ? helpers_1.Long.fromValue(object.height) : helpers_1.Long.UZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            previousPeriod: object?.previous_period,
	            stake: object?.stake,
	            height: object?.height
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.previous_period = message.previousPeriod;
	        obj.stake = message.stake;
	        obj.height = message.height;
	        return obj;
	    }
	};
	function createBaseDelegationDelegatorReward() {
	    return {
	        validatorAddress: "",
	        reward: []
	    };
	}
	exports.DelegationDelegatorReward = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.validatorAddress !== "") {
	            writer.uint32(10).string(message.validatorAddress);
	        }
	        for (const v of message.reward) {
	            coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDelegationDelegatorReward();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validatorAddress = reader.string();
	                    break;
	                case 2:
	                    message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validatorAddress: (0, helpers_1.isSet)(object.validatorAddress) ? String(object.validatorAddress) : "",
	            reward: Array.isArray(object?.reward) ? object.reward.map((e) => coin_1.DecCoin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
	        if (message.reward) {
	            obj.reward = message.reward.map(e => e ? coin_1.DecCoin.toJSON(e) : undefined);
	        }
	        else {
	            obj.reward = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDelegationDelegatorReward();
	        message.validatorAddress = object.validatorAddress ?? "";
	        message.reward = object.reward?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validatorAddress: object?.validator_address,
	            reward: Array.isArray(object?.reward) ? object.reward.map((e) => coin_1.DecCoin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.validator_address = message.validatorAddress;
	        if (message.reward) {
	            obj.reward = message.reward.map(e => e ? coin_1.DecCoin.toSDK(e) : undefined);
	        }
	        else {
	            obj.reward = [];
	        }
	        return obj;
	    }
	};
	function createBaseCommunityPoolSpendProposalWithDeposit() {
	    return {
	        title: "",
	        description: "",
	        recipient: "",
	        amount: "",
	        deposit: ""
	    };
	}
	exports.CommunityPoolSpendProposalWithDeposit = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.title !== "") {
	            writer.uint32(10).string(message.title);
	        }
	        if (message.description !== "") {
	            writer.uint32(18).string(message.description);
	        }
	        if (message.recipient !== "") {
	            writer.uint32(26).string(message.recipient);
	        }
	        if (message.amount !== "") {
	            writer.uint32(34).string(message.amount);
	        }
	        if (message.deposit !== "") {
	            writer.uint32(42).string(message.deposit);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseCommunityPoolSpendProposalWithDeposit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.title = reader.string();
	                    break;
	                case 2:
	                    message.description = reader.string();
	                    break;
	                case 3:
	                    message.recipient = reader.string();
	                    break;
	                case 4:
	                    message.amount = reader.string();
	                    break;
	                case 5:
	                    message.deposit = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            title: (0, helpers_1.isSet)(object.title) ? String(object.title) : "",
	            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
	            recipient: (0, helpers_1.isSet)(object.recipient) ? String(object.recipient) : "",
	            amount: (0, helpers_1.isSet)(object.amount) ? String(object.amount) : "",
	            deposit: (0, helpers_1.isSet)(object.deposit) ? String(object.deposit) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.title !== undefined && (obj.title = message.title);
	        message.description !== undefined && (obj.description = message.description);
	        message.recipient !== undefined && (obj.recipient = message.recipient);
	        message.amount !== undefined && (obj.amount = message.amount);
	        message.deposit !== undefined && (obj.deposit = message.deposit);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseCommunityPoolSpendProposalWithDeposit();
	        message.title = object.title ?? "";
	        message.description = object.description ?? "";
	        message.recipient = object.recipient ?? "";
	        message.amount = object.amount ?? "";
	        message.deposit = object.deposit ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            title: object?.title,
	            description: object?.description,
	            recipient: object?.recipient,
	            amount: object?.amount,
	            deposit: object?.deposit
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.title = message.title;
	        obj.description = message.description;
	        obj.recipient = message.recipient;
	        obj.amount = message.amount;
	        obj.deposit = message.deposit;
	        return obj;
	    }
	};
	
} (distribution));

distribution.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgCommunityPoolSpendResponse = exports.MsgCommunityPoolSpend = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgFundCommunityPoolResponse = exports.MsgFundCommunityPool = exports.MsgWithdrawValidatorCommissionResponse = exports.MsgWithdrawValidatorCommission = exports.MsgWithdrawDelegatorRewardResponse = exports.MsgWithdrawDelegatorReward = exports.MsgSetWithdrawAddressResponse = exports.MsgSetWithdrawAddress = exports.protobufPackage = void 0;
	/* eslint-disable */
	const coin_1 = coin;
	const distribution_1 = distribution;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "cosmos.distribution.v1beta1";
	function createBaseMsgSetWithdrawAddress() {
	    return {
	        delegatorAddress: "",
	        withdrawAddress: ""
	    };
	}
	exports.MsgSetWithdrawAddress = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.delegatorAddress !== "") {
	            writer.uint32(10).string(message.delegatorAddress);
	        }
	        if (message.withdrawAddress !== "") {
	            writer.uint32(18).string(message.withdrawAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSetWithdrawAddress();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.delegatorAddress = reader.string();
	                    break;
	                case 2:
	                    message.withdrawAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            delegatorAddress: (0, helpers_1.isSet)(object.delegatorAddress) ? String(object.delegatorAddress) : "",
	            withdrawAddress: (0, helpers_1.isSet)(object.withdrawAddress) ? String(object.withdrawAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
	        message.withdrawAddress !== undefined && (obj.withdrawAddress = message.withdrawAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgSetWithdrawAddress();
	        message.delegatorAddress = object.delegatorAddress ?? "";
	        message.withdrawAddress = object.withdrawAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            delegatorAddress: object?.delegator_address,
	            withdrawAddress: object?.withdraw_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.delegator_address = message.delegatorAddress;
	        obj.withdraw_address = message.withdrawAddress;
	        return obj;
	    }
	};
	function createBaseMsgSetWithdrawAddressResponse() {
	    return {};
	}
	exports.MsgSetWithdrawAddressResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgSetWithdrawAddressResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgSetWithdrawAddressResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgWithdrawDelegatorReward() {
	    return {
	        delegatorAddress: "",
	        validatorAddress: ""
	    };
	}
	exports.MsgWithdrawDelegatorReward = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.delegatorAddress !== "") {
	            writer.uint32(10).string(message.delegatorAddress);
	        }
	        if (message.validatorAddress !== "") {
	            writer.uint32(18).string(message.validatorAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgWithdrawDelegatorReward();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.delegatorAddress = reader.string();
	                    break;
	                case 2:
	                    message.validatorAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            delegatorAddress: (0, helpers_1.isSet)(object.delegatorAddress) ? String(object.delegatorAddress) : "",
	            validatorAddress: (0, helpers_1.isSet)(object.validatorAddress) ? String(object.validatorAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
	        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgWithdrawDelegatorReward();
	        message.delegatorAddress = object.delegatorAddress ?? "";
	        message.validatorAddress = object.validatorAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            delegatorAddress: object?.delegator_address,
	            validatorAddress: object?.validator_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.delegator_address = message.delegatorAddress;
	        obj.validator_address = message.validatorAddress;
	        return obj;
	    }
	};
	function createBaseMsgWithdrawDelegatorRewardResponse() {
	    return {
	        amount: []
	    };
	}
	exports.MsgWithdrawDelegatorRewardResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgWithdrawDelegatorRewardResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgWithdrawDelegatorRewardResponse();
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgWithdrawValidatorCommission() {
	    return {
	        validatorAddress: ""
	    };
	}
	exports.MsgWithdrawValidatorCommission = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.validatorAddress !== "") {
	            writer.uint32(10).string(message.validatorAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgWithdrawValidatorCommission();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.validatorAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            validatorAddress: (0, helpers_1.isSet)(object.validatorAddress) ? String(object.validatorAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgWithdrawValidatorCommission();
	        message.validatorAddress = object.validatorAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            validatorAddress: object?.validator_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.validator_address = message.validatorAddress;
	        return obj;
	    }
	};
	function createBaseMsgWithdrawValidatorCommissionResponse() {
	    return {
	        amount: []
	    };
	}
	exports.MsgWithdrawValidatorCommissionResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgWithdrawValidatorCommissionResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgWithdrawValidatorCommissionResponse();
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgFundCommunityPool() {
	    return {
	        amount: [],
	        depositor: ""
	    };
	}
	exports.MsgFundCommunityPool = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.depositor !== "") {
	            writer.uint32(18).string(message.depositor);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgFundCommunityPool();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.depositor = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
	            depositor: (0, helpers_1.isSet)(object.depositor) ? String(object.depositor) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        message.depositor !== undefined && (obj.depositor = message.depositor);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgFundCommunityPool();
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        message.depositor = object.depositor ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : [],
	            depositor: object?.depositor
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        obj.depositor = message.depositor;
	        return obj;
	    }
	};
	function createBaseMsgFundCommunityPoolResponse() {
	    return {};
	}
	exports.MsgFundCommunityPoolResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgFundCommunityPoolResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgFundCommunityPoolResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            distribution_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = distribution_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? distribution_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? distribution_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? distribution_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? distribution_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgCommunityPoolSpend() {
	    return {
	        authority: "",
	        recipient: "",
	        amount: []
	    };
	}
	exports.MsgCommunityPoolSpend = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.recipient !== "") {
	            writer.uint32(18).string(message.recipient);
	        }
	        for (const v of message.amount) {
	            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCommunityPoolSpend();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.recipient = reader.string();
	                    break;
	                case 3:
	                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            recipient: (0, helpers_1.isSet)(object.recipient) ? String(object.recipient) : "",
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.recipient !== undefined && (obj.recipient = message.recipient);
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCommunityPoolSpend();
	        message.authority = object.authority ?? "";
	        message.recipient = object.recipient ?? "";
	        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            recipient: object?.recipient,
	            amount: Array.isArray(object?.amount) ? object.amount.map((e) => coin_1.Coin.fromSDK(e)) : []
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        obj.recipient = message.recipient;
	        if (message.amount) {
	            obj.amount = message.amount.map(e => e ? coin_1.Coin.toSDK(e) : undefined);
	        }
	        else {
	            obj.amount = [];
	        }
	        return obj;
	    }
	};
	function createBaseMsgCommunityPoolSpendResponse() {
	    return {};
	}
	exports.MsgCommunityPoolSpendResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCommunityPoolSpendResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgCommunityPoolSpendResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
	        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
	        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
	        this.FundCommunityPool = this.FundCommunityPool.bind(this);
	        this.UpdateParams = this.UpdateParams.bind(this);
	        this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
	    }
	    SetWithdrawAddress(request) {
	        const data = exports.MsgSetWithdrawAddress.encode(request).finish();
	        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data);
	        return promise.then(data => exports.MsgSetWithdrawAddressResponse.decode(new _m0.Reader(data)));
	    }
	    WithdrawDelegatorReward(request) {
	        const data = exports.MsgWithdrawDelegatorReward.encode(request).finish();
	        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data);
	        return promise.then(data => exports.MsgWithdrawDelegatorRewardResponse.decode(new _m0.Reader(data)));
	    }
	    WithdrawValidatorCommission(request) {
	        const data = exports.MsgWithdrawValidatorCommission.encode(request).finish();
	        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data);
	        return promise.then(data => exports.MsgWithdrawValidatorCommissionResponse.decode(new _m0.Reader(data)));
	    }
	    FundCommunityPool(request) {
	        const data = exports.MsgFundCommunityPool.encode(request).finish();
	        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data);
	        return promise.then(data => exports.MsgFundCommunityPoolResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	    CommunityPoolSpend(request) {
	        const data = exports.MsgCommunityPoolSpend.encode(request).finish();
	        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", data);
	        return promise.then(data => exports.MsgCommunityPoolSpendResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx$1));

tx$1.default;

class Distribution extends Account {
    setWithdrawAddress(withdrawAddress, delegatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcCient = yield this.getRpcClient();
            const rpc = new tx$1.MsgClientImpl(rpcCient);
            return yield rpc.SetWithdrawAddress({
                withdrawAddress,
                delegatorAddress,
            });
        });
    }
    withdrawValidatorCommission(validatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcCient = yield this.getRpcClient();
            const rpc = new tx$1.MsgClientImpl(rpcCient);
            return rpc.WithdrawValidatorCommission({
                validatorAddress,
            });
        });
    }
    withdrawDelegatorReward(validatorAddress, delegatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcCient = yield this.getRpcClient();
            const rpc = new tx$1.MsgClientImpl(rpcCient);
            return rpc.WithdrawDelegatorReward({
                delegatorAddress,
                validatorAddress,
            });
        });
    }
    fundCommunityPoolundComm(amount, depositor) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcCient = yield this.getRpcClient();
            const rpc = new tx$1.MsgClientImpl(rpcCient);
            return rpc.FundCommunityPool({
                amount,
                depositor,
            });
        });
    }
}

const MsgCreateGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

const MsgDeleteGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

const MsgLeaveGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

const MsgUpdateGroupMemberSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

class Group extends Account {
    createGroup(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgCreateGroup';
            const msgBytes = tx$5.MsgCreateGroup.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.creator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgCreateGroupSDKTypeEIP712, tx$5.MsgCreateGroup.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    deleteGroup(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgDeleteGroup';
            const msgBytes = tx$5.MsgDeleteGroup.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgDeleteGroupSDKTypeEIP712, tx$5.MsgDeleteGroup.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    updateGroupMember(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (msg.groupName === '') {
                throw new Error('group name is empty');
            }
            if (msg.membersToAdd.length === 0 && msg.membersToDelete.length === 0) {
                throw new Error('no update member');
            }
            const typeUrl = '/bnbchain.greenfield.storage.MsgUpdateGroupMember';
            const msgBytes = tx$5.MsgUpdateGroupMember.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgUpdateGroupMemberSDKTypeEIP712, tx$5.MsgUpdateGroupMember.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    leaveGroup(address, msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgLeaveGroup';
            const msgBytes = tx$5.MsgLeaveGroup.encode(msg).finish();
            const accountInfo = yield this.getAccount(address);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgLeaveGroupSDKTypeEIP712, tx$5.MsgLeaveGroup.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    headGroup(groupName, groupOwner) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return yield rpc.HeadGroup({
                groupName,
                groupOwner,
            });
        });
    }
    headGroupMember(groupName, groupOwner, member) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return yield rpc.HeadGroupMember({
                groupName,
                groupOwner,
                member,
            });
        });
    }
    getPolicyOfGroup(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return yield rpc.QueryPolicyForGroup(request);
        });
    }
}

const TYPE_URL$4 = '/bnbchain.greenfield.storage.MsgCancelCreateObject';
const MsgCancelCreateObjectSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
    ],
};
const newMsgCancelCreateObject = ({ from, bucketName, objectName, }) => {
    return {
        type: TYPE_URL$4,
        operator: from,
        bucket_name: bucketName,
        object_name: objectName,
    };
};

const TYPE_URL$3 = '/bnbchain.greenfield.storage.MsgCreateObject';
const MsgCreateObjectSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
        {
            name: 'payload_size',
            type: 'uint64',
        },
        {
            name: 'visibility',
            type: 'string',
        },
        {
            name: 'content_type',
            type: 'string',
        },
        {
            name: 'primary_sp_approval',
            type: 'TypePrimarySpApproval',
        },
        {
            name: 'expect_checksums',
            type: 'bytes[]',
        },
        {
            name: 'redundancy_type',
            type: 'string',
        },
        {
            name: 'expect_secondary_sp_addresses',
            type: 'string[]',
        },
    ],
    TypePrimarySpApproval: [
        {
            name: 'expired_height',
            type: 'uint64',
        },
        {
            name: 'sig',
            type: 'bytes',
        },
    ],
};
const newMsgCreateObject = ({ bucketName, contentType, expectChecksums, expiredHeight, from, visibility, objectName, payloadSize, sig, expectSecondarySpAddresses, redundancyType, }) => {
    return {
        type: TYPE_URL$3,
        bucket_name: bucketName,
        content_type: contentType,
        creator: from,
        expect_checksums: expectChecksums,
        visibility: visibility === undefined ? common$3.visibilityTypeToJSON(0) : common$3.visibilityTypeToJSON(visibility),
        object_name: objectName,
        payload_size: payloadSize,
        primary_sp_approval: {
            expired_height: expiredHeight,
            sig: sig,
        },
        expect_secondary_sp_addresses: expectSecondarySpAddresses,
        redundancy_type: redundancyType === undefined ? common$3.redundancyTypeToJSON(0) : common$3.redundancyTypeToJSON(redundancyType),
    };
};

const TYPE_URL$2 = '/bnbchain.greenfield.storage.MsgDeleteObject';
const MsgDeleteObjectSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
    ],
};
const newMsgDeleteObject = ({ bucketName, objectName, from }) => {
    return {
        type: TYPE_URL$2,
        bucket_name: bucketName,
        object_name: objectName,
        operator: from,
    };
};

class Object$1 extends Account {
    constructor(rpcUrl, chainId, bucket) {
        super(rpcUrl, chainId);
        this.bucket = bucket;
    }
    getCreateObjectApproval({ bucketName, creator, objectName, visibility = 'VISIBILITY_TYPE_PUBLIC_READ', spInfo, duration = 3000, file, redundancyType = 'REDUNDANCY_EC_TYPE', }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!isValidUrl(spInfo.endpoint)) {
                    throw new Error('Invalid endpoint');
                }
                if (!file) {
                    throw new Error('File is needed');
                }
                if (!isValidBucketName(bucketName)) ;
                if (!isValidObjectName(objectName)) ;
                if (!creator) {
                    throw new Error('empty creator address');
                }
                const buffer = yield file.arrayBuffer();
                const bytes = new Uint8Array(buffer);
                const hashResult = yield greenfiledFileHandle.FileHandler.getPieceHashRoots(bytes);
                const { contentLength, expectCheckSums } = hashResult;
                const finalContentType = file && file.type && file.type.length > 0 ? file.type : 'application/octet-stream';
                const msg = {
                    creator: creator,
                    object_name: objectName,
                    content_type: finalContentType,
                    payload_size: contentLength.toString(),
                    bucket_name: bucketName,
                    visibility,
                    primary_sp_approval: { expired_height: '0', sig: '' },
                    expect_checksums: expectCheckSums,
                    redundancy_type: redundancyType,
                    expect_secondary_sp_addresses: spInfo.secondarySpAddresses,
                };
                const signature = MOCK_SIGNATURE;
                const url = spInfo.endpoint + '/greenfield/admin/v1/get-approval?action=CreateObject';
                const unSignedMessageInHex = encodeObjectToHexString(msg);
                const headers = new Headers({
                    // todo place the correct authorization string
                    Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                    'X-Gnfd-Unsigned-Msg': unSignedMessageInHex,
                });
                const result = yield fetchWithTimeout(url, {
                    headers,
                    method: METHOD_GET,
                }, duration);
                const { status } = result;
                if (!result.ok) {
                    return {
                        code: -1,
                        message: 'Get create object approval error.',
                        statusCode: status,
                    };
                }
                const resultContentType = result.headers.get('Content-Type');
                // Will receive xml when get object met error
                if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                    const xmlText = yield result.text();
                    const xml = yield new window.DOMParser().parseFromString(xmlText, 'text/xml');
                    return {
                        code: -1,
                        xml,
                        message: 'Get create object approval error.',
                        statusCode: status,
                    };
                }
                const signedMsgString = result.headers.get('X-Gnfd-Signed-Msg') || '';
                const signedMsg = decodeObjectFromHexString(signedMsgString);
                return {
                    code: 0,
                    message: 'Get create object approval success.',
                    body: (_a = result.headers.get('X-Gnfd-Signed-Msg')) !== null && _a !== void 0 ? _a : '',
                    statusCode: status,
                    signedMsg,
                };
            }
            catch (error) {
                return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
            }
        });
    }
    createObject(getApprovalParams, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const { signedMsg } = yield this.getCreateObjectApproval(getApprovalParams);
            if (!signedMsg) {
                throw new Error('Get create object approval error');
            }
            const msg = {
                bucketName: signedMsg.bucket_name,
                creator: signedMsg.creator,
                objectName: signedMsg.object_name,
                contentType: signedMsg.content_type,
                payloadSize: Long__default["default"].fromString(signedMsg.payload_size),
                visibility: common$3.visibilityTypeFromJSON(signedMsg.visibility),
                expectChecksums: signedMsg.expect_checksums.map((e) => bytesFromBase64_1(e)),
                expectSecondarySpAddresses: signedMsg.expect_secondary_sp_addresses,
                redundancyType: signedMsg.redundancy_type === undefined
                    ? common$3.redundancyTypeFromJSON(0)
                    : common$3.redundancyTypeFromJSON(signedMsg.redundancy_type),
                primarySpApproval: {
                    expiredHeight: Long__default["default"].fromString(signedMsg.primary_sp_approval.expired_height),
                    sig: bytesFromBase64_1(signedMsg.primary_sp_approval.sig),
                },
            };
            const typeUrl = '/bnbchain.greenfield.storage.MsgCreateObject';
            const msgBytes = tx$5.MsgCreateObject.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.creator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgCreateObjectSDKTypeEIP712, Object$1.assign(Object$1.assign({}, signedMsg), { type: typeUrl, visibility: signedMsg.visibility, primary_sp_approval: {
                    expired_height: signedMsg.primary_sp_approval.expired_height,
                    sig: signedMsg.primary_sp_approval.sig,
                }, redundancy_type: signedMsg.redundancy_type, payload_size: signedMsg.payload_size }), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    uploadObject(configParam) {
        return __awaiter(this, void 0, void 0, function* () {
            const { bucketName, objectName, txnHash, body, endpoint, duration = 30000 } = configParam;
            if (!isValidBucketName(bucketName)) ;
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            if (!isValidObjectName(objectName)) ;
            if (!txnHash) {
                throw new Error('Transaction hash is empty, please check.');
            }
            const url = generateUrlByBucketName(endpoint, bucketName) + '/' + objectName;
            // todo generate real signature
            const signature = MOCK_SIGNATURE;
            const headers = new Headers({
                // todo place the correct authorization string
                Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                'X-Gnfd-Txn-hash': txnHash,
            });
            try {
                const result = yield fetchWithTimeout(url, {
                    headers,
                    method: METHOD_PUT,
                    body,
                }, duration);
                const { status } = result;
                if (!result.ok) {
                    return { code: -1, message: 'Put object error.', statusCode: status };
                }
                const resultContentType = result.headers.get('Content-Type');
                // Will receive xml when put object met error
                if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                    const xmlText = yield result.text();
                    const xml = yield new window.DOMParser().parseFromString(xmlText, 'text/xml');
                    return { code: -1, message: 'Put object error.', xml, statusCode: status };
                }
                return { code: 0, message: 'Put object success.', statusCode: status };
            }
            catch (error) {
                return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
            }
        });
    }
    cancelCreateObject(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgCancelCreateObject';
            const msgBytes = tx$5.MsgCancelCreateObject.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgCancelCreateObjectSDKTypeEIP712, tx$5.MsgCancelCreateObject.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    deleteObject(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.storage.MsgDeleteObject';
            const msgBytes = tx$5.MsgDeleteObject.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.operator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgDeleteObjectSDKTypeEIP712, tx$5.MsgDeleteObject.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    headObject(bucketName, objectName) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return rpc.HeadObject({
                bucketName,
                objectName,
            });
        });
    }
    headObjectById(objectId) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$5.QueryClientImpl(rpcClient);
            return rpc.HeadObjectById({
                objectId,
            });
        });
    }
    getObject(configParam) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { bucketName, objectName, endpoint, duration = 30000 } = configParam;
                // todo generate real signature
                const signature = MOCK_SIGNATURE;
                if (!isValidUrl(endpoint)) {
                    throw new Error('Invalid endpoint');
                }
                if (!isValidBucketName(bucketName)) ;
                if (!isValidObjectName(objectName)) ;
                const url = generateUrlByBucketName(endpoint, bucketName) + '/' + objectName;
                const headers = new Headers({
                    Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                });
                const result = yield fetchWithTimeout(url, {
                    headers,
                    method: METHOD_GET,
                }, duration);
                const { status } = result;
                if (!result.ok) {
                    return { code: -1, message: 'Get object error.', statusCode: status };
                }
                const resultContentType = result.headers.get('Content-Type');
                // Will receive xml when get object met error
                if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                    const xmlText = yield result.text();
                    const xml = yield new window.DOMParser().parseFromString(xmlText, 'text/xml');
                    return {
                        code: -1,
                        xml,
                        message: 'Get object error.',
                        statusCode: status,
                    };
                }
                const fileBlob = yield result.blob();
                return {
                    code: 0,
                    body: fileBlob,
                    message: 'Get object success.',
                    statusCode: status,
                };
            }
            catch (error) {
                return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
            }
        });
    }
    downloadFile(configParam) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { objectName } = configParam;
                const getObjectResult = yield this.getObject(configParam);
                if (getObjectResult.code !== 0) {
                    throw new Error(getObjectResult.message);
                }
                const file = getObjectResult === null || getObjectResult === void 0 ? void 0 : getObjectResult.body;
                if (file) {
                    // const {file} = getObjectResult;
                    const fileURL = URL.createObjectURL(file);
                    // create <a> tag dynamically
                    const fileLink = document.createElement('a');
                    fileLink.href = fileURL;
                    // it forces the name of the downloaded file
                    fileLink.download = objectName;
                    // triggers the click event
                    fileLink.click();
                }
                return;
            }
            catch (error) {
                throw new Error(error);
            }
        });
    }
    listObjects(configParam) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { bucketName, endpoint, duration = 30000 } = configParam;
                if (!isValidBucketName(bucketName)) ;
                if (!isValidUrl(endpoint)) {
                    throw new Error('Invalid endpoint');
                }
                const url = generateUrlByBucketName(endpoint, bucketName);
                const signature = MOCK_SIGNATURE;
                const headers = new Headers({
                    // todo place the correct authorization string
                    Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                });
                const result = yield fetchWithTimeout(url, {
                    headers,
                    method: METHOD_GET,
                }, duration);
                const { status } = result;
                if (!result.ok) {
                    return { code: -1, message: 'List object error.', statusCode: status };
                }
                const { objects } = yield result.json();
                return {
                    code: 0,
                    message: 'List object success.',
                    statusCode: status,
                    body: objects,
                };
            }
            catch (error) {
                return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
            }
        });
    }
    createFolder(getApprovalParams, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!getApprovalParams.objectName.endsWith('/')) {
                throw new Error('failed to create folder. Folder names must end with a forward slash (/) character');
            }
            return this.createObject(getApprovalParams, txOption);
        });
    }
}

const MsgDepositSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "string",
      "name": "amount"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

const MsgDisableRefundSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "string",
      "name": "amount"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "from"
    },
    {
      "type": "string",
      "name": "amount"
    },
    {
      "type": "string",
      "name": "owner"
    },
    {
      "type": "string",
      "name": "addr"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

const MsgWithdrawSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "string",
      "name": "amount"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "from"
    },
    {
      "type": "string",
      "name": "amount"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

class Payment extends Account {
    getStreamRecord(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$7.QueryClientImpl(rpcClient);
            return yield rpc.StreamRecord({
                account,
            });
        });
    }
    params() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query$7.QueryClientImpl(rpcClient);
            return yield rpc.Params();
        });
    }
    deposit(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.payment.MsgDeposit';
            const msgBytes = tx$7.MsgDeposit.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.creator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgDepositSDKTypeEIP712, tx$7.MsgDeposit.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    withdraw(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.payment.MsgWithdraw';
            const msgBytes = tx$7.MsgWithdraw.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.creator);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgWithdrawSDKTypeEIP712, tx$7.MsgWithdraw.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
    disableRefund(msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.payment.MsgDisableRefund';
            const msgBytes = tx$7.MsgDisableRefund.encode(msg).finish();
            const accountInfo = yield this.getAccount(msg.addr);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgDisableRefundSDKTypeEIP712, tx$7.MsgDisableRefund.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
}

const MsgUpdateSpStoragePriceSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "TypeDescription",
      "name": "description"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "string",
      "name": "funding_address"
    },
    {
      "type": "string",
      "name": "seal_address"
    },
    {
      "type": "string",
      "name": "approval_address"
    },
    {
      "type": "string",
      "name": "gc_address"
    },
    {
      "type": "string",
      "name": "endpoint"
    },
    {
      "type": "TypeAmount",
      "name": "deposit"
    },
    {
      "type": "string",
      "name": "read_price"
    },
    {
      "type": "uint64",
      "name": "free_read_quota"
    },
    {
      "type": "string",
      "name": "store_price"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "TypeAmount",
      "name": "deposit"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "string",
      "name": "endpoint"
    },
    {
      "type": "TypeDescription",
      "name": "description"
    },
    {
      "type": "string",
      "name": "seal_address"
    },
    {
      "type": "string",
      "name": "approval_address"
    },
    {
      "type": "string",
      "name": "gc_address"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "string",
      "name": "read_price"
    },
    {
      "type": "uint64",
      "name": "free_read_quota"
    },
    {
      "type": "string",
      "name": "store_price"
    }
  ],
  "TypeDescription": [
    {
      "type": "string",
      "name": "moniker"
    },
    {
      "type": "string",
      "name": "identity"
    },
    {
      "type": "string",
      "name": "website"
    },
    {
      "type": "string",
      "name": "security_contact"
    },
    {
      "type": "string",
      "name": "details"
    }
  ]
};

var query = {};

var params = {};

var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(params, "__esModule", { value: true });
params.Params = params.protobufPackage = void 0;
/* eslint-disable */
const _m0 = __importStar(minimal$1.exports);
const helpers_1 = helpers;
params.protobufPackage = "greenfield.sp";
function createBaseParams() {
    return {
        depositDenom: "",
        minDeposit: "",
        secondarySpStorePriceRatio: ""
    };
}
params.Params = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.depositDenom !== "") {
            writer.uint32(10).string(message.depositDenom);
        }
        if (message.minDeposit !== "") {
            writer.uint32(18).string(message.minDeposit);
        }
        if (message.secondarySpStorePriceRatio !== "") {
            writer.uint32(26).string(message.secondarySpStorePriceRatio);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositDenom = reader.string();
                    break;
                case 2:
                    message.minDeposit = reader.string();
                    break;
                case 3:
                    message.secondarySpStorePriceRatio = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            depositDenom: (0, helpers_1.isSet)(object.depositDenom) ? String(object.depositDenom) : "",
            minDeposit: (0, helpers_1.isSet)(object.minDeposit) ? String(object.minDeposit) : "",
            secondarySpStorePriceRatio: (0, helpers_1.isSet)(object.secondarySpStorePriceRatio) ? String(object.secondarySpStorePriceRatio) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.depositDenom !== undefined && (obj.depositDenom = message.depositDenom);
        message.minDeposit !== undefined && (obj.minDeposit = message.minDeposit);
        message.secondarySpStorePriceRatio !== undefined && (obj.secondarySpStorePriceRatio = message.secondarySpStorePriceRatio);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseParams();
        message.depositDenom = object.depositDenom ?? "";
        message.minDeposit = object.minDeposit ?? "";
        message.secondarySpStorePriceRatio = object.secondarySpStorePriceRatio ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            depositDenom: object?.deposit_denom,
            minDeposit: object?.min_deposit,
            secondarySpStorePriceRatio: object?.secondary_sp_store_price_ratio
        };
    },
    toSDK(message) {
        const obj = {};
        obj.deposit_denom = message.depositDenom;
        obj.min_deposit = message.minDeposit;
        obj.secondary_sp_store_price_ratio = message.secondarySpStorePriceRatio;
        return obj;
    }
};

var types = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SecondarySpStorePrice = exports.SpStoragePrice = exports.RewardInfo = exports.StorageProvider = exports.Description = exports.statusToJSON = exports.statusFromJSON = exports.StatusSDKType = exports.Status = exports.protobufPackage = void 0;
	/* eslint-disable */
	const coin_1 = coin;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.sp";
	/** Status is the status of a storage provider. */
	var Status;
	(function (Status) {
	    Status[Status["STATUS_IN_SERVICE"] = 0] = "STATUS_IN_SERVICE";
	    Status[Status["STATUS_IN_JAILED"] = 1] = "STATUS_IN_JAILED";
	    Status[Status["STATUS_GRACEFUL_EXITING"] = 2] = "STATUS_GRACEFUL_EXITING";
	    Status[Status["STATUS_OUT_OF_SERVICE"] = 3] = "STATUS_OUT_OF_SERVICE";
	    Status[Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
	})(Status = exports.Status || (exports.Status = {}));
	exports.StatusSDKType = Status;
	function statusFromJSON(object) {
	    switch (object) {
	        case 0:
	        case "STATUS_IN_SERVICE":
	            return Status.STATUS_IN_SERVICE;
	        case 1:
	        case "STATUS_IN_JAILED":
	            return Status.STATUS_IN_JAILED;
	        case 2:
	        case "STATUS_GRACEFUL_EXITING":
	            return Status.STATUS_GRACEFUL_EXITING;
	        case 3:
	        case "STATUS_OUT_OF_SERVICE":
	            return Status.STATUS_OUT_OF_SERVICE;
	        case -1:
	        case "UNRECOGNIZED":
	        default:
	            return Status.UNRECOGNIZED;
	    }
	}
	exports.statusFromJSON = statusFromJSON;
	function statusToJSON(object) {
	    switch (object) {
	        case Status.STATUS_IN_SERVICE:
	            return "STATUS_IN_SERVICE";
	        case Status.STATUS_IN_JAILED:
	            return "STATUS_IN_JAILED";
	        case Status.STATUS_GRACEFUL_EXITING:
	            return "STATUS_GRACEFUL_EXITING";
	        case Status.STATUS_OUT_OF_SERVICE:
	            return "STATUS_OUT_OF_SERVICE";
	        case Status.UNRECOGNIZED:
	        default:
	            return "UNRECOGNIZED";
	    }
	}
	exports.statusToJSON = statusToJSON;
	function createBaseDescription() {
	    return {
	        moniker: "",
	        identity: "",
	        website: "",
	        securityContact: "",
	        details: ""
	    };
	}
	exports.Description = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.moniker !== "") {
	            writer.uint32(10).string(message.moniker);
	        }
	        if (message.identity !== "") {
	            writer.uint32(18).string(message.identity);
	        }
	        if (message.website !== "") {
	            writer.uint32(26).string(message.website);
	        }
	        if (message.securityContact !== "") {
	            writer.uint32(34).string(message.securityContact);
	        }
	        if (message.details !== "") {
	            writer.uint32(42).string(message.details);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseDescription();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.moniker = reader.string();
	                    break;
	                case 2:
	                    message.identity = reader.string();
	                    break;
	                case 3:
	                    message.website = reader.string();
	                    break;
	                case 4:
	                    message.securityContact = reader.string();
	                    break;
	                case 5:
	                    message.details = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            moniker: (0, helpers_1.isSet)(object.moniker) ? String(object.moniker) : "",
	            identity: (0, helpers_1.isSet)(object.identity) ? String(object.identity) : "",
	            website: (0, helpers_1.isSet)(object.website) ? String(object.website) : "",
	            securityContact: (0, helpers_1.isSet)(object.securityContact) ? String(object.securityContact) : "",
	            details: (0, helpers_1.isSet)(object.details) ? String(object.details) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.moniker !== undefined && (obj.moniker = message.moniker);
	        message.identity !== undefined && (obj.identity = message.identity);
	        message.website !== undefined && (obj.website = message.website);
	        message.securityContact !== undefined && (obj.securityContact = message.securityContact);
	        message.details !== undefined && (obj.details = message.details);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseDescription();
	        message.moniker = object.moniker ?? "";
	        message.identity = object.identity ?? "";
	        message.website = object.website ?? "";
	        message.securityContact = object.securityContact ?? "";
	        message.details = object.details ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            moniker: object?.moniker,
	            identity: object?.identity,
	            website: object?.website,
	            securityContact: object?.security_contact,
	            details: object?.details
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.moniker = message.moniker;
	        obj.identity = message.identity;
	        obj.website = message.website;
	        obj.security_contact = message.securityContact;
	        obj.details = message.details;
	        return obj;
	    }
	};
	function createBaseStorageProvider() {
	    return {
	        operatorAddress: "",
	        fundingAddress: "",
	        sealAddress: "",
	        approvalAddress: "",
	        gcAddress: "",
	        totalDeposit: "",
	        status: 0,
	        endpoint: "",
	        description: undefined
	    };
	}
	exports.StorageProvider = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.operatorAddress !== "") {
	            writer.uint32(10).string(message.operatorAddress);
	        }
	        if (message.fundingAddress !== "") {
	            writer.uint32(18).string(message.fundingAddress);
	        }
	        if (message.sealAddress !== "") {
	            writer.uint32(26).string(message.sealAddress);
	        }
	        if (message.approvalAddress !== "") {
	            writer.uint32(34).string(message.approvalAddress);
	        }
	        if (message.gcAddress !== "") {
	            writer.uint32(42).string(message.gcAddress);
	        }
	        if (message.totalDeposit !== "") {
	            writer.uint32(50).string(message.totalDeposit);
	        }
	        if (message.status !== 0) {
	            writer.uint32(56).int32(message.status);
	        }
	        if (message.endpoint !== "") {
	            writer.uint32(66).string(message.endpoint);
	        }
	        if (message.description !== undefined) {
	            exports.Description.encode(message.description, writer.uint32(74).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseStorageProvider();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.operatorAddress = reader.string();
	                    break;
	                case 2:
	                    message.fundingAddress = reader.string();
	                    break;
	                case 3:
	                    message.sealAddress = reader.string();
	                    break;
	                case 4:
	                    message.approvalAddress = reader.string();
	                    break;
	                case 5:
	                    message.gcAddress = reader.string();
	                    break;
	                case 6:
	                    message.totalDeposit = reader.string();
	                    break;
	                case 7:
	                    message.status = reader.int32();
	                    break;
	                case 8:
	                    message.endpoint = reader.string();
	                    break;
	                case 9:
	                    message.description = exports.Description.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            operatorAddress: (0, helpers_1.isSet)(object.operatorAddress) ? String(object.operatorAddress) : "",
	            fundingAddress: (0, helpers_1.isSet)(object.fundingAddress) ? String(object.fundingAddress) : "",
	            sealAddress: (0, helpers_1.isSet)(object.sealAddress) ? String(object.sealAddress) : "",
	            approvalAddress: (0, helpers_1.isSet)(object.approvalAddress) ? String(object.approvalAddress) : "",
	            gcAddress: (0, helpers_1.isSet)(object.gcAddress) ? String(object.gcAddress) : "",
	            totalDeposit: (0, helpers_1.isSet)(object.totalDeposit) ? String(object.totalDeposit) : "",
	            status: (0, helpers_1.isSet)(object.status) ? statusFromJSON(object.status) : 0,
	            endpoint: (0, helpers_1.isSet)(object.endpoint) ? String(object.endpoint) : "",
	            description: (0, helpers_1.isSet)(object.description) ? exports.Description.fromJSON(object.description) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
	        message.fundingAddress !== undefined && (obj.fundingAddress = message.fundingAddress);
	        message.sealAddress !== undefined && (obj.sealAddress = message.sealAddress);
	        message.approvalAddress !== undefined && (obj.approvalAddress = message.approvalAddress);
	        message.gcAddress !== undefined && (obj.gcAddress = message.gcAddress);
	        message.totalDeposit !== undefined && (obj.totalDeposit = message.totalDeposit);
	        message.status !== undefined && (obj.status = statusToJSON(message.status));
	        message.endpoint !== undefined && (obj.endpoint = message.endpoint);
	        message.description !== undefined && (obj.description = message.description ? exports.Description.toJSON(message.description) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseStorageProvider();
	        message.operatorAddress = object.operatorAddress ?? "";
	        message.fundingAddress = object.fundingAddress ?? "";
	        message.sealAddress = object.sealAddress ?? "";
	        message.approvalAddress = object.approvalAddress ?? "";
	        message.gcAddress = object.gcAddress ?? "";
	        message.totalDeposit = object.totalDeposit ?? "";
	        message.status = object.status ?? 0;
	        message.endpoint = object.endpoint ?? "";
	        message.description = object.description !== undefined && object.description !== null ? exports.Description.fromPartial(object.description) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            operatorAddress: object?.operator_address,
	            fundingAddress: object?.funding_address,
	            sealAddress: object?.seal_address,
	            approvalAddress: object?.approval_address,
	            gcAddress: object?.gc_address,
	            totalDeposit: object?.total_deposit,
	            status: (0, helpers_1.isSet)(object.status) ? statusFromJSON(object.status) : 0,
	            endpoint: object?.endpoint,
	            description: object.description ? exports.Description.fromSDK(object.description) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.operator_address = message.operatorAddress;
	        obj.funding_address = message.fundingAddress;
	        obj.seal_address = message.sealAddress;
	        obj.approval_address = message.approvalAddress;
	        obj.gc_address = message.gcAddress;
	        obj.total_deposit = message.totalDeposit;
	        message.status !== undefined && (obj.status = statusToJSON(message.status));
	        obj.endpoint = message.endpoint;
	        message.description !== undefined && (obj.description = message.description ? exports.Description.toSDK(message.description) : undefined);
	        return obj;
	    }
	};
	function createBaseRewardInfo() {
	    return {
	        address: "",
	        amount: undefined
	    };
	}
	exports.RewardInfo = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.address !== "") {
	            writer.uint32(10).string(message.address);
	        }
	        if (message.amount !== undefined) {
	            coin_1.Coin.encode(message.amount, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseRewardInfo();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.address = reader.string();
	                    break;
	                case 2:
	                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
	            amount: (0, helpers_1.isSet)(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.address !== undefined && (obj.address = message.address);
	        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseRewardInfo();
	        message.address = object.address ?? "";
	        message.amount = object.amount !== undefined && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            address: object?.address,
	            amount: object.amount ? coin_1.Coin.fromSDK(object.amount) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.address = message.address;
	        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toSDK(message.amount) : undefined);
	        return obj;
	    }
	};
	function createBaseSpStoragePrice() {
	    return {
	        spAddress: "",
	        updateTimeSec: helpers_1.Long.ZERO,
	        readPrice: "",
	        freeReadQuota: helpers_1.Long.UZERO,
	        storePrice: ""
	    };
	}
	exports.SpStoragePrice = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spAddress !== "") {
	            writer.uint32(10).string(message.spAddress);
	        }
	        if (!message.updateTimeSec.isZero()) {
	            writer.uint32(16).int64(message.updateTimeSec);
	        }
	        if (message.readPrice !== "") {
	            writer.uint32(26).string(message.readPrice);
	        }
	        if (!message.freeReadQuota.isZero()) {
	            writer.uint32(32).uint64(message.freeReadQuota);
	        }
	        if (message.storePrice !== "") {
	            writer.uint32(42).string(message.storePrice);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSpStoragePrice();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spAddress = reader.string();
	                    break;
	                case 2:
	                    message.updateTimeSec = reader.int64();
	                    break;
	                case 3:
	                    message.readPrice = reader.string();
	                    break;
	                case 4:
	                    message.freeReadQuota = reader.uint64();
	                    break;
	                case 5:
	                    message.storePrice = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
	            updateTimeSec: (0, helpers_1.isSet)(object.updateTimeSec) ? helpers_1.Long.fromValue(object.updateTimeSec) : helpers_1.Long.ZERO,
	            readPrice: (0, helpers_1.isSet)(object.readPrice) ? String(object.readPrice) : "",
	            freeReadQuota: (0, helpers_1.isSet)(object.freeReadQuota) ? helpers_1.Long.fromValue(object.freeReadQuota) : helpers_1.Long.UZERO,
	            storePrice: (0, helpers_1.isSet)(object.storePrice) ? String(object.storePrice) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        message.updateTimeSec !== undefined && (obj.updateTimeSec = (message.updateTimeSec || helpers_1.Long.ZERO).toString());
	        message.readPrice !== undefined && (obj.readPrice = message.readPrice);
	        message.freeReadQuota !== undefined && (obj.freeReadQuota = (message.freeReadQuota || helpers_1.Long.UZERO).toString());
	        message.storePrice !== undefined && (obj.storePrice = message.storePrice);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSpStoragePrice();
	        message.spAddress = object.spAddress ?? "";
	        message.updateTimeSec = object.updateTimeSec !== undefined && object.updateTimeSec !== null ? helpers_1.Long.fromValue(object.updateTimeSec) : helpers_1.Long.ZERO;
	        message.readPrice = object.readPrice ?? "";
	        message.freeReadQuota = object.freeReadQuota !== undefined && object.freeReadQuota !== null ? helpers_1.Long.fromValue(object.freeReadQuota) : helpers_1.Long.UZERO;
	        message.storePrice = object.storePrice ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spAddress: object?.sp_address,
	            updateTimeSec: object?.update_time_sec,
	            readPrice: object?.read_price,
	            freeReadQuota: object?.free_read_quota,
	            storePrice: object?.store_price
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sp_address = message.spAddress;
	        obj.update_time_sec = message.updateTimeSec;
	        obj.read_price = message.readPrice;
	        obj.free_read_quota = message.freeReadQuota;
	        obj.store_price = message.storePrice;
	        return obj;
	    }
	};
	function createBaseSecondarySpStorePrice() {
	    return {
	        updateTimeSec: helpers_1.Long.ZERO,
	        storePrice: ""
	    };
	}
	exports.SecondarySpStorePrice = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.updateTimeSec.isZero()) {
	            writer.uint32(8).int64(message.updateTimeSec);
	        }
	        if (message.storePrice !== "") {
	            writer.uint32(18).string(message.storePrice);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseSecondarySpStorePrice();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.updateTimeSec = reader.int64();
	                    break;
	                case 2:
	                    message.storePrice = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            updateTimeSec: (0, helpers_1.isSet)(object.updateTimeSec) ? helpers_1.Long.fromValue(object.updateTimeSec) : helpers_1.Long.ZERO,
	            storePrice: (0, helpers_1.isSet)(object.storePrice) ? String(object.storePrice) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.updateTimeSec !== undefined && (obj.updateTimeSec = (message.updateTimeSec || helpers_1.Long.ZERO).toString());
	        message.storePrice !== undefined && (obj.storePrice = message.storePrice);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseSecondarySpStorePrice();
	        message.updateTimeSec = object.updateTimeSec !== undefined && object.updateTimeSec !== null ? helpers_1.Long.fromValue(object.updateTimeSec) : helpers_1.Long.ZERO;
	        message.storePrice = object.storePrice ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            updateTimeSec: object?.update_time_sec,
	            storePrice: object?.store_price
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.update_time_sec = message.updateTimeSec;
	        obj.store_price = message.storePrice;
	        return obj;
	    }
	};
	
} (types));

types.default;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QueryClientImpl = exports.QueryStorageProviderResponse = exports.QueryStorageProviderRequest = exports.QueryGetSecondarySpStorePriceByTimeResponse = exports.QueryGetSecondarySpStorePriceByTimeRequest = exports.QueryGetSpStoragePriceByTimeResponse = exports.QueryGetSpStoragePriceByTimeRequest = exports.QueryStorageProvidersResponse = exports.QueryStorageProvidersRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
	/* eslint-disable */
	const pagination_1 = pagination;
	const params_1 = params;
	const types_1 = types;
	const _m0 = __importStar(minimal$1.exports);
	const helpers_1 = helpers;
	exports.protobufPackage = "greenfield.sp";
	function createBaseQueryParamsRequest() {
	    return {};
	}
	exports.QueryParamsRequest = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseQueryParamsRequest();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseQueryParamsResponse() {
	    return {
	        params: undefined
	    };
	}
	exports.QueryParamsResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryParamsResponse();
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryStorageProvidersRequest() {
	    return {
	        pagination: undefined
	    };
	}
	exports.QueryStorageProvidersRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.pagination !== undefined) {
	            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryStorageProvidersRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryStorageProvidersRequest();
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            pagination: object.pagination ? pagination_1.PageRequest.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryStorageProvidersResponse() {
	    return {
	        sps: [],
	        pagination: undefined
	    };
	}
	exports.QueryStorageProvidersResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        for (const v of message.sps) {
	            types_1.StorageProvider.encode(v, writer.uint32(10).fork()).ldelim();
	        }
	        if (message.pagination !== undefined) {
	            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryStorageProvidersResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.sps.push(types_1.StorageProvider.decode(reader, reader.uint32()));
	                    break;
	                case 2:
	                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            sps: Array.isArray(object?.sps) ? object.sps.map((e) => types_1.StorageProvider.fromJSON(e)) : [],
	            pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        if (message.sps) {
	            obj.sps = message.sps.map(e => e ? types_1.StorageProvider.toJSON(e) : undefined);
	        }
	        else {
	            obj.sps = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryStorageProvidersResponse();
	        message.sps = object.sps?.map(e => types_1.StorageProvider.fromPartial(e)) || [];
	        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            sps: Array.isArray(object?.sps) ? object.sps.map((e) => types_1.StorageProvider.fromSDK(e)) : [],
	            pagination: object.pagination ? pagination_1.PageResponse.fromSDK(object.pagination) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        if (message.sps) {
	            obj.sps = message.sps.map(e => e ? types_1.StorageProvider.toSDK(e) : undefined);
	        }
	        else {
	            obj.sps = [];
	        }
	        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toSDK(message.pagination) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryGetSpStoragePriceByTimeRequest() {
	    return {
	        spAddr: "",
	        timestamp: helpers_1.Long.ZERO
	    };
	}
	exports.QueryGetSpStoragePriceByTimeRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spAddr !== "") {
	            writer.uint32(10).string(message.spAddr);
	        }
	        if (!message.timestamp.isZero()) {
	            writer.uint32(16).int64(message.timestamp);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetSpStoragePriceByTimeRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spAddr = reader.string();
	                    break;
	                case 2:
	                    message.timestamp = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spAddr: (0, helpers_1.isSet)(object.spAddr) ? String(object.spAddr) : "",
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? helpers_1.Long.fromValue(object.timestamp) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spAddr !== undefined && (obj.spAddr = message.spAddr);
	        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetSpStoragePriceByTimeRequest();
	        message.spAddr = object.spAddr ?? "";
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? helpers_1.Long.fromValue(object.timestamp) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spAddr: object?.sp_addr,
	            timestamp: object?.timestamp
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sp_addr = message.spAddr;
	        obj.timestamp = message.timestamp;
	        return obj;
	    }
	};
	function createBaseQueryGetSpStoragePriceByTimeResponse() {
	    return {
	        spStoragePrice: undefined
	    };
	}
	exports.QueryGetSpStoragePriceByTimeResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spStoragePrice !== undefined) {
	            types_1.SpStoragePrice.encode(message.spStoragePrice, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetSpStoragePriceByTimeResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spStoragePrice = types_1.SpStoragePrice.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spStoragePrice: (0, helpers_1.isSet)(object.spStoragePrice) ? types_1.SpStoragePrice.fromJSON(object.spStoragePrice) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spStoragePrice !== undefined && (obj.spStoragePrice = message.spStoragePrice ? types_1.SpStoragePrice.toJSON(message.spStoragePrice) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetSpStoragePriceByTimeResponse();
	        message.spStoragePrice = object.spStoragePrice !== undefined && object.spStoragePrice !== null ? types_1.SpStoragePrice.fromPartial(object.spStoragePrice) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spStoragePrice: object.sp_storage_price ? types_1.SpStoragePrice.fromSDK(object.sp_storage_price) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.spStoragePrice !== undefined && (obj.sp_storage_price = message.spStoragePrice ? types_1.SpStoragePrice.toSDK(message.spStoragePrice) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryGetSecondarySpStorePriceByTimeRequest() {
	    return {
	        timestamp: helpers_1.Long.ZERO
	    };
	}
	exports.QueryGetSecondarySpStorePriceByTimeRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (!message.timestamp.isZero()) {
	            writer.uint32(8).int64(message.timestamp);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetSecondarySpStorePriceByTimeRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.timestamp = reader.int64();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            timestamp: (0, helpers_1.isSet)(object.timestamp) ? helpers_1.Long.fromValue(object.timestamp) : helpers_1.Long.ZERO
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || helpers_1.Long.ZERO).toString());
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetSecondarySpStorePriceByTimeRequest();
	        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? helpers_1.Long.fromValue(object.timestamp) : helpers_1.Long.ZERO;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            timestamp: object?.timestamp
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.timestamp = message.timestamp;
	        return obj;
	    }
	};
	function createBaseQueryGetSecondarySpStorePriceByTimeResponse() {
	    return {
	        secondarySpStorePrice: undefined
	    };
	}
	exports.QueryGetSecondarySpStorePriceByTimeResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.secondarySpStorePrice !== undefined) {
	            types_1.SecondarySpStorePrice.encode(message.secondarySpStorePrice, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryGetSecondarySpStorePriceByTimeResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.secondarySpStorePrice = types_1.SecondarySpStorePrice.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            secondarySpStorePrice: (0, helpers_1.isSet)(object.secondarySpStorePrice) ? types_1.SecondarySpStorePrice.fromJSON(object.secondarySpStorePrice) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.secondarySpStorePrice !== undefined && (obj.secondarySpStorePrice = message.secondarySpStorePrice ? types_1.SecondarySpStorePrice.toJSON(message.secondarySpStorePrice) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryGetSecondarySpStorePriceByTimeResponse();
	        message.secondarySpStorePrice = object.secondarySpStorePrice !== undefined && object.secondarySpStorePrice !== null ? types_1.SecondarySpStorePrice.fromPartial(object.secondarySpStorePrice) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            secondarySpStorePrice: object.secondary_sp_store_price ? types_1.SecondarySpStorePrice.fromSDK(object.secondary_sp_store_price) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.secondarySpStorePrice !== undefined && (obj.secondary_sp_store_price = message.secondarySpStorePrice ? types_1.SecondarySpStorePrice.toSDK(message.secondarySpStorePrice) : undefined);
	        return obj;
	    }
	};
	function createBaseQueryStorageProviderRequest() {
	    return {
	        spAddress: ""
	    };
	}
	exports.QueryStorageProviderRequest = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spAddress !== "") {
	            writer.uint32(10).string(message.spAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryStorageProviderRequest();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryStorageProviderRequest();
	        message.spAddress = object.spAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spAddress: object?.spAddress
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.spAddress = message.spAddress;
	        return obj;
	    }
	};
	function createBaseQueryStorageProviderResponse() {
	    return {
	        storageProvider: undefined
	    };
	}
	exports.QueryStorageProviderResponse = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.storageProvider !== undefined) {
	            types_1.StorageProvider.encode(message.storageProvider, writer.uint32(10).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseQueryStorageProviderResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.storageProvider = types_1.StorageProvider.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            storageProvider: (0, helpers_1.isSet)(object.storageProvider) ? types_1.StorageProvider.fromJSON(object.storageProvider) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.storageProvider !== undefined && (obj.storageProvider = message.storageProvider ? types_1.StorageProvider.toJSON(message.storageProvider) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseQueryStorageProviderResponse();
	        message.storageProvider = object.storageProvider !== undefined && object.storageProvider !== null ? types_1.StorageProvider.fromPartial(object.storageProvider) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            storageProvider: object.storageProvider ? types_1.StorageProvider.fromSDK(object.storageProvider) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        message.storageProvider !== undefined && (obj.storageProvider = message.storageProvider ? types_1.StorageProvider.toSDK(message.storageProvider) : undefined);
	        return obj;
	    }
	};
	class QueryClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.Params = this.Params.bind(this);
	        this.StorageProviders = this.StorageProviders.bind(this);
	        this.QueryGetSpStoragePriceByTime = this.QueryGetSpStoragePriceByTime.bind(this);
	        this.QueryGetSecondarySpStorePriceByTime = this.QueryGetSecondarySpStorePriceByTime.bind(this);
	        this.StorageProvider = this.StorageProvider.bind(this);
	    }
	    Params(request = {}) {
	        const data = exports.QueryParamsRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Query", "Params", data);
	        return promise.then(data => exports.QueryParamsResponse.decode(new _m0.Reader(data)));
	    }
	    StorageProviders(request = {
	        pagination: undefined
	    }) {
	        const data = exports.QueryStorageProvidersRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Query", "StorageProviders", data);
	        return promise.then(data => exports.QueryStorageProvidersResponse.decode(new _m0.Reader(data)));
	    }
	    QueryGetSpStoragePriceByTime(request) {
	        const data = exports.QueryGetSpStoragePriceByTimeRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Query", "QueryGetSpStoragePriceByTime", data);
	        return promise.then(data => exports.QueryGetSpStoragePriceByTimeResponse.decode(new _m0.Reader(data)));
	    }
	    QueryGetSecondarySpStorePriceByTime(request) {
	        const data = exports.QueryGetSecondarySpStorePriceByTimeRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Query", "QueryGetSecondarySpStorePriceByTime", data);
	        return promise.then(data => exports.QueryGetSecondarySpStorePriceByTimeResponse.decode(new _m0.Reader(data)));
	    }
	    StorageProvider(request) {
	        const data = exports.QueryStorageProviderRequest.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Query", "StorageProvider", data);
	        return promise.then(data => exports.QueryStorageProviderResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.QueryClientImpl = QueryClientImpl;
	
} (query));

query.default;

var tx = {};

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgUpdateSpStoragePriceResponse = exports.MsgUpdateSpStoragePrice = exports.MsgEditStorageProviderResponse = exports.MsgEditStorageProvider = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgCreateStorageProviderResponse = exports.MsgCreateStorageProvider = exports.protobufPackage = void 0;
	/* eslint-disable */
	const types_1 = types;
	const coin_1 = coin;
	const params_1 = params;
	const helpers_1 = helpers;
	const _m0 = __importStar(minimal$1.exports);
	exports.protobufPackage = "greenfield.sp";
	function createBaseMsgCreateStorageProvider() {
	    return {
	        creator: "",
	        description: undefined,
	        spAddress: "",
	        fundingAddress: "",
	        sealAddress: "",
	        approvalAddress: "",
	        gcAddress: "",
	        endpoint: "",
	        deposit: undefined,
	        readPrice: "",
	        freeReadQuota: helpers_1.Long.UZERO,
	        storePrice: ""
	    };
	}
	exports.MsgCreateStorageProvider = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        if (message.description !== undefined) {
	            types_1.Description.encode(message.description, writer.uint32(18).fork()).ldelim();
	        }
	        if (message.spAddress !== "") {
	            writer.uint32(26).string(message.spAddress);
	        }
	        if (message.fundingAddress !== "") {
	            writer.uint32(34).string(message.fundingAddress);
	        }
	        if (message.sealAddress !== "") {
	            writer.uint32(42).string(message.sealAddress);
	        }
	        if (message.approvalAddress !== "") {
	            writer.uint32(50).string(message.approvalAddress);
	        }
	        if (message.gcAddress !== "") {
	            writer.uint32(58).string(message.gcAddress);
	        }
	        if (message.endpoint !== "") {
	            writer.uint32(66).string(message.endpoint);
	        }
	        if (message.deposit !== undefined) {
	            coin_1.Coin.encode(message.deposit, writer.uint32(74).fork()).ldelim();
	        }
	        if (message.readPrice !== "") {
	            writer.uint32(82).string(message.readPrice);
	        }
	        if (!message.freeReadQuota.isZero()) {
	            writer.uint32(88).uint64(message.freeReadQuota);
	        }
	        if (message.storePrice !== "") {
	            writer.uint32(98).string(message.storePrice);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateStorageProvider();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                case 2:
	                    message.description = types_1.Description.decode(reader, reader.uint32());
	                    break;
	                case 3:
	                    message.spAddress = reader.string();
	                    break;
	                case 4:
	                    message.fundingAddress = reader.string();
	                    break;
	                case 5:
	                    message.sealAddress = reader.string();
	                    break;
	                case 6:
	                    message.approvalAddress = reader.string();
	                    break;
	                case 7:
	                    message.gcAddress = reader.string();
	                    break;
	                case 8:
	                    message.endpoint = reader.string();
	                    break;
	                case 9:
	                    message.deposit = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                case 10:
	                    message.readPrice = reader.string();
	                    break;
	                case 11:
	                    message.freeReadQuota = reader.uint64();
	                    break;
	                case 12:
	                    message.storePrice = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
	            description: (0, helpers_1.isSet)(object.description) ? types_1.Description.fromJSON(object.description) : undefined,
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
	            fundingAddress: (0, helpers_1.isSet)(object.fundingAddress) ? String(object.fundingAddress) : "",
	            sealAddress: (0, helpers_1.isSet)(object.sealAddress) ? String(object.sealAddress) : "",
	            approvalAddress: (0, helpers_1.isSet)(object.approvalAddress) ? String(object.approvalAddress) : "",
	            gcAddress: (0, helpers_1.isSet)(object.gcAddress) ? String(object.gcAddress) : "",
	            endpoint: (0, helpers_1.isSet)(object.endpoint) ? String(object.endpoint) : "",
	            deposit: (0, helpers_1.isSet)(object.deposit) ? coin_1.Coin.fromJSON(object.deposit) : undefined,
	            readPrice: (0, helpers_1.isSet)(object.readPrice) ? String(object.readPrice) : "",
	            freeReadQuota: (0, helpers_1.isSet)(object.freeReadQuota) ? helpers_1.Long.fromValue(object.freeReadQuota) : helpers_1.Long.UZERO,
	            storePrice: (0, helpers_1.isSet)(object.storePrice) ? String(object.storePrice) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        message.description !== undefined && (obj.description = message.description ? types_1.Description.toJSON(message.description) : undefined);
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        message.fundingAddress !== undefined && (obj.fundingAddress = message.fundingAddress);
	        message.sealAddress !== undefined && (obj.sealAddress = message.sealAddress);
	        message.approvalAddress !== undefined && (obj.approvalAddress = message.approvalAddress);
	        message.gcAddress !== undefined && (obj.gcAddress = message.gcAddress);
	        message.endpoint !== undefined && (obj.endpoint = message.endpoint);
	        message.deposit !== undefined && (obj.deposit = message.deposit ? coin_1.Coin.toJSON(message.deposit) : undefined);
	        message.readPrice !== undefined && (obj.readPrice = message.readPrice);
	        message.freeReadQuota !== undefined && (obj.freeReadQuota = (message.freeReadQuota || helpers_1.Long.UZERO).toString());
	        message.storePrice !== undefined && (obj.storePrice = message.storePrice);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgCreateStorageProvider();
	        message.creator = object.creator ?? "";
	        message.description = object.description !== undefined && object.description !== null ? types_1.Description.fromPartial(object.description) : undefined;
	        message.spAddress = object.spAddress ?? "";
	        message.fundingAddress = object.fundingAddress ?? "";
	        message.sealAddress = object.sealAddress ?? "";
	        message.approvalAddress = object.approvalAddress ?? "";
	        message.gcAddress = object.gcAddress ?? "";
	        message.endpoint = object.endpoint ?? "";
	        message.deposit = object.deposit !== undefined && object.deposit !== null ? coin_1.Coin.fromPartial(object.deposit) : undefined;
	        message.readPrice = object.readPrice ?? "";
	        message.freeReadQuota = object.freeReadQuota !== undefined && object.freeReadQuota !== null ? helpers_1.Long.fromValue(object.freeReadQuota) : helpers_1.Long.UZERO;
	        message.storePrice = object.storePrice ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator,
	            description: object.description ? types_1.Description.fromSDK(object.description) : undefined,
	            spAddress: object?.sp_address,
	            fundingAddress: object?.funding_address,
	            sealAddress: object?.seal_address,
	            approvalAddress: object?.approval_address,
	            gcAddress: object?.gc_address,
	            endpoint: object?.endpoint,
	            deposit: object.deposit ? coin_1.Coin.fromSDK(object.deposit) : undefined,
	            readPrice: object?.read_price,
	            freeReadQuota: object?.free_read_quota,
	            storePrice: object?.store_price
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        message.description !== undefined && (obj.description = message.description ? types_1.Description.toSDK(message.description) : undefined);
	        obj.sp_address = message.spAddress;
	        obj.funding_address = message.fundingAddress;
	        obj.seal_address = message.sealAddress;
	        obj.approval_address = message.approvalAddress;
	        obj.gc_address = message.gcAddress;
	        obj.endpoint = message.endpoint;
	        message.deposit !== undefined && (obj.deposit = message.deposit ? coin_1.Coin.toSDK(message.deposit) : undefined);
	        obj.read_price = message.readPrice;
	        obj.free_read_quota = message.freeReadQuota;
	        obj.store_price = message.storePrice;
	        return obj;
	    }
	};
	function createBaseMsgCreateStorageProviderResponse() {
	    return {};
	}
	exports.MsgCreateStorageProviderResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgCreateStorageProviderResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgCreateStorageProviderResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgDeposit() {
	    return {
	        creator: "",
	        spAddress: "",
	        deposit: undefined
	    };
	}
	exports.MsgDeposit = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.creator !== "") {
	            writer.uint32(10).string(message.creator);
	        }
	        if (message.spAddress !== "") {
	            writer.uint32(18).string(message.spAddress);
	        }
	        if (message.deposit !== undefined) {
	            coin_1.Coin.encode(message.deposit, writer.uint32(26).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDeposit();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.creator = reader.string();
	                    break;
	                case 2:
	                    message.spAddress = reader.string();
	                    break;
	                case 3:
	                    message.deposit = coin_1.Coin.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
	            deposit: (0, helpers_1.isSet)(object.deposit) ? coin_1.Coin.fromJSON(object.deposit) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.creator !== undefined && (obj.creator = message.creator);
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        message.deposit !== undefined && (obj.deposit = message.deposit ? coin_1.Coin.toJSON(message.deposit) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgDeposit();
	        message.creator = object.creator ?? "";
	        message.spAddress = object.spAddress ?? "";
	        message.deposit = object.deposit !== undefined && object.deposit !== null ? coin_1.Coin.fromPartial(object.deposit) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            creator: object?.creator,
	            spAddress: object?.sp_address,
	            deposit: object.deposit ? coin_1.Coin.fromSDK(object.deposit) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.creator = message.creator;
	        obj.sp_address = message.spAddress;
	        message.deposit !== undefined && (obj.deposit = message.deposit ? coin_1.Coin.toSDK(message.deposit) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgDepositResponse() {
	    return {};
	}
	exports.MsgDepositResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgDepositResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgDepositResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgEditStorageProvider() {
	    return {
	        spAddress: "",
	        endpoint: "",
	        description: undefined,
	        sealAddress: "",
	        approvalAddress: "",
	        gcAddress: ""
	    };
	}
	exports.MsgEditStorageProvider = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spAddress !== "") {
	            writer.uint32(10).string(message.spAddress);
	        }
	        if (message.endpoint !== "") {
	            writer.uint32(18).string(message.endpoint);
	        }
	        if (message.description !== undefined) {
	            types_1.Description.encode(message.description, writer.uint32(26).fork()).ldelim();
	        }
	        if (message.sealAddress !== "") {
	            writer.uint32(34).string(message.sealAddress);
	        }
	        if (message.approvalAddress !== "") {
	            writer.uint32(42).string(message.approvalAddress);
	        }
	        if (message.gcAddress !== "") {
	            writer.uint32(50).string(message.gcAddress);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgEditStorageProvider();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spAddress = reader.string();
	                    break;
	                case 2:
	                    message.endpoint = reader.string();
	                    break;
	                case 3:
	                    message.description = types_1.Description.decode(reader, reader.uint32());
	                    break;
	                case 4:
	                    message.sealAddress = reader.string();
	                    break;
	                case 5:
	                    message.approvalAddress = reader.string();
	                    break;
	                case 6:
	                    message.gcAddress = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
	            endpoint: (0, helpers_1.isSet)(object.endpoint) ? String(object.endpoint) : "",
	            description: (0, helpers_1.isSet)(object.description) ? types_1.Description.fromJSON(object.description) : undefined,
	            sealAddress: (0, helpers_1.isSet)(object.sealAddress) ? String(object.sealAddress) : "",
	            approvalAddress: (0, helpers_1.isSet)(object.approvalAddress) ? String(object.approvalAddress) : "",
	            gcAddress: (0, helpers_1.isSet)(object.gcAddress) ? String(object.gcAddress) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        message.endpoint !== undefined && (obj.endpoint = message.endpoint);
	        message.description !== undefined && (obj.description = message.description ? types_1.Description.toJSON(message.description) : undefined);
	        message.sealAddress !== undefined && (obj.sealAddress = message.sealAddress);
	        message.approvalAddress !== undefined && (obj.approvalAddress = message.approvalAddress);
	        message.gcAddress !== undefined && (obj.gcAddress = message.gcAddress);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgEditStorageProvider();
	        message.spAddress = object.spAddress ?? "";
	        message.endpoint = object.endpoint ?? "";
	        message.description = object.description !== undefined && object.description !== null ? types_1.Description.fromPartial(object.description) : undefined;
	        message.sealAddress = object.sealAddress ?? "";
	        message.approvalAddress = object.approvalAddress ?? "";
	        message.gcAddress = object.gcAddress ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spAddress: object?.sp_address,
	            endpoint: object?.endpoint,
	            description: object.description ? types_1.Description.fromSDK(object.description) : undefined,
	            sealAddress: object?.seal_address,
	            approvalAddress: object?.approval_address,
	            gcAddress: object?.gc_address
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sp_address = message.spAddress;
	        obj.endpoint = message.endpoint;
	        message.description !== undefined && (obj.description = message.description ? types_1.Description.toSDK(message.description) : undefined);
	        obj.seal_address = message.sealAddress;
	        obj.approval_address = message.approvalAddress;
	        obj.gc_address = message.gcAddress;
	        return obj;
	    }
	};
	function createBaseMsgEditStorageProviderResponse() {
	    return {};
	}
	exports.MsgEditStorageProviderResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgEditStorageProviderResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgEditStorageProviderResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateSpStoragePrice() {
	    return {
	        spAddress: "",
	        readPrice: "",
	        freeReadQuota: helpers_1.Long.UZERO,
	        storePrice: ""
	    };
	}
	exports.MsgUpdateSpStoragePrice = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.spAddress !== "") {
	            writer.uint32(10).string(message.spAddress);
	        }
	        if (message.readPrice !== "") {
	            writer.uint32(18).string(message.readPrice);
	        }
	        if (!message.freeReadQuota.isZero()) {
	            writer.uint32(24).uint64(message.freeReadQuota);
	        }
	        if (message.storePrice !== "") {
	            writer.uint32(34).string(message.storePrice);
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateSpStoragePrice();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.spAddress = reader.string();
	                    break;
	                case 2:
	                    message.readPrice = reader.string();
	                    break;
	                case 3:
	                    message.freeReadQuota = reader.uint64();
	                    break;
	                case 4:
	                    message.storePrice = reader.string();
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
	            readPrice: (0, helpers_1.isSet)(object.readPrice) ? String(object.readPrice) : "",
	            freeReadQuota: (0, helpers_1.isSet)(object.freeReadQuota) ? helpers_1.Long.fromValue(object.freeReadQuota) : helpers_1.Long.UZERO,
	            storePrice: (0, helpers_1.isSet)(object.storePrice) ? String(object.storePrice) : ""
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
	        message.readPrice !== undefined && (obj.readPrice = message.readPrice);
	        message.freeReadQuota !== undefined && (obj.freeReadQuota = (message.freeReadQuota || helpers_1.Long.UZERO).toString());
	        message.storePrice !== undefined && (obj.storePrice = message.storePrice);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateSpStoragePrice();
	        message.spAddress = object.spAddress ?? "";
	        message.readPrice = object.readPrice ?? "";
	        message.freeReadQuota = object.freeReadQuota !== undefined && object.freeReadQuota !== null ? helpers_1.Long.fromValue(object.freeReadQuota) : helpers_1.Long.UZERO;
	        message.storePrice = object.storePrice ?? "";
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            spAddress: object?.sp_address,
	            readPrice: object?.read_price,
	            freeReadQuota: object?.free_read_quota,
	            storePrice: object?.store_price
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.sp_address = message.spAddress;
	        obj.read_price = message.readPrice;
	        obj.free_read_quota = message.freeReadQuota;
	        obj.store_price = message.storePrice;
	        return obj;
	    }
	};
	function createBaseMsgUpdateSpStoragePriceResponse() {
	    return {};
	}
	exports.MsgUpdateSpStoragePriceResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateSpStoragePriceResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateSpStoragePriceResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	function createBaseMsgUpdateParams() {
	    return {
	        authority: "",
	        params: undefined
	    };
	}
	exports.MsgUpdateParams = {
	    encode(message, writer = _m0.Writer.create()) {
	        if (message.authority !== "") {
	            writer.uint32(10).string(message.authority);
	        }
	        if (message.params !== undefined) {
	            params_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
	        }
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParams();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                case 1:
	                    message.authority = reader.string();
	                    break;
	                case 2:
	                    message.params = params_1.Params.decode(reader, reader.uint32());
	                    break;
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(object) {
	        return {
	            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
	            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
	        };
	    },
	    toJSON(message) {
	        const obj = {};
	        message.authority !== undefined && (obj.authority = message.authority);
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
	        return obj;
	    },
	    fromPartial(object) {
	        const message = createBaseMsgUpdateParams();
	        message.authority = object.authority ?? "";
	        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
	        return message;
	    },
	    fromSDK(object) {
	        return {
	            authority: object?.authority,
	            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
	        };
	    },
	    toSDK(message) {
	        const obj = {};
	        obj.authority = message.authority;
	        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
	        return obj;
	    }
	};
	function createBaseMsgUpdateParamsResponse() {
	    return {};
	}
	exports.MsgUpdateParamsResponse = {
	    encode(_, writer = _m0.Writer.create()) {
	        return writer;
	    },
	    decode(input, length) {
	        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
	        let end = length === undefined ? reader.len : reader.pos + length;
	        const message = createBaseMsgUpdateParamsResponse();
	        while (reader.pos < end) {
	            const tag = reader.uint32();
	            switch (tag >>> 3) {
	                default:
	                    reader.skipType(tag & 7);
	                    break;
	            }
	        }
	        return message;
	    },
	    fromJSON(_) {
	        return {};
	    },
	    toJSON(_) {
	        const obj = {};
	        return obj;
	    },
	    fromPartial(_) {
	        const message = createBaseMsgUpdateParamsResponse();
	        return message;
	    },
	    fromSDK(_) {
	        return {};
	    },
	    toSDK(_) {
	        const obj = {};
	        return obj;
	    }
	};
	class MsgClientImpl {
	    constructor(rpc) {
	        this.rpc = rpc;
	        this.CreateStorageProvider = this.CreateStorageProvider.bind(this);
	        this.Deposit = this.Deposit.bind(this);
	        this.EditStorageProvider = this.EditStorageProvider.bind(this);
	        this.UpdateSpStoragePrice = this.UpdateSpStoragePrice.bind(this);
	        this.UpdateParams = this.UpdateParams.bind(this);
	    }
	    CreateStorageProvider(request) {
	        const data = exports.MsgCreateStorageProvider.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Msg", "CreateStorageProvider", data);
	        return promise.then(data => exports.MsgCreateStorageProviderResponse.decode(new _m0.Reader(data)));
	    }
	    Deposit(request) {
	        const data = exports.MsgDeposit.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Msg", "Deposit", data);
	        return promise.then(data => exports.MsgDepositResponse.decode(new _m0.Reader(data)));
	    }
	    EditStorageProvider(request) {
	        const data = exports.MsgEditStorageProvider.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Msg", "EditStorageProvider", data);
	        return promise.then(data => exports.MsgEditStorageProviderResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateSpStoragePrice(request) {
	        const data = exports.MsgUpdateSpStoragePrice.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Msg", "UpdateSpStoragePrice", data);
	        return promise.then(data => exports.MsgUpdateSpStoragePriceResponse.decode(new _m0.Reader(data)));
	    }
	    UpdateParams(request) {
	        const data = exports.MsgUpdateParams.encode(request).finish();
	        const promise = this.rpc.request("greenfield.sp.Msg", "UpdateParams", data);
	        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
	    }
	}
	exports.MsgClientImpl = MsgClientImpl;
	
} (tx));

tx.default;

class Sp extends Account {
    getStorageProviders() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query.QueryClientImpl(rpcClient);
            const res = yield rpc.StorageProviders();
            return res.sps;
        });
    }
    getStorageProviderInfo(spAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query.QueryClientImpl(rpcClient);
            const res = yield rpc.StorageProvider({
                spAddress,
            });
            return res.storageProvider;
        });
    }
    getStoragePriceByTime(spAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query.QueryClientImpl(rpcClient);
            const res = yield rpc.QueryGetSpStoragePriceByTime({
                timestamp: Long__default["default"].fromNumber(0),
                spAddr: spAddress,
            });
            return res.spStoragePrice;
        });
    }
    getSecondarySpStorePrice() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield this.getRpcClient();
            const rpc = new query.QueryClientImpl(rpcClient);
            const res = yield rpc.QueryGetSecondarySpStorePriceByTime({
                timestamp: Long__default["default"].fromNumber(0),
            });
            return res.secondarySpStorePrice;
        });
    }
    updateSpStoragePrice(address, msg, txOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeUrl = '/bnbchain.greenfield.sp.MsgUpdateSpStoragePrice';
            const msgBytes = tx.MsgUpdateSpStoragePrice.encode(msg).finish();
            const accountInfo = yield this.getAccount(address);
            const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
            if (txOption.simulate) {
                return yield this.simulateRawTx(bodyBytes, accountInfo, {
                    denom: txOption.denom,
                });
            }
            const rawTxBytes = yield this.getRawTxBytes(typeUrl, MsgUpdateSpStoragePriceSDKTypeEIP712, tx.MsgUpdateSpStoragePrice.toSDK(msg), bodyBytes, accountInfo, {
                denom: txOption.denom,
                gasLimit: txOption.gasLimit,
                gasPrice: txOption.gasPrice,
                payer: accountInfo.address,
                granter: '',
            });
            return yield this.broadcastRawTx(rawTxBytes);
        });
    }
}

class Client {
    static create(rpcUrl, chainId) {
        const account = new Account(rpcUrl, chainId);
        const basic = new Basic(rpcUrl, chainId);
        const bucket = new Bucket(rpcUrl, chainId);
        const challenge = new Challenge(rpcUrl, chainId);
        const crosschain = new CrossChain(rpcUrl, chainId);
        const distribution = new Distribution(rpcUrl, chainId);
        const group = new Group(rpcUrl, chainId);
        const object = new Object$1(rpcUrl, chainId, bucket);
        const payment = new Payment(rpcUrl, chainId);
        const sp = new Sp(rpcUrl, chainId);
        return new Client(account, basic, bucket, challenge, crosschain, distribution, group, object, payment, sp);
    }
    constructor(account, basic, bucket, challenge, crosschain, distribution, group, object, payment, sp) {
        this.account = account;
        this.basic = basic;
        this.bucket = bucket;
        this.challenge = challenge;
        this.crosschain = crosschain;
        this.distribution = distribution;
        this.group = group;
        this.object = object;
        this.payment = payment;
        this.sp = sp;
    }
}

const MsgSendSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from_address"
    },
    {
      "type": "string",
      "name": "to_address"
    },
    {
      "type": "TypeAmount[]",
      "name": "amount"
    }
  ]
};

class BaseTx {
    constructor(rpcUrl, chainId, txType) {
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = txType;
    }
    broadcastTx(txRawBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield stargate.StargateClient.connect(this.rpcUrl);
            if (!BaseTx.client) {
                BaseTx.client = client;
            }
            return yield client.broadcastTx(txRawBytes);
        });
    }
    getSignture(sign) {
        return Uint8Array.from(util.toBuffer(sign));
    }
    simulateTx(txBodyBytes, authInfoBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield makeRpcClient(this.rpcUrl);
            const rpc = new service.ServiceClientImpl(rpcClient);
            const tx = tx$6.Tx.fromPartial({
                authInfo: tx$6.AuthInfo.decode(authInfoBytes),
                body: tx$6.TxBody.decode(txBodyBytes),
                signatures: [Uint8Array.from([])],
            });
            const request = service.SimulateRequest.fromPartial({
                txBytes: tx$6.Tx.encode(tx).finish(),
            });
            return rpc.Simulate(request);
        });
    }
}

const TYPE_URL$1 = '/cosmos.bank.v1beta1.MsgSend';
class TransferTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, TYPE_URL$1);
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = TYPE_URL$1;
    }
    getRawTxInfo({ sequence, sign, pubKey, from, to, amount, gasLimit, denom, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bodyBytes = this.getSimulateBytes({ from, to, amount, denom });
            const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
            const signtureFromWallet = this.getSignture(sign);
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [signtureFromWallet],
            });
            const txRawBytes = tx$6.TxRaw.encode(txRaw).finish();
            return {
                bytes: txRawBytes,
                hex: util.bufferToHex(Buffer.from(txRawBytes)),
            };
        });
    }
    getSimulateBytes({ from, to, amount, denom, }) {
        const message = tx$8.MsgSend.fromPartial({
            amount: [
                {
                    amount,
                    denom,
                },
            ],
            fromAddress: from,
            toAddress: to,
        });
        const messageBytes = tx$8.MsgSend.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
    signTx({ from, to, sequence, accountNumber, amount, denom, gasLimit, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
            const msg = tx$8.MsgSend.toSDK({
                amount: [
                    {
                        amount,
                        denom,
                    },
                ],
                fromAddress: from,
                toAddress: to,
            });
            const wrapperMsg = typeWrapper(TYPE_URL$1, msg);
            const types = generateTypes(MsgSendSDKTypeEIP712);
            const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, wrapperMsg, '0');
            const eip712 = createEIP712(types, this.chainId, messages);
            return yield sign712Tx(from, JSON.stringify(eip712));
        });
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                denom,
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

const MsgTransferOutSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "TypeAmount",
      "name": "amount"
    }
  ]
};

const TYPE_URL = '/bnbchain.greenfield.bridge.MsgTransferOut';
class TransferOutTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, TYPE_URL);
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = TYPE_URL;
    }
    getRawTxInfo({ sequence, sign, pubKey, from, to, amount, denom, gasLimit, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bodyBytes = this.getSimulateBytes({ from, to, amount, denom });
            const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
            const signtureFromWallet = this.getSignture(sign);
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [signtureFromWallet],
            });
            const txRawBytes = tx$6.TxRaw.encode(txRaw).finish();
            return {
                bytes: txRawBytes,
                hex: util.bufferToHex(Buffer.from(txRawBytes)),
            };
        });
    }
    getSimulateBytes({ from, to, amount, denom, }) {
        const payload = {
            from,
            to,
            amount: {
                amount,
                denom,
            },
        };
        const message = tx$2.MsgTransferOut.fromJSON(payload);
        const messageBytes = tx$2.MsgTransferOut.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
    signTx({ from, to, sequence, accountNumber, amount, denom, gasLimit, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
            // const msg = newMsgTransferOut(amount, denom, from, to);
            const msg = tx$2.MsgTransferOut.fromSDK({
                from,
                to,
                amount: {
                    amount,
                    denom,
                },
            });
            const wrappedMsg = typeWrapper(TYPE_URL, msg);
            const types = generateTypes(MsgTransferOutSDKTypeEIP712);
            const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, wrappedMsg, '0');
            const eip712 = createEIP712(types, this.chainId, messages);
            return yield sign712Tx(from, JSON.stringify(eip712));
        });
    }
    simulateRelayFee() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcClient = yield makeRpcClient(this.rpcUrl);
            const rpc = new query$3.QueryClientImpl(rpcClient);
            const data = query$3.QueryParamsRequest.encode({}).finish();
            return rpc.Params(data);
        });
    }
}

class CreateBucketTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgCreateBucket');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgCreateBucket';
    }
    signTx({ bucketName, from, sequence, primarySpAddress, denom, accountNumber, expiredHeight, chargedReadQuota, sig, visibility, gasLimit, gasPrice, paymentAddress, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
            const msg = newMsgCreateBucket({
                bucketName,
                from,
                expiredHeight,
                visibility,
                paymentAddress,
                primarySpAddress,
                chargedReadQuota,
                sig,
            });
            const types = generateTypes(MsgCreateBucketSDKTypeEIP712);
            const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
            const eip712 = createEIP712(types, this.chainId, messages);
            return yield sign712Tx(from, JSON.stringify(eip712));
        });
    }
    getRawTxInfo({ bucketName, from, sequence, primarySpAddress, denom, expiredHeight, sig, visibility, gasLimit, sign, pubKey, chargedReadQuota, gasPrice, paymentAddress, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bodyBytes = this.getSimulateBytes({
                primarySpAddress,
                from,
                denom,
                bucketName,
                expiredHeight,
                sig,
                visibility,
                chargedReadQuota,
                paymentAddress,
            });
            const authInfoBytes = this.getAuthInfoBytes({ sequence, pubKey, denom, gasLimit, gasPrice });
            const signtureFromWallet = this.getSignture(sign);
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [signtureFromWallet],
            });
            const txRawBytes = tx$6.TxRaw.encode(txRaw).finish();
            return {
                bytes: txRawBytes,
                hex: util.bufferToHex(Buffer.from(txRawBytes)),
            };
        });
    }
    getAuthInfoBytes({ sequence, pubKey, denom, gasLimit, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const bigGasPrice = BigInt(gasPrice);
        const bigGasLimit = BigInt(gasLimit);
        const feeAmount = [
            {
                amount: String(bigGasPrice * bigGasLimit),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
    getSimulateBytes({ from, bucketName, primarySpAddress, expiredHeight, sig, visibility, chargedReadQuota, paymentAddress, }) {
        const message = tx$5.MsgCreateBucket.fromPartial({});
        message.bucketName = bucketName;
        message.chargedReadQuota = chargedReadQuota
            ? Long.fromNumber(0)
            : Long.fromNumber(chargedReadQuota);
        message.creator = from;
        message.visibility = common$3.visibilityTypeFromJSON(visibility);
        message.paymentAddress = paymentAddress;
        message.primarySpAddress = primarySpAddress;
        message.primarySpApproval = {
            expiredHeight: Long.fromString(expiredHeight),
            sig: bytesFromBase64_1(sig),
        };
        const messageBytes = tx$5.MsgCreateBucket.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
}

class DelBucketTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, TYPE_URL$5);
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = TYPE_URL$5;
    }
    signTx({ from, bucketName, accountNumber, sequence, gasLimit, denom, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
            const msg = newMsgDeleteBucket({
                bucketName,
                from,
            });
            const types = generateTypes(MsgDeleteBucketSDKTypeEIP712);
            const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
            const eip712 = createEIP712(types, this.chainId, messages);
            return yield sign712Tx(from, JSON.stringify(eip712));
        });
    }
    getRawTxInfo({ bucketName, from, sequence, gasLimit, sign, pubKey, denom, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bodyBytes = this.getSimulateBytes({
                from,
                bucketName,
            });
            const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
            const signtureFromWallet = this.getSignture(sign);
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [signtureFromWallet],
            });
            const txRawBytes = tx$6.TxRaw.encode(txRaw).finish();
            return {
                bytes: txRawBytes,
                hex: util.bufferToHex(Buffer.from(txRawBytes)),
            };
        });
    }
    getSimulateBytes({ from, bucketName, }) {
        const message = tx$5.MsgDeleteBucket.fromJSON({
            operator: from,
            bucketName,
        });
        const messageBytes = tx$5.MsgDeleteBucket.encode(message).finish();
        const msgDemoWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgDemoWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, denom, gasLimit, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

class CreateObjectTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgCreateObject');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgCreateObject';
    }
    signTx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { accountNumber, bucketName, contentType, denom, expectChecksums, expectSecondarySpAddresses, expiredHeight, from, gasLimit, objectName, payloadSize, redundancyType, sequence, sig, visibility, gasPrice, } = params;
            const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
            const msg = newMsgCreateObject({
                bucketName,
                contentType,
                expectChecksums,
                expectSecondarySpAddresses,
                expiredHeight,
                from,
                objectName,
                payloadSize,
                redundancyType,
                sig,
                visibility,
            });
            const types = generateTypes(MsgCreateObjectSDKTypeEIP712);
            const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
            const eip712 = createEIP712(types, this.chainId, messages);
            return yield sign712Tx(from, JSON.stringify(eip712));
        });
    }
    getRawTxInfo({ bucketName, contentType, denom, expectChecksums, expectSecondarySpAddresses, expiredHeight, from, gasLimit, objectName, payloadSize, pubKey, redundancyType, sequence, sig, sign, visibility, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bodyBytes = this.getSimulateBytes({
                from,
                bucketName,
                expiredHeight,
                sig,
                visibility,
                contentType,
                expectChecksums,
                objectName,
                payloadSize,
                expectSecondarySpAddresses,
                redundancyType,
            });
            const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
            const signtureFromWallet = this.getSignture(sign);
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [signtureFromWallet],
            });
            const txRawBytes = tx$6.TxRaw.encode(txRaw).finish();
            return {
                bytes: txRawBytes,
                hex: util.bufferToHex(Buffer.from(txRawBytes)),
            };
        });
    }
    getSimulateBytes(params) {
        const { from, bucketName, objectName, contentType, visibility, payloadSize, expiredHeight, sig, expectChecksums, expectSecondarySpAddresses, redundancyType, } = params;
        const message = tx$5.MsgCreateObject.fromPartial({
            bucketName,
            objectName,
            contentType,
            payloadSize,
            creator: from,
            expectSecondarySpAddresses,
        });
        message.visibility =
            visibility === undefined ? common$3.visibilityTypeFromJSON(0) : common$3.visibilityTypeFromJSON(visibility);
        message.redundancyType =
            redundancyType === undefined
                ? common$3.redundancyTypeFromJSON(0)
                : common$3.redundancyTypeFromJSON(redundancyType);
        message.primarySpApproval = {
            expiredHeight: Long.fromString(expiredHeight),
            sig: bytesFromBase64_1(sig),
        };
        message.expectChecksums = expectChecksums.map((e) => bytesFromBase64_1(e));
        const messageBytes = tx$5.MsgCreateObject.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

class DelObjectTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgDeleteObject');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgDeleteObject';
    }
    signTx({ bucketName, objectName, from, sequence, accountNumber, gasLimit, denom, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
            const msg = newMsgDeleteObject({
                bucketName,
                from,
                objectName,
            });
            const types = generateTypes(MsgDeleteObjectSDKTypeEIP712);
            const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
            const eip712 = createEIP712(types, this.chainId, messages);
            return yield sign712Tx(from, JSON.stringify(eip712));
        });
    }
    getRawTxInfo({ bucketName, from, sequence, gasLimit, sign, pubKey, objectName, denom, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bodyBytes = this.getSimulateBytes({
                from,
                bucketName,
                objectName,
            });
            const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
            const signtureFromWallet = this.getSignture(sign);
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [signtureFromWallet],
            });
            const txRawBytes = tx$6.TxRaw.encode(txRaw).finish();
            return {
                bytes: txRawBytes,
                hex: util.bufferToHex(Buffer.from(txRawBytes)),
            };
        });
    }
    getSimulateBytes({ from, bucketName, objectName, }) {
        const message = tx$5.MsgDeleteObject.fromJSON({
            operator: from,
            bucketName,
            objectName,
        });
        const messageBytes = tx$5.MsgDeleteObject.encode(message).finish();
        const msgDemoWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgDemoWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

class CancelCreateObjectTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgCancelCreateObject');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgCancelCreateObject';
    }
    signTx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { accountNumber, bucketName, denom, gasLimit, gasPrice, objectName, sequence, from } = params;
            const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
            const msg = newMsgCancelCreateObject({
                bucketName,
                objectName,
                from,
            });
            const types = generateTypes(MsgCancelCreateObjectSDKTypeEIP712);
            const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
            const eip712 = createEIP712(types, this.chainId, messages);
            return yield sign712Tx(from, JSON.stringify(eip712));
        });
    }
    getRawTxInfo({ bucketName, from, sequence, gasLimit, sign, pubKey, objectName, denom, gasPrice, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bodyBytes = this.getSimulateBytes({
                from,
                bucketName,
                objectName,
            });
            const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
            const signtureFromWallet = this.getSignture(sign);
            const txRaw = tx$6.TxRaw.fromPartial({
                bodyBytes,
                authInfoBytes,
                signatures: [signtureFromWallet],
            });
            const txRawBytes = tx$6.TxRaw.encode(txRaw).finish();
            return {
                bytes: txRawBytes,
                hex: util.bufferToHex(Buffer.from(txRawBytes)),
            };
        });
    }
    getSimulateBytes(params) {
        const { from, bucketName, objectName } = params;
        const message = tx$5.MsgCancelCreateObject.fromJSON({
            operator: from,
            bucketName,
            objectName,
        });
        const messageBytes = tx$5.MsgCancelCreateObject.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = tx$6.TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return tx$6.TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasPrice) * BigInt(gasLimit)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = protoSigning.makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

const BucketTypeAbbr = 'b';
const ObjectTypeAbbr = 'o';
const GroupTypeAbbr = 'g';
const newBucketGRN = (bucketName) => {
    return {
        resType: types$2.ResourceType.RESOURCE_TYPE_BUCKET,
        groupOwner: '',
        name: bucketName,
    };
};
const newObjectGRN = (owner, groupName) => {
    return {
        resType: types$2.ResourceType.RESOURCE_TYPE_GROUP,
        groupOwner: owner,
        name: groupName,
    };
};
const GRNToString = (grn) => {
    let res = '';
    switch (grn.resType) {
        case types$2.ResourceType.RESOURCE_TYPE_BUCKET:
            res = `grn:${BucketTypeAbbr}::${grn.name}`;
            break;
        case types$2.ResourceType.RESOURCE_TYPE_OBJECT:
            res = `grn:${ObjectTypeAbbr}::${grn.name}`;
            break;
        case types$2.ResourceType.RESOURCE_TYPE_GROUP:
            res = `grn:${GroupTypeAbbr}:${grn.groupOwner}:${grn.name}`;
            break;
        default:
            return '';
    }
    return res.trim();
};

Object.defineProperty(exports, 'Long', {
    enumerable: true,
    get: function () { return Long__default["default"]; }
});
exports.CancelCreateObjectTx = CancelCreateObjectTx;
exports.Client = Client;
exports.CreateBucketTx = CreateBucketTx;
exports.CreateObjectTx = CreateObjectTx;
exports.DelBucketTx = DelBucketTx;
exports.DelObjectTx = DelObjectTx;
exports.GRNToString = GRNToString;
exports.StorageEnums = common$2;
exports.TYPE_URL = TYPE_URL;
exports.TransferOutTx = TransferOutTx;
exports.TransferTx = TransferTx;
exports.ZERO_PUBKEY = ZERO_PUBKEY;
exports.decodeFromHex = decodeFromHex;
exports.decodeObjectFromHexString = decodeObjectFromHexString;
exports.encodeObjectToHexString = encodeObjectToHexString;
exports.encodeToHex = encodeToHex;
exports.encodeToHexString = encodeToHexString;
exports.generateUrlByBucketName = generateUrlByBucketName;
exports.getGasFeeBySimulate = getGasFeeBySimulate;
exports.isValidAddress = isValidAddress;
exports.isValidBucketName = isValidBucketName;
exports.isValidObjectName = isValidObjectName;
exports.isValidUrl = isValidUrl;
exports.makeCosmsPubKey = makeCosmsPubKey;
exports.newBucketGRN = newBucketGRN;
exports.newObjectGRN = newObjectGRN;
exports.recoverPk = recoverPk;
exports.sign712Tx = sign712Tx;
exports.trimString = trimString;
