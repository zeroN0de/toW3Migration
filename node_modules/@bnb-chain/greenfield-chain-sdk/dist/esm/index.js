import { BaseAccount } from '@bnb-chain/greenfield-cosmos-types/cosmos/auth/v1beta1/auth';
import { QueryClientImpl as QueryClientImpl$1 } from '@bnb-chain/greenfield-cosmos-types/cosmos/auth/v1beta1/query';
import { QueryClientImpl as QueryClientImpl$2 } from '@bnb-chain/greenfield-cosmos-types/cosmos/bank/v1beta1/query';
import { MsgMultiSend, MsgSend } from '@bnb-chain/greenfield-cosmos-types/cosmos/bank/v1beta1/tx';
import { QueryClientImpl } from '@bnb-chain/greenfield-cosmos-types/greenfield/payment/query';
import { MsgCreatePaymentAccount, MsgDeposit, MsgWithdraw, MsgDisableRefund } from '@bnb-chain/greenfield-cosmos-types/greenfield/payment/tx';
import { formatEther } from '@ethersproject/units';
import { ServiceClientImpl } from '@bnb-chain/greenfield-cosmos-types/cosmos/base/tendermint/v1beta1/query';
import { ServiceClientImpl as ServiceClientImpl$1, SimulateRequest } from '@bnb-chain/greenfield-cosmos-types/cosmos/tx/v1beta1/service';
import { Tx, AuthInfo, TxBody, TxRaw } from '@bnb-chain/greenfield-cosmos-types/cosmos/tx/v1beta1/tx';
import { Any } from '@bnb-chain/greenfield-cosmos-types/google/protobuf/any';
import { makeAuthInfoBytes } from '@cosmjs/proto-signing';
import { createProtobufRpcClient, QueryClient, setupAuthExtension, setupAuthzExtension, setupBankExtension, setupDistributionExtension, setupFeegrantExtension, setupGovExtension, setupIbcExtension, setupMintExtension, setupSlashingExtension, setupStakingExtension, setupTxExtension, StargateClient } from '@cosmjs/stargate';
import { toBuffer, bufferToHex } from '@ethereumjs/util';
import { TypedDataUtils, SignTypedDataVersion } from '@metamask/eth-sig-util';
import Long from 'long';
export { default as Long } from 'long';
import { PubKey } from '@bnb-chain/greenfield-cosmos-types/cosmos/crypto/secp256k1/keys';
import { recoverPublicKey, computePublicKey } from '@ethersproject/signing-key';
import { Tendermint34Client } from '@cosmjs/tendermint-rpc';
import { visibilityTypeFromJSON, visibilityTypeToJSON, redundancyTypeToJSON, redundancyTypeFromJSON } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/common';
import * as common from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/common';
export { common as StorageEnums };
import { QueryClientImpl as QueryClientImpl$3 } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/query';
import { MsgCreateBucket, MsgDeleteBucket, MsgUpdateBucketInfo, MsgPutPolicy, MsgDeletePolicy, MsgMirrorGroup, MsgMirrorBucket, MsgMirrorObject, MsgCreateGroup, MsgDeleteGroup, MsgUpdateGroupMember, MsgLeaveGroup, MsgCreateObject, MsgCancelCreateObject, MsgDeleteObject } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/tx';
import { bytesFromBase64, Long as Long$1 } from '@bnb-chain/greenfield-cosmos-types/helpers';
import { QueryClientImpl as QueryClientImpl$4 } from '@bnb-chain/greenfield-cosmos-types/greenfield/challenge/query';
import { MsgSubmit, MsgAttest } from '@bnb-chain/greenfield-cosmos-types/greenfield/challenge/tx';
import { QueryClientImpl as QueryClientImpl$7, QueryParamsRequest } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/query';
import { QueryClientImpl as QueryClientImpl$5 } from '@bnb-chain/greenfield-cosmos-types/cosmos/crosschain/v1/query';
import { QueryClientImpl as QueryClientImpl$6 } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/query';
import { MsgClaim } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/tx';
import { MsgTransferOut } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/tx';
import { MsgClientImpl } from '@bnb-chain/greenfield-cosmos-types/cosmos/distribution/v1beta1/tx';
import { FileHandler } from '@bnb-chain/greenfiled-file-handle';
import { QueryClientImpl as QueryClientImpl$8 } from '@bnb-chain/greenfield-cosmos-types/greenfield/sp/query';
import { MsgUpdateSpStoragePrice } from '@bnb-chain/greenfield-cosmos-types/greenfield/sp/tx';
import { ResourceType } from '@bnb-chain/greenfield-cosmos-types/greenfield/resource/types';

const MsgSendTypeUrl = '/cosmos.bank.v1beta1.MsgSend';
const MsgSendSDKTypeEIP712$1 = {
    Msg: [
        { name: 'type', type: 'string' },
        { name: 'from_address', type: 'string' },
        { name: 'to_address', type: 'string' },
        { name: 'amount', type: 'TypeAmount[]' },
    ],
};

const MsgMultiSendSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from_address"
    },
    {
      "type": "string",
      "name": "to_address"
    },
    {
      "type": "TypeAmount[]",
      "name": "amount"
    },
    {
      "type": "InputSDKType[]",
      "name": "inputs"
    },
    {
      "type": "OutputSDKType[]",
      "name": "outputs"
    }
  ]
};

const MsgCreatePaymentAccountSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

const getGasFeeBySimulate = (simulateTxInfo, denom = 'BNB') => {
    if (!simulateTxInfo.gasInfo)
        throw new Error('gasInfo not found');
    const gasLimit = BigInt(simulateTxInfo.gasInfo?.gasUsed.toNumber());
    const gasPrice = simulateTxInfo.gasInfo?.minGasPrice.replace(denom, '');
    const gasFee = gasLimit * BigInt(gasPrice);
    return {
        gasLimit,
        gasPrice,
        gasFee: formatEther(String(gasFee)),
    };
};

const ZERO_PUBKEY = '0x000000000000000000000000000000000000000000000000000000000000000000';

const createEIP712 = (types, chainId, message) => {
    return {
        types,
        primaryType: 'Tx',
        domain: {
            name: 'Greenfield Tx',
            version: '1.0.0',
            chainId,
            verifyingContract: 'greenfield',
            salt: '0',
        },
        message,
    };
};
const generateMessage = (accountNumber, sequence, chainCosmosId, memo, fee, msg, timeoutHeight) => {
    return {
        account_number: accountNumber,
        chain_id: chainCosmosId,
        sequence,
        memo,
        fee,
        msg,
        timeout_height: timeoutHeight,
    };
};
const generateTypes = (newTypes) => {
    const types = {
        Coin: [
            { name: 'denom', type: 'string' },
            { name: 'amount', type: 'uint256' },
        ],
        EIP712Domain: [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'string' },
            { name: 'salt', type: 'string' },
        ],
        Tx: [
            { name: 'account_number', type: 'uint256' },
            { name: 'chain_id', type: 'uint256' },
            { name: 'fee', type: 'Fee' },
            { name: 'memo', type: 'string' },
            { name: 'msg', type: 'Msg' },
            { name: 'sequence', type: 'uint256' },
            { name: 'timeout_height', type: 'uint256' },
        ],
        Fee: [
            { name: 'amount', type: 'Coin[]' },
            { name: 'gas_limit', type: 'uint256' },
            { name: 'payer', type: 'string' },
            { name: 'granter', type: 'string' },
        ],
        TypeAmount: [
            { name: 'denom', type: 'string' },
            { name: 'amount', type: 'string' },
        ],
    };
    Object.assign(types, newTypes);
    return types;
};
const generateFee = (amount, denom, gas_limit, payer, granter) => {
    return {
        amount: [
            {
                amount,
                denom,
            },
        ],
        gas_limit,
        payer,
        granter,
    };
};

/**
 * @addr wallet address
 * @message sign typed v4 data
 */
const sign712Tx = async (addr, message) => {
    // TODO: eth-sig-utils
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const signature = await window.ethereum?.request({
        method: 'eth_signTypedData_v4',
        params: [addr, message],
    });
    const messageHash = TypedDataUtils.eip712Hash(JSON.parse(message), SignTypedDataVersion.V4);
    return {
        signature,
        messageHash,
    };
};

/**
 * recover public key from signature
 *
 * @messageHash message hash
 * @signature message signature
 *
 * @returns uncompressed public key
 */
const recoverPk = ({ messageHash, signature }) => {
    const uncompressedPubKey = recoverPublicKey(messageHash, signature);
    return computePublicKey(uncompressedPubKey, true);
};
/**
 * @pk compressed public key from signature
 * @return eg. { typeUrl: '/ethermint.crypto.v1.ethsecp256k1.PubKey', value: 'CiEC+hp2uVKio9T7x0goOPyHgwUYiRsZ8MeYUrfRX8MxrzM=' }
 */
const makeCosmsPubKey = (pk) => {
    const pubKey = PubKey.fromPartial({
        key: toBuffer(pk),
    });
    return {
        typeUrl: '/ethermint.crypto.v1.ethsecp256k1.PubKey',
        value: PubKey.encode(pubKey).finish(),
    };
};

const typeWrapper = (type, msg) => {
    return {
        ...msg,
        type,
    };
};

const makeClientWithExtension = async (rpcUrl) => {
    const tmClient = await Tendermint34Client.connect(rpcUrl);
    return [
        QueryClient.withExtensions(tmClient, setupAuthExtension, setupAuthzExtension, setupBankExtension, setupDistributionExtension, setupFeegrantExtension, setupGovExtension, setupIbcExtension, setupMintExtension, setupSlashingExtension, setupStakingExtension, setupTxExtension),
        tmClient,
    ];
};
const makeRpcClient = async (rpcUrl) => {
    const [, tmClient] = await makeClientWithExtension(rpcUrl);
    const rpc = createProtobufRpcClient(new QueryClient(tmClient));
    return rpc;
};
class Basic {
    constructor(rpcUrl, chainId) {
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.rpcClient = null;
        this.queryClient = null;
    }
    async getNodeInfo() {
        const rpcClient = await this.getRpcClient();
        const rpc = new ServiceClientImpl(rpcClient);
        return await rpc.GetNodeInfo();
    }
    async getLatestBlock() {
        const rpcClient = await this.getRpcClient();
        const rpc = new ServiceClientImpl(rpcClient);
        return await rpc.GetLatestBlock();
    }
    async getLatestBlockHeight() {
        const latestBlock = await this.getLatestBlock();
        const height = latestBlock.sdkBlock?.header?.height;
        if (!height)
            return 0;
        return height.toNumber();
    }
    async getSyncing() {
        const rpcClient = await this.getRpcClient();
        const rpc = new ServiceClientImpl(rpcClient);
        const syncing = await rpc.GetSyncing();
        return syncing.syncing;
    }
    async getBlockByHeight(height) {
        const rpcClient = await this.getRpcClient();
        const rpc = new ServiceClientImpl(rpcClient);
        return await rpc.GetBlockByHeight({
            height: Long.fromInt(height),
        });
    }
    async GetLatestValidatorSet(request) {
        const rpcClient = await this.getRpcClient();
        const rpc = new ServiceClientImpl(rpcClient);
        const validatorSet = await rpc.GetLatestValidatorSet(request);
        return validatorSet.blockHeight.toNumber();
    }
    async getRpcClient() {
        if (!this.rpcClient) {
            this.rpcClient = await makeRpcClient(this.rpcUrl);
        }
        return this.rpcClient;
    }
    async simulateRawTx(txBodyBytes, accountInfo, txOption) {
        const rpcClient = await this.getRpcClient();
        const rpc = new ServiceClientImpl$1(rpcClient);
        const { denom } = txOption;
        const authInfoBytes = this.getAuthInfoBytes({
            sequence: accountInfo.sequence + '',
            denom,
            gasLimit: 0,
            gasPrice: '0',
            pubKey: makeCosmsPubKey(ZERO_PUBKEY),
        });
        const tx = Tx.fromPartial({
            authInfo: AuthInfo.decode(authInfoBytes),
            body: TxBody.decode(txBodyBytes),
            signatures: [Uint8Array.from([])],
        });
        const request = SimulateRequest.fromPartial({
            txBytes: Tx.encode(tx).finish(),
        });
        const res = await rpc.Simulate(request);
        return getGasFeeBySimulate(res, txOption.denom);
    }
    async broadcastRawTx(txRawBytes) {
        const client = await StargateClient.connect(this.rpcUrl);
        return await client.broadcastTx(txRawBytes);
    }
    async getQueryClient() {
        if (!this.queryClient) {
            const [client] = await makeClientWithExtension(this.rpcUrl);
            this.queryClient = client;
        }
        return this.queryClient;
    }
    getAuthInfoBytes(params) {
        const { pubKey, denom, sequence, gasLimit, gasPrice } = params;
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                denom,
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
    async getRawTxBytes(typeUrl, msgEIP712Structor, msgEIP712, bodyBytes, accountInfo, txOption) {
        const { denom, gasLimit, gasPrice } = txOption;
        const eip712 = this.getEIP712Struct(typeUrl, msgEIP712Structor, accountInfo.accountNumber + '', accountInfo.sequence + '', this.chainId, msgEIP712, txOption);
        const { signature, pubKey } = await this.signTx(accountInfo.address, JSON.stringify(eip712));
        const authInfoBytes = this.getAuthInfoBytes({
            denom,
            sequence: accountInfo.sequence + '',
            gasLimit,
            gasPrice,
            pubKey,
        });
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [toBuffer(signature)],
        });
        return TxRaw.encode(txRaw).finish();
    }
    getBodyBytes(typeUrl, msgBytes) {
        const msgWrapped = Any.fromPartial({
            typeUrl,
            value: msgBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
    getEIP712Struct(typeUrl, types, accountNumber, sequence, chainId, msg, txOption) {
        const { gasLimit, gasPrice, denom, payer } = txOption;
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), payer, '');
        const wrapperTypes = generateTypes(types);
        const wrapperMsg = typeWrapper(typeUrl, msg);
        const messages = generateMessage(accountNumber, sequence, chainId, '', fee, wrapperMsg, '0');
        return createEIP712(wrapperTypes, chainId, messages);
    }
    async signTx(addr, message) {
        // TODO: provider
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const signature = await window.ethereum?.request({
            method: 'eth_signTypedData_v4',
            params: [addr, message],
        });
        const messageHash = TypedDataUtils.eip712Hash(JSON.parse(message), SignTypedDataVersion.V4);
        const pk = recoverPk({
            signature,
            messageHash,
        });
        const pubKey = makeCosmsPubKey(pk);
        return {
            signature,
            messageHash,
            pubKey,
        };
    }
}

class Account extends Basic {
    async multiTransfer(address, msg, txOption) {
        const typeUrl = '/cosmos.bank.v1beta1.MsgMultiSend';
        const msgBytes = MsgMultiSend.encode(msg).finish();
        const accountInfo = await this.getAccount(address);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgMultiSendSDKTypeEIP712, MsgMultiSend.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async createPaymentAccount(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.payment.MsgCreatePaymentAccount';
        const msgBytes = MsgCreatePaymentAccount.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.creator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgCreatePaymentAccountSDKTypeEIP712, MsgCreatePaymentAccount.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async getPaymentAccountsByOwner(owner) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl(rpcClient);
        return await rpc.GetPaymentAccountsByOwner({
            owner,
        });
    }
    async getModuleAccountByName(name) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$1(rpcClient);
        return rpc.ModuleAccountByName({
            name,
        });
    }
    async getModuleAccounts() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$1(rpcClient);
        return await rpc.ModuleAccounts();
    }
    async getPaymentAccount(request) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl(rpcClient);
        return await rpc.PaymentAccount(request);
    }
    async getAccountBalance(request) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$2(rpcClient);
        return await rpc.Balance(request);
    }
    async getAccount(address) {
        const client = await this.getQueryClient();
        const account = await client.auth.account(address);
        if (!account)
            return BaseAccount.fromJSON({});
        return BaseAccount.toJSON(BaseAccount.decode(account.value));
    }
    async transfer(msg, txOption) {
        const typeUrl = MsgSendTypeUrl;
        const msgBytes = MsgSend.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.fromAddress);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgSendSDKTypeEIP712$1, MsgSend.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
}

const TYPE_URL$6 = '/bnbchain.greenfield.storage.MsgCreateBucket';
const MsgCreateBucketSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'visibility',
            type: 'string',
        },
        {
            name: 'payment_address',
            type: 'string',
        },
        {
            name: 'primary_sp_address',
            type: 'string',
        },
        {
            name: 'primary_sp_approval',
            type: 'TypePrimarySpApproval',
        },
        {
            name: 'charged_read_quota',
            type: 'uint64',
        },
    ],
    TypePrimarySpApproval: [
        {
            name: 'expired_height',
            type: 'uint64',
        },
        {
            name: 'sig',
            type: 'bytes',
        },
    ],
};
const newMsgCreateBucket = ({ bucketName, expiredHeight, from, visibility, paymentAddress, primarySpAddress, chargedReadQuota, sig, }) => {
    return {
        type: TYPE_URL$6,
        bucket_name: bucketName,
        creator: from,
        visibility,
        payment_address: paymentAddress,
        primary_sp_address: primarySpAddress,
        primary_sp_approval: {
            expired_height: expiredHeight,
            sig,
        },
        charged_read_quota: chargedReadQuota,
    };
};

const TYPE_URL$5 = '/bnbchain.greenfield.storage.MsgDeleteBucket';
const MsgDeleteBucketSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
    ],
};
const newMsgDeleteBucket = ({ bucketName, from }) => {
    return {
        type: TYPE_URL$5,
        bucket_name: bucketName,
        operator: from,
    };
};

const toHex = (char = '') => {
    return char.charCodeAt(0).toString(16);
};
const encodeToHex = (str = '') => {
    return str.split('').map(toHex).join('');
};
const decodeFromHex = (hex = '') => {
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
        result.push(String.fromCharCode(parseInt(hex.substr(i, 2), 16)));
    }
    return result.join('');
};
const encodeObjectToHexString = (jsonObject) => {
    const utf8Encoder = new TextEncoder();
    const utf8Bytes = utf8Encoder.encode(JSON.stringify(jsonObject));
    return Array.from(utf8Bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
};
const encodeToHexString = (str = '') => {
    const utf8Encoder = new TextEncoder();
    const utf8Bytes = utf8Encoder.encode(str);
    return Array.from(utf8Bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
};
const hexToBytes = (hex = '') => {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    return bytes;
};
function uint8ArrayToJson(uint8Array) {
    const decoder = new TextDecoder('utf-8');
    const jsonString = decoder.decode(uint8Array);
    return JSON.parse(jsonString);
}
const decodeObjectFromHexString = (hex = '') => {
    return uint8ArrayToJson(hexToBytes(hex));
};

const MOCK_SIGNATURE = '1234567812345678123456781234567812345678123456781234567812345678';
const NORMAL_ERROR_CODE = 404;
const METHOD_GET = 'GET';
const METHOD_PUT = 'PUT';
function timeoutAfter(duration) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('request time out'));
        }, duration);
    });
}
const fetchWithTimeout = async (fetchUrl = '', fetchOptions = {}, duration = 30000) => {
    try {
        const response = await Promise.race([timeoutAfter(duration), fetch(fetchUrl, fetchOptions)]);
        return response;
    }
    catch (error) {
        return Promise.reject(error);
    }
};

const IP_REGEX = /^(\d+\.){3}\d+$/g;
const ALLOW_REGEX = /^[a-z0-9][a-z0-9.\-]{1,61}[a-z0-9]$/g;
const dotdotComponent = '..';
const dotComponent = '.';
const slashSeparator = '/';
const isValidBucketName = (bucketName) => {
    if (!bucketName) {
        throw new Error('Bucket name is empty, please check.');
    }
    const length = bucketName.length;
    if (length < 3 || length > 63) {
        throw new Error(`Bucket name length is required to be between 3~63, please check.`);
    }
    if (bucketName.match(IP_REGEX)) {
        throw new Error('The bucket name %s cannot be formatted as an IP address, please check.');
    }
    if (bucketName.includes('..') || bucketName.includes('.-') || bucketName.includes('-.')) {
        throw new Error('Bucket name contains invalid characters, please check.');
    }
    if (!bucketName.match(ALLOW_REGEX)) {
        throw new Error('Bucket name can only include lowercase letters, numbers, commas and hyphen, please check.');
    }
    if (bucketName[0] === '-' ||
        bucketName[length - 1] === '-' ||
        bucketName[0] === '.' ||
        bucketName[length - 1] === '.') {
        throw new Error('Bucket name %must start and end with a lowercase letter or number, please check.');
    }
    return true;
};
const hasBadPathComponent = (path) => {
    const newPath = path.trim();
    for (const p of newPath.split(slashSeparator)) {
        switch (p.trim()) {
            case dotdotComponent:
            case dotComponent:
                return true;
        }
    }
    return false;
};
const isUTF8 = (str) => {
    try {
        new TextDecoder('utf-8').decode(new TextEncoder().encode(str));
        return true;
    }
    catch {
        return false;
    }
};
const isValidObjectName = (objectName) => {
    if (!objectName) {
        throw new Error('Object name is empty, please check.');
    }
    if (objectName.length > 1024) {
        throw new Error('Object name is limited to 1024 at most, please check.');
    }
    if (hasBadPathComponent(objectName)) {
        throw new Error('Object name error, please check.');
    }
    if (!isUTF8(objectName)) {
        throw new Error('Object name is not in UTF-8 format, please check.');
    }
    if (objectName.includes(`//`)) {
        throw new Error(`Object name that contains a "//" is not supported`);
    }
    return true;
};
const isValidAddress = (address) => {
    if (!address) {
        throw new Error('Address is empty, please check.');
    }
    if (address.length > 1024) {
        throw new Error('Address is limited to 1024 at most, please check.');
    }
    return true;
};
const isValidUrl = (url) => {
    if (!url || url.length === 0)
        return false;
    const pattern = new RegExp('^(https?:\\/\\/)?' + // 协议
        '((([a-zA-Z\\d]([a-zA-Z\\d-]{0,61}[a-zA-Z\\d])?)\\.)+' + // 域名
        '[a-zA-Z]{2,13})' + // 顶级域名
        '(\\:\\d{1,5})?' + // 端口号
        '(\\/[-a-zA-Z\\d%_.~+]*)*' + // 路径
        '(\\?[;&a-zA-Z\\d%_.~+=-]*)?' + // 查询字符串
        '(\\#[-a-zA-Z\\d_]*)?$', 'i'); // 锚点
    return pattern.test(url);
};
// remove specified from prefix and suffix of a string
const trimString = (originString, deleteString) => {
    const delStrLength = deleteString.length;
    if (originString.startsWith(deleteString)) {
        originString = originString.substring(delStrLength);
    }
    if (originString.endsWith(deleteString)) {
        originString = originString.substring(0, originString.length - delStrLength);
    }
    return originString;
};
const generateUrlByBucketName = (endpoint = '', bucketName) => {
    if (!isValidUrl(endpoint)) {
        throw new Error('Invalid endpoint');
    }
    if (!isValidBucketName(bucketName)) ;
    const { protocol } = new URL(endpoint);
    return endpoint.replace(`${protocol}//`, `${protocol}//${bucketName}.`);
};

const MsgDeletePolicySDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgPutPolicySDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgUpdateBucketInfoSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ]
};

class Bucket extends Account {
    // private sp: ISp = new Sp(this.rpcUrl, this.chainId);
    /* private async getRandomSpInfo(): Promise<ISpInfo> {
      const spList = await this.sp.getStorageProviders();
      if (!spList || spList.length === 0) {
        return {} as ISpInfo;
      }
  
      const randomIndex = Math.floor(Math.random() * spList.length);
      const selectSp = spList[randomIndex];
      const secondarySpAddresses = spList
        .filter((_, index) => index !== randomIndex)
        .map((sp) => sp.operatorAddress);
      const { endpoint, operatorAddress, sealAddress } = selectSp;
  
      return {
        endpoint,
        primarySpAddress: operatorAddress,
        sealAddress,
        secondarySpAddresses,
      };
    } */
    async getCreateBucketApproval({ bucketName, creator, visibility = 'VISIBILITY_TYPE_PUBLIC_READ', chargedReadQuota, spInfo, duration, }) {
        try {
            if (!spInfo.primarySpAddress) {
                throw new Error('Primary sp address is missing');
            }
            if (!isValidBucketName(bucketName)) ;
            if (!creator) {
                throw new Error('Empty creator address');
            }
            const endpoint = spInfo.endpoint;
            const msg = {
                bucket_name: bucketName,
                creator,
                visibility,
                primary_sp_address: spInfo.primarySpAddress,
                primary_sp_approval: {
                    expired_height: '0',
                    sig: '',
                },
                charged_read_quota: chargedReadQuota,
                payment_address: '',
            };
            const url = endpoint + '/greenfield/admin/v1/get-approval?action=CreateBucket';
            const unSignedMessageInHex = encodeObjectToHexString(msg);
            const headers = new Headers({
                // TODO: replace when offchain release
                Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${MOCK_SIGNATURE}`,
                'X-Gnfd-Unsigned-Msg': unSignedMessageInHex,
            });
            const result = await fetchWithTimeout(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                return {
                    code: -1,
                    message: 'Get create bucket approval error.',
                    statusCode: status,
                };
            }
            const resultContentType = result.headers.get('Content-Type');
            if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                const xmlText = await result.text();
                const xml = await new window.DOMParser().parseFromString(xmlText, 'text/xml');
                return {
                    code: -1,
                    xml,
                    message: 'Get create bucket approval error.',
                    statusCode: status,
                };
            }
            const signedMsgString = result.headers.get('X-Gnfd-Signed-Msg') || '';
            const signedMsg = decodeObjectFromHexString(signedMsgString);
            return {
                code: 0,
                message: 'Get create bucket approval success.',
                body: signedMsgString,
                statusCode: status,
                signedMsg: signedMsg,
            };
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
        }
    }
    async createBucket(params, txOption) {
        const { signedMsg } = await this.getCreateBucketApproval(params);
        if (!signedMsg) {
            throw new Error('Get create bucket approval error');
        }
        const sig = signedMsg.primary_sp_approval.sig;
        const expiredHeight = signedMsg.primary_sp_approval.expired_height;
        const msg = {
            bucketName: signedMsg.bucket_name,
            creator: signedMsg.creator,
            visibility: visibilityTypeFromJSON(signedMsg.visibility),
            primarySpAddress: signedMsg.primary_sp_address,
            primarySpApproval: {
                expiredHeight: Long.fromString(expiredHeight),
                sig: bytesFromBase64(sig),
            },
            chargedReadQuota: signedMsg.charged_read_quota
                ? Long.fromString('0')
                : Long.fromString(signedMsg.charged_read_quota),
            paymentAddress: '',
        };
        const typeUrl = '/bnbchain.greenfield.storage.MsgCreateBucket';
        const msgBytes = MsgCreateBucket.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.creator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgCreateBucketSDKTypeEIP712, {
            ...signedMsg,
            type: typeUrl,
            charged_read_quota: signedMsg.charged_read_quota,
            visibility: signedMsg.visibility,
            primary_sp_approval: {
                expired_height: expiredHeight,
                sig,
            },
        }, bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async deleteBucket(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgDeleteBucket';
        const msgBytes = MsgDeleteBucket.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgDeleteBucketSDKTypeEIP712, MsgDeleteBucket.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async headBucket(bucketName) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return await rpc.HeadBucket({
            bucketName,
        });
    }
    async headBucketById(bucketId) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return await rpc.HeadBucketById({
            bucketId,
        });
    }
    async getVerifyPermission(bucketName, operator, actionType) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return rpc.VerifyPermission({
            bucketName,
            operator,
            objectName: '',
            actionType,
        });
    }
    async getUserBuckets(configParam) {
        try {
            const { address, duration = 30000, endpoint } = configParam;
            if (!isValidAddress(address)) ;
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            const url = endpoint;
            const signature = MOCK_SIGNATURE;
            const headers = new Headers({
                // todo place the correct authorization string
                Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                'X-Gnfd-User-Address': address,
            });
            const result = await fetchWithTimeout(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                return { code: -1, message: 'Get bucket error.', statusCode: status };
            }
            const { buckets } = await result.json();
            return {
                code: 0,
                message: 'Get bucket success.',
                statusCode: status,
                body: buckets,
            };
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
        }
    }
    async getBucketReadQuota(configParam) {
        try {
            const { bucketName, endpoint, duration = 30000, year, month } = configParam;
            // todo generate real signature
            const signature = MOCK_SIGNATURE;
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            if (!isValidBucketName(bucketName)) ;
            const currentDate = new Date();
            const finalYear = year ? year : currentDate.getFullYear();
            const finalMonth = month ? month : currentDate.getMonth() + 1;
            const formattedMonth = finalMonth.toString().padStart(2, '0'); // format month to 2 digits, like "01"
            const url = generateUrlByBucketName(endpoint, bucketName) +
                `/?read-quota&year-month=${finalYear}-${formattedMonth}`;
            const headers = new Headers({
                Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
            });
            const result = await fetchWithTimeout(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                return { code: -1, message: 'Get Bucket Quota error.', statusCode: status };
            }
            const resultContentType = result.headers.get('Content-Type');
            // Will receive xml when get object met error
            if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                const xmlText = await result.text();
                const xml = await new window.DOMParser().parseFromString(xmlText, 'text/xml');
                const ReadQuotaSize = xml.getElementsByTagName('ReadQuotaSize')[0]
                    .textContent;
                const SPFreeReadQuotaSize = xml.getElementsByTagName('SPFreeReadQuotaSize')[0].textContent;
                const ReadConsumedSize = xml.getElementsByTagName('ReadConsumedSize')[0]
                    .textContent;
                return {
                    code: 0,
                    body: {
                        readQuota: Number(ReadQuotaSize ?? '0'),
                        freeQuota: Number(SPFreeReadQuotaSize ?? '0'),
                        consumedQuota: Number(ReadConsumedSize ?? '0'),
                    },
                    message: 'Get bucket read quota.',
                    statusCode: status,
                };
            }
            else {
                return {
                    code: -1,
                    message: 'Get bucket read quota error.',
                    statusCode: status,
                };
            }
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
        }
    }
    async updateBucketInfo(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgUpdateBucketInfo';
        const msgBytes = MsgUpdateBucketInfo.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgUpdateBucketInfoSDKTypeEIP712, MsgUpdateBucketInfo.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async putBucketPolicy(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgPutPolicy';
        const msgBytes = MsgPutPolicy.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgPutPolicySDKTypeEIP712, MsgPutPolicy.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async deleteBucketPolicy(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgDeletePolicy';
        const msgBytes = MsgDeletePolicy.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgDeletePolicySDKTypeEIP712, MsgDeletePolicy.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
}

const MsgAttestSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "challenger"
    },
    {
      "type": "string",
      "name": "sp_operator_address"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "segment_index"
    },
    {
      "type": "bool",
      "name": "random_index"
    },
    {
      "type": "string",
      "name": "submitter"
    },
    {
      "type": "uint64",
      "name": "challenge_id"
    },
    {
      "type": "string",
      "name": "object_id"
    },
    {
      "type": "string",
      "name": "sp_operator_address"
    },
    {
      "type": "string",
      "name": "vote_result"
    },
    {
      "type": "string",
      "name": "challenger_address"
    },
    {
      "type": "uint64[]",
      "name": "vote_validator_set"
    },
    {
      "type": "bytes",
      "name": "vote_agg_signature"
    }
  ]
};

const MsgSubmitSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "challenger"
    },
    {
      "type": "string",
      "name": "sp_operator_address"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "segment_index"
    },
    {
      "type": "bool",
      "name": "random_index"
    }
  ]
};

class Challenge extends Account {
    async submitChallenge(address, msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.challenge.MsgSubmit';
        const msgBytes = MsgSubmit.encode(msg).finish();
        const accountInfo = await this.getAccount(address);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgSubmitSDKTypeEIP712, MsgSubmit.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async attestChallenge(address, msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.challenge.MsgAttest';
        const msgBytes = MsgAttest.encode(msg).finish();
        const accountInfo = await this.getAccount(address);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgAttestSDKTypeEIP712, MsgAttest.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async latestAttestedChallenges() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$4(rpcClient);
        return await rpc.LatestAttestedChallenges();
    }
    async inturnAttestationSubmitter() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$4(rpcClient);
        return await rpc.InturnAttestationSubmitter();
    }
}

const MsgTransferOutSDKTypeEIP712$1 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'from',
            type: 'string',
        },
        {
            name: 'to',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'TypeAmount',
        },
    ],
};

const MsgClaimSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from_address"
    },
    {
      "type": "uint64",
      "name": "src_chain_id"
    },
    {
      "type": "uint64",
      "name": "dest_chain_id"
    },
    {
      "type": "uint64",
      "name": "sequence"
    },
    {
      "type": "uint64",
      "name": "timestamp"
    },
    {
      "type": "bytes",
      "name": "payload"
    },
    {
      "type": "uint64[]",
      "name": "vote_address_set"
    },
    {
      "type": "bytes",
      "name": "agg_signature"
    }
  ]
};

const MsgMirrorBucketSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgMirrorGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

const MsgMirrorObjectSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "TypeChargedReadQuota",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "StatementSDKType[]",
      "name": "statements"
    },
    {
      "type": "TypeExpirationTime",
      "name": "expiration_time"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "TypePrincipal",
      "name": "principal"
    },
    {
      "type": "string",
      "name": "resource"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "id"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeChargedReadQuota": [
    {
      "type": "uint64",
      "name": "value"
    }
  ],
  "TypePrincipal": [
    {
      "name": "type"
    },
    {
      "type": "string",
      "name": "value"
    }
  ],
  "TypeExpirationTime": [
    {
      "type": "uint64",
      "name": "seconds"
    },
    {
      "type": "uint64",
      "name": "nanos"
    }
  ]
};

class CrossChain extends Account {
    async transferOut(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.bridge.MsgTransferOut';
        const msgBytes = MsgTransferOut.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.from);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgTransferOutSDKTypeEIP712$1, MsgTransferOut.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async claims(msg, txOption) {
        const typeUrl = '/cosmos.oracle.v1.MsgClaim';
        const msgBytes = MsgClaim.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.fromAddress);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgClaimSDKTypeEIP712, MsgClaim.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async getChannelSendSequence(channelId) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$5(rpcClient);
        return await rpc.SendSequence({
            channelId,
        });
    }
    async getChannelReceiveSequence(channelId) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$5(rpcClient);
        return await rpc.ReceiveSequence({
            channelId,
        });
    }
    async getInturnRelayer() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$6(rpcClient);
        return await rpc.InturnRelayer();
    }
    async getCrosschainPackage(channelId, sequence) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$5(rpcClient);
        return await rpc.CrossChainPackage({
            channelId,
            sequence: Long.fromNumber(sequence),
        });
    }
    async mirrorGroup(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgMirrorGroup';
        const msgBytes = MsgMirrorGroup.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgMirrorGroupSDKTypeEIP712, MsgMirrorGroup.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async mirrorBucket(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgMirrorBucket';
        const msgBytes = MsgMirrorBucket.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgMirrorBucketSDKTypeEIP712, MsgMirrorBucket.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async mirrorObject(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgMirrorObject';
        const msgBytes = MsgMirrorObject.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgMirrorObjectSDKTypeEIP712, MsgMirrorObject.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async getParams() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$7(rpcClient);
        return rpc.Params();
    }
}

class Distribution extends Account {
    async setWithdrawAddress(withdrawAddress, delegatorAddress) {
        const rpcCient = await this.getRpcClient();
        const rpc = new MsgClientImpl(rpcCient);
        return await rpc.SetWithdrawAddress({
            withdrawAddress,
            delegatorAddress,
        });
    }
    async withdrawValidatorCommission(validatorAddress) {
        const rpcCient = await this.getRpcClient();
        const rpc = new MsgClientImpl(rpcCient);
        return rpc.WithdrawValidatorCommission({
            validatorAddress,
        });
    }
    async withdrawDelegatorReward(validatorAddress, delegatorAddress) {
        const rpcCient = await this.getRpcClient();
        const rpc = new MsgClientImpl(rpcCient);
        return rpc.WithdrawDelegatorReward({
            delegatorAddress,
            validatorAddress,
        });
    }
    async fundCommunityPoolundComm(amount, depositor) {
        const rpcCient = await this.getRpcClient();
        const rpc = new MsgClientImpl(rpcCient);
        return rpc.FundCommunityPool({
            amount,
            depositor,
        });
    }
}

const MsgCreateGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

const MsgDeleteGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

const MsgLeaveGroupSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    },
    {
      "type": "string",
      "name": "member"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

const MsgUpdateGroupMemberSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "payment_address"
    },
    {
      "type": "string",
      "name": "primary_sp_address"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "uint64",
      "name": "charged_read_quota"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "uint64",
      "name": "payload_size"
    },
    {
      "type": "string",
      "name": "visibility"
    },
    {
      "type": "string",
      "name": "content_type"
    },
    {
      "type": "TypePrimarySpApproval",
      "name": "primary_sp_approval"
    },
    {
      "type": "Uint8Array[]",
      "name": "expect_checksums"
    },
    {
      "type": "string",
      "name": "redundancy_type"
    },
    {
      "type": "string[]",
      "name": "expect_secondary_sp_addresses"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string[]",
      "name": "secondary_sp_addresses"
    },
    {
      "type": "Uint8Array[]",
      "name": "secondary_sp_signatures"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "src_bucket_name"
    },
    {
      "type": "string",
      "name": "dst_bucket_name"
    },
    {
      "type": "string",
      "name": "src_object_name"
    },
    {
      "type": "string",
      "name": "dst_object_name"
    },
    {
      "type": "TypeDstPrimarySpApproval",
      "name": "dst_primary_sp_approval"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string",
      "name": "object_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "bucket_name"
    },
    {
      "type": "string[]",
      "name": "object_ids"
    },
    {
      "type": "string",
      "name": "reason"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string",
      "name": "operator"
    },
    {
      "type": "string",
      "name": "group_owner"
    },
    {
      "type": "string",
      "name": "group_name"
    },
    {
      "type": "string[]",
      "name": "members_to_add"
    },
    {
      "type": "string[]",
      "name": "members_to_delete"
    }
  ],
  "TypePrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ],
  "TypeDstPrimarySpApproval": [
    {
      "type": "uint64",
      "name": "expired_height"
    },
    {
      "type": "bytes",
      "name": "sig"
    }
  ]
};

class Group extends Account {
    async createGroup(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgCreateGroup';
        const msgBytes = MsgCreateGroup.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.creator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgCreateGroupSDKTypeEIP712, MsgCreateGroup.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async deleteGroup(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgDeleteGroup';
        const msgBytes = MsgDeleteGroup.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgDeleteGroupSDKTypeEIP712, MsgDeleteGroup.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async updateGroupMember(msg, txOption) {
        if (msg.groupName === '') {
            throw new Error('group name is empty');
        }
        if (msg.membersToAdd.length === 0 && msg.membersToDelete.length === 0) {
            throw new Error('no update member');
        }
        const typeUrl = '/bnbchain.greenfield.storage.MsgUpdateGroupMember';
        const msgBytes = MsgUpdateGroupMember.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgUpdateGroupMemberSDKTypeEIP712, MsgUpdateGroupMember.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async leaveGroup(address, msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgLeaveGroup';
        const msgBytes = MsgLeaveGroup.encode(msg).finish();
        const accountInfo = await this.getAccount(address);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgLeaveGroupSDKTypeEIP712, MsgLeaveGroup.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async headGroup(groupName, groupOwner) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return await rpc.HeadGroup({
            groupName,
            groupOwner,
        });
    }
    async headGroupMember(groupName, groupOwner, member) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return await rpc.HeadGroupMember({
            groupName,
            groupOwner,
            member,
        });
    }
    async getPolicyOfGroup(request) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return await rpc.QueryPolicyForGroup(request);
    }
}

const TYPE_URL$4 = '/bnbchain.greenfield.storage.MsgCancelCreateObject';
const MsgCancelCreateObjectSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
    ],
};
const newMsgCancelCreateObject = ({ from, bucketName, objectName, }) => {
    return {
        type: TYPE_URL$4,
        operator: from,
        bucket_name: bucketName,
        object_name: objectName,
    };
};

const TYPE_URL$3 = '/bnbchain.greenfield.storage.MsgCreateObject';
const MsgCreateObjectSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
        {
            name: 'payload_size',
            type: 'uint64',
        },
        {
            name: 'visibility',
            type: 'string',
        },
        {
            name: 'content_type',
            type: 'string',
        },
        {
            name: 'primary_sp_approval',
            type: 'TypePrimarySpApproval',
        },
        {
            name: 'expect_checksums',
            type: 'bytes[]',
        },
        {
            name: 'redundancy_type',
            type: 'string',
        },
        {
            name: 'expect_secondary_sp_addresses',
            type: 'string[]',
        },
    ],
    TypePrimarySpApproval: [
        {
            name: 'expired_height',
            type: 'uint64',
        },
        {
            name: 'sig',
            type: 'bytes',
        },
    ],
};
const newMsgCreateObject = ({ bucketName, contentType, expectChecksums, expiredHeight, from, visibility, objectName, payloadSize, sig, expectSecondarySpAddresses, redundancyType, }) => {
    return {
        type: TYPE_URL$3,
        bucket_name: bucketName,
        content_type: contentType,
        creator: from,
        expect_checksums: expectChecksums,
        visibility: visibility === undefined ? visibilityTypeToJSON(0) : visibilityTypeToJSON(visibility),
        object_name: objectName,
        payload_size: payloadSize,
        primary_sp_approval: {
            expired_height: expiredHeight,
            sig: sig,
        },
        expect_secondary_sp_addresses: expectSecondarySpAddresses,
        redundancy_type: redundancyType === undefined ? redundancyTypeToJSON(0) : redundancyTypeToJSON(redundancyType),
    };
};

const TYPE_URL$2 = '/bnbchain.greenfield.storage.MsgDeleteObject';
const MsgDeleteObjectSDKTypeEIP712 = {
    Msg: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
    ],
};
const newMsgDeleteObject = ({ bucketName, objectName, from }) => {
    return {
        type: TYPE_URL$2,
        bucket_name: bucketName,
        object_name: objectName,
        operator: from,
    };
};

class Object$1 extends Account {
    constructor(rpcUrl, chainId, bucket) {
        super(rpcUrl, chainId);
        this.bucket = bucket;
    }
    async getCreateObjectApproval({ bucketName, creator, objectName, visibility = 'VISIBILITY_TYPE_PUBLIC_READ', spInfo, duration = 3000, file, redundancyType = 'REDUNDANCY_EC_TYPE', }) {
        try {
            if (!isValidUrl(spInfo.endpoint)) {
                throw new Error('Invalid endpoint');
            }
            if (!file) {
                throw new Error('File is needed');
            }
            if (!isValidBucketName(bucketName)) ;
            if (!isValidObjectName(objectName)) ;
            if (!creator) {
                throw new Error('empty creator address');
            }
            const buffer = await file.arrayBuffer();
            const bytes = new Uint8Array(buffer);
            const hashResult = await FileHandler.getPieceHashRoots(bytes);
            const { contentLength, expectCheckSums } = hashResult;
            const finalContentType = file && file.type && file.type.length > 0 ? file.type : 'application/octet-stream';
            const msg = {
                creator: creator,
                object_name: objectName,
                content_type: finalContentType,
                payload_size: contentLength.toString(),
                bucket_name: bucketName,
                visibility,
                primary_sp_approval: { expired_height: '0', sig: '' },
                expect_checksums: expectCheckSums,
                redundancy_type: redundancyType,
                expect_secondary_sp_addresses: spInfo.secondarySpAddresses,
            };
            const signature = MOCK_SIGNATURE;
            const url = spInfo.endpoint + '/greenfield/admin/v1/get-approval?action=CreateObject';
            const unSignedMessageInHex = encodeObjectToHexString(msg);
            const headers = new Headers({
                // todo place the correct authorization string
                Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
                'X-Gnfd-Unsigned-Msg': unSignedMessageInHex,
            });
            const result = await fetchWithTimeout(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                return {
                    code: -1,
                    message: 'Get create object approval error.',
                    statusCode: status,
                };
            }
            const resultContentType = result.headers.get('Content-Type');
            // Will receive xml when get object met error
            if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                const xmlText = await result.text();
                const xml = await new window.DOMParser().parseFromString(xmlText, 'text/xml');
                return {
                    code: -1,
                    xml,
                    message: 'Get create object approval error.',
                    statusCode: status,
                };
            }
            const signedMsgString = result.headers.get('X-Gnfd-Signed-Msg') || '';
            const signedMsg = decodeObjectFromHexString(signedMsgString);
            return {
                code: 0,
                message: 'Get create object approval success.',
                body: result.headers.get('X-Gnfd-Signed-Msg') ?? '',
                statusCode: status,
                signedMsg,
            };
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
        }
    }
    async createObject(getApprovalParams, txOption) {
        const { signedMsg } = await this.getCreateObjectApproval(getApprovalParams);
        if (!signedMsg) {
            throw new Error('Get create object approval error');
        }
        const msg = {
            bucketName: signedMsg.bucket_name,
            creator: signedMsg.creator,
            objectName: signedMsg.object_name,
            contentType: signedMsg.content_type,
            payloadSize: Long.fromString(signedMsg.payload_size),
            visibility: visibilityTypeFromJSON(signedMsg.visibility),
            expectChecksums: signedMsg.expect_checksums.map((e) => bytesFromBase64(e)),
            expectSecondarySpAddresses: signedMsg.expect_secondary_sp_addresses,
            redundancyType: signedMsg.redundancy_type === undefined
                ? redundancyTypeFromJSON(0)
                : redundancyTypeFromJSON(signedMsg.redundancy_type),
            primarySpApproval: {
                expiredHeight: Long.fromString(signedMsg.primary_sp_approval.expired_height),
                sig: bytesFromBase64(signedMsg.primary_sp_approval.sig),
            },
        };
        const typeUrl = '/bnbchain.greenfield.storage.MsgCreateObject';
        const msgBytes = MsgCreateObject.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.creator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgCreateObjectSDKTypeEIP712, {
            ...signedMsg,
            type: typeUrl,
            visibility: signedMsg.visibility,
            primary_sp_approval: {
                expired_height: signedMsg.primary_sp_approval.expired_height,
                sig: signedMsg.primary_sp_approval.sig,
            },
            redundancy_type: signedMsg.redundancy_type,
            payload_size: signedMsg.payload_size,
        }, bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async uploadObject(configParam) {
        const { bucketName, objectName, txnHash, body, endpoint, duration = 30000 } = configParam;
        if (!isValidBucketName(bucketName)) ;
        if (!isValidUrl(endpoint)) {
            throw new Error('Invalid endpoint');
        }
        if (!isValidObjectName(objectName)) ;
        if (!txnHash) {
            throw new Error('Transaction hash is empty, please check.');
        }
        const url = generateUrlByBucketName(endpoint, bucketName) + '/' + objectName;
        // todo generate real signature
        const signature = MOCK_SIGNATURE;
        const headers = new Headers({
            // todo place the correct authorization string
            Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
            'X-Gnfd-Txn-hash': txnHash,
        });
        try {
            const result = await fetchWithTimeout(url, {
                headers,
                method: METHOD_PUT,
                body,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                return { code: -1, message: 'Put object error.', statusCode: status };
            }
            const resultContentType = result.headers.get('Content-Type');
            // Will receive xml when put object met error
            if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                const xmlText = await result.text();
                const xml = await new window.DOMParser().parseFromString(xmlText, 'text/xml');
                return { code: -1, message: 'Put object error.', xml, statusCode: status };
            }
            return { code: 0, message: 'Put object success.', statusCode: status };
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
        }
    }
    async cancelCreateObject(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgCancelCreateObject';
        const msgBytes = MsgCancelCreateObject.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgCancelCreateObjectSDKTypeEIP712, MsgCancelCreateObject.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async deleteObject(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.storage.MsgDeleteObject';
        const msgBytes = MsgDeleteObject.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.operator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgDeleteObjectSDKTypeEIP712, MsgDeleteObject.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async headObject(bucketName, objectName) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return rpc.HeadObject({
            bucketName,
            objectName,
        });
    }
    async headObjectById(objectId) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$3(rpcClient);
        return rpc.HeadObjectById({
            objectId,
        });
    }
    async getObject(configParam) {
        try {
            const { bucketName, objectName, endpoint, duration = 30000 } = configParam;
            // todo generate real signature
            const signature = MOCK_SIGNATURE;
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            if (!isValidBucketName(bucketName)) ;
            if (!isValidObjectName(objectName)) ;
            const url = generateUrlByBucketName(endpoint, bucketName) + '/' + objectName;
            const headers = new Headers({
                Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
            });
            const result = await fetchWithTimeout(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                return { code: -1, message: 'Get object error.', statusCode: status };
            }
            const resultContentType = result.headers.get('Content-Type');
            // Will receive xml when get object met error
            if (resultContentType === 'text/xml' || resultContentType === 'application/xml') {
                const xmlText = await result.text();
                const xml = await new window.DOMParser().parseFromString(xmlText, 'text/xml');
                return {
                    code: -1,
                    xml,
                    message: 'Get object error.',
                    statusCode: status,
                };
            }
            const fileBlob = await result.blob();
            return {
                code: 0,
                body: fileBlob,
                message: 'Get object success.',
                statusCode: status,
            };
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
        }
    }
    async downloadFile(configParam) {
        try {
            const { objectName } = configParam;
            const getObjectResult = await this.getObject(configParam);
            if (getObjectResult.code !== 0) {
                throw new Error(getObjectResult.message);
            }
            const file = getObjectResult?.body;
            if (file) {
                // const {file} = getObjectResult;
                const fileURL = URL.createObjectURL(file);
                // create <a> tag dynamically
                const fileLink = document.createElement('a');
                fileLink.href = fileURL;
                // it forces the name of the downloaded file
                fileLink.download = objectName;
                // triggers the click event
                fileLink.click();
            }
            return;
        }
        catch (error) {
            throw new Error(error);
        }
    }
    async listObjects(configParam) {
        try {
            const { bucketName, endpoint, duration = 30000 } = configParam;
            if (!isValidBucketName(bucketName)) ;
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            const url = generateUrlByBucketName(endpoint, bucketName);
            const signature = MOCK_SIGNATURE;
            const headers = new Headers({
                // todo place the correct authorization string
                Authorization: `authTypeV2 ECDSA-secp256k1, Signature=${signature}`,
            });
            const result = await fetchWithTimeout(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                return { code: -1, message: 'List object error.', statusCode: status };
            }
            const { objects } = await result.json();
            return {
                code: 0,
                message: 'List object success.',
                statusCode: status,
                body: objects,
            };
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: NORMAL_ERROR_CODE };
        }
    }
    async createFolder(getApprovalParams, txOption) {
        if (!getApprovalParams.objectName.endsWith('/')) {
            throw new Error('failed to create folder. Folder names must end with a forward slash (/) character');
        }
        return this.createObject(getApprovalParams, txOption);
    }
}

const MsgDepositSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "string",
      "name": "amount"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

const MsgDisableRefundSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "string",
      "name": "amount"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "from"
    },
    {
      "type": "string",
      "name": "amount"
    },
    {
      "type": "string",
      "name": "owner"
    },
    {
      "type": "string",
      "name": "addr"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

const MsgWithdrawSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "authority"
    },
    {
      "type": "TypeParams",
      "name": "params"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "string",
      "name": "amount"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "from"
    },
    {
      "type": "string",
      "name": "amount"
    }
  ],
  "TypeParams": [
    {
      "type": "uint64",
      "name": "reserve_time"
    },
    {
      "type": "uint64",
      "name": "payment_account_count_limit"
    },
    {
      "type": "uint64",
      "name": "forced_settle_time"
    },
    {
      "type": "uint64",
      "name": "max_auto_force_settle_num"
    },
    {
      "type": "string",
      "name": "fee_denom"
    },
    {
      "type": "string",
      "name": "validator_tax_rate"
    }
  ]
};

class Payment extends Account {
    async getStreamRecord(account) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl(rpcClient);
        return await rpc.StreamRecord({
            account,
        });
    }
    async params() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl(rpcClient);
        return await rpc.Params();
    }
    async deposit(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.payment.MsgDeposit';
        const msgBytes = MsgDeposit.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.creator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgDepositSDKTypeEIP712, MsgDeposit.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async withdraw(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.payment.MsgWithdraw';
        const msgBytes = MsgWithdraw.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.creator);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgWithdrawSDKTypeEIP712, MsgWithdraw.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
    async disableRefund(msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.payment.MsgDisableRefund';
        const msgBytes = MsgDisableRefund.encode(msg).finish();
        const accountInfo = await this.getAccount(msg.addr);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgDisableRefundSDKTypeEIP712, MsgDisableRefund.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
}

const MsgUpdateSpStoragePriceSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "TypeDescription",
      "name": "description"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "string",
      "name": "funding_address"
    },
    {
      "type": "string",
      "name": "seal_address"
    },
    {
      "type": "string",
      "name": "approval_address"
    },
    {
      "type": "string",
      "name": "gc_address"
    },
    {
      "type": "string",
      "name": "endpoint"
    },
    {
      "type": "TypeAmount",
      "name": "deposit"
    },
    {
      "type": "string",
      "name": "read_price"
    },
    {
      "type": "uint64",
      "name": "free_read_quota"
    },
    {
      "type": "string",
      "name": "store_price"
    },
    {
      "type": "string",
      "name": "creator"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "TypeAmount",
      "name": "deposit"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "string",
      "name": "endpoint"
    },
    {
      "type": "TypeDescription",
      "name": "description"
    },
    {
      "type": "string",
      "name": "seal_address"
    },
    {
      "type": "string",
      "name": "approval_address"
    },
    {
      "type": "string",
      "name": "gc_address"
    },
    {
      "type": "string",
      "name": "sp_address"
    },
    {
      "type": "string",
      "name": "read_price"
    },
    {
      "type": "uint64",
      "name": "free_read_quota"
    },
    {
      "type": "string",
      "name": "store_price"
    }
  ],
  "TypeDescription": [
    {
      "type": "string",
      "name": "moniker"
    },
    {
      "type": "string",
      "name": "identity"
    },
    {
      "type": "string",
      "name": "website"
    },
    {
      "type": "string",
      "name": "security_contact"
    },
    {
      "type": "string",
      "name": "details"
    }
  ]
};

class Sp extends Account {
    async getStorageProviders() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$8(rpcClient);
        const res = await rpc.StorageProviders();
        return res.sps;
    }
    async getStorageProviderInfo(spAddress) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$8(rpcClient);
        const res = await rpc.StorageProvider({
            spAddress,
        });
        return res.storageProvider;
    }
    async getStoragePriceByTime(spAddress) {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$8(rpcClient);
        const res = await rpc.QueryGetSpStoragePriceByTime({
            timestamp: Long.fromNumber(0),
            spAddr: spAddress,
        });
        return res.spStoragePrice;
    }
    async getSecondarySpStorePrice() {
        const rpcClient = await this.getRpcClient();
        const rpc = new QueryClientImpl$8(rpcClient);
        const res = await rpc.QueryGetSecondarySpStorePriceByTime({
            timestamp: Long.fromNumber(0),
        });
        return res.secondarySpStorePrice;
    }
    async updateSpStoragePrice(address, msg, txOption) {
        const typeUrl = '/bnbchain.greenfield.sp.MsgUpdateSpStoragePrice';
        const msgBytes = MsgUpdateSpStoragePrice.encode(msg).finish();
        const accountInfo = await this.getAccount(address);
        const bodyBytes = this.getBodyBytes(typeUrl, msgBytes);
        if (txOption.simulate) {
            return await this.simulateRawTx(bodyBytes, accountInfo, {
                denom: txOption.denom,
            });
        }
        const rawTxBytes = await this.getRawTxBytes(typeUrl, MsgUpdateSpStoragePriceSDKTypeEIP712, MsgUpdateSpStoragePrice.toSDK(msg), bodyBytes, accountInfo, {
            denom: txOption.denom,
            gasLimit: txOption.gasLimit,
            gasPrice: txOption.gasPrice,
            payer: accountInfo.address,
            granter: '',
        });
        return await this.broadcastRawTx(rawTxBytes);
    }
}

class Client {
    static create(rpcUrl, chainId) {
        const account = new Account(rpcUrl, chainId);
        const basic = new Basic(rpcUrl, chainId);
        const bucket = new Bucket(rpcUrl, chainId);
        const challenge = new Challenge(rpcUrl, chainId);
        const crosschain = new CrossChain(rpcUrl, chainId);
        const distribution = new Distribution(rpcUrl, chainId);
        const group = new Group(rpcUrl, chainId);
        const object = new Object$1(rpcUrl, chainId, bucket);
        const payment = new Payment(rpcUrl, chainId);
        const sp = new Sp(rpcUrl, chainId);
        return new Client(account, basic, bucket, challenge, crosschain, distribution, group, object, payment, sp);
    }
    constructor(account, basic, bucket, challenge, crosschain, distribution, group, object, payment, sp) {
        this.account = account;
        this.basic = basic;
        this.bucket = bucket;
        this.challenge = challenge;
        this.crosschain = crosschain;
        this.distribution = distribution;
        this.group = group;
        this.object = object;
        this.payment = payment;
        this.sp = sp;
    }
}

const MsgSendSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from_address"
    },
    {
      "type": "string",
      "name": "to_address"
    },
    {
      "type": "TypeAmount[]",
      "name": "amount"
    }
  ]
};

class BaseTx {
    constructor(rpcUrl, chainId, txType) {
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = txType;
    }
    async broadcastTx(txRawBytes) {
        const client = await StargateClient.connect(this.rpcUrl);
        if (!BaseTx.client) {
            BaseTx.client = client;
        }
        return await client.broadcastTx(txRawBytes);
    }
    getSignture(sign) {
        return Uint8Array.from(toBuffer(sign));
    }
    async simulateTx(txBodyBytes, authInfoBytes) {
        const rpcClient = await makeRpcClient(this.rpcUrl);
        const rpc = new ServiceClientImpl$1(rpcClient);
        const tx = Tx.fromPartial({
            authInfo: AuthInfo.decode(authInfoBytes),
            body: TxBody.decode(txBodyBytes),
            signatures: [Uint8Array.from([])],
        });
        const request = SimulateRequest.fromPartial({
            txBytes: Tx.encode(tx).finish(),
        });
        return rpc.Simulate(request);
    }
}

const TYPE_URL$1 = '/cosmos.bank.v1beta1.MsgSend';
class TransferTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, TYPE_URL$1);
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = TYPE_URL$1;
    }
    async getRawTxInfo({ sequence, sign, pubKey, from, to, amount, gasLimit, denom, gasPrice, }) {
        const bodyBytes = this.getSimulateBytes({ from, to, amount, denom });
        const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
        const signtureFromWallet = this.getSignture(sign);
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [signtureFromWallet],
        });
        const txRawBytes = TxRaw.encode(txRaw).finish();
        return {
            bytes: txRawBytes,
            hex: bufferToHex(Buffer.from(txRawBytes)),
        };
    }
    getSimulateBytes({ from, to, amount, denom, }) {
        const message = MsgSend.fromPartial({
            amount: [
                {
                    amount,
                    denom,
                },
            ],
            fromAddress: from,
            toAddress: to,
        });
        const messageBytes = MsgSend.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
    async signTx({ from, to, sequence, accountNumber, amount, denom, gasLimit, gasPrice, }) {
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
        const msg = MsgSend.toSDK({
            amount: [
                {
                    amount,
                    denom,
                },
            ],
            fromAddress: from,
            toAddress: to,
        });
        const wrapperMsg = typeWrapper(TYPE_URL$1, msg);
        const types = generateTypes(MsgSendSDKTypeEIP712);
        const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, wrapperMsg, '0');
        const eip712 = createEIP712(types, this.chainId, messages);
        return await sign712Tx(from, JSON.stringify(eip712));
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                denom,
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

const MsgTransferOutSDKTypeEIP712 = {
  "Msg": [
    {
      "type": "string",
      "name": "type"
    },
    {
      "type": "string",
      "name": "from"
    },
    {
      "type": "string",
      "name": "to"
    },
    {
      "type": "TypeAmount",
      "name": "amount"
    }
  ]
};

const TYPE_URL = '/bnbchain.greenfield.bridge.MsgTransferOut';
class TransferOutTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, TYPE_URL);
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = TYPE_URL;
    }
    async getRawTxInfo({ sequence, sign, pubKey, from, to, amount, denom, gasLimit, gasPrice, }) {
        const bodyBytes = this.getSimulateBytes({ from, to, amount, denom });
        const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
        const signtureFromWallet = this.getSignture(sign);
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [signtureFromWallet],
        });
        const txRawBytes = TxRaw.encode(txRaw).finish();
        return {
            bytes: txRawBytes,
            hex: bufferToHex(Buffer.from(txRawBytes)),
        };
    }
    getSimulateBytes({ from, to, amount, denom, }) {
        const payload = {
            from,
            to,
            amount: {
                amount,
                denom,
            },
        };
        const message = MsgTransferOut.fromJSON(payload);
        const messageBytes = MsgTransferOut.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
    async signTx({ from, to, sequence, accountNumber, amount, denom, gasLimit, gasPrice, }) {
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
        // const msg = newMsgTransferOut(amount, denom, from, to);
        const msg = MsgTransferOut.fromSDK({
            from,
            to,
            amount: {
                amount,
                denom,
            },
        });
        const wrappedMsg = typeWrapper(TYPE_URL, msg);
        const types = generateTypes(MsgTransferOutSDKTypeEIP712);
        const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, wrappedMsg, '0');
        const eip712 = createEIP712(types, this.chainId, messages);
        return await sign712Tx(from, JSON.stringify(eip712));
    }
    async simulateRelayFee() {
        const rpcClient = await makeRpcClient(this.rpcUrl);
        const rpc = new QueryClientImpl$7(rpcClient);
        const data = QueryParamsRequest.encode({}).finish();
        return rpc.Params(data);
    }
}

class CreateBucketTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgCreateBucket');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgCreateBucket';
    }
    async signTx({ bucketName, from, sequence, primarySpAddress, denom, accountNumber, expiredHeight, chargedReadQuota, sig, visibility, gasLimit, gasPrice, paymentAddress, }) {
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
        const msg = newMsgCreateBucket({
            bucketName,
            from,
            expiredHeight,
            visibility,
            paymentAddress,
            primarySpAddress,
            chargedReadQuota,
            sig,
        });
        const types = generateTypes(MsgCreateBucketSDKTypeEIP712);
        const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
        const eip712 = createEIP712(types, this.chainId, messages);
        return await sign712Tx(from, JSON.stringify(eip712));
    }
    async getRawTxInfo({ bucketName, from, sequence, primarySpAddress, denom, expiredHeight, sig, visibility, gasLimit, sign, pubKey, chargedReadQuota, gasPrice, paymentAddress, }) {
        const bodyBytes = this.getSimulateBytes({
            primarySpAddress,
            from,
            denom,
            bucketName,
            expiredHeight,
            sig,
            visibility,
            chargedReadQuota,
            paymentAddress,
        });
        const authInfoBytes = this.getAuthInfoBytes({ sequence, pubKey, denom, gasLimit, gasPrice });
        const signtureFromWallet = this.getSignture(sign);
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [signtureFromWallet],
        });
        const txRawBytes = TxRaw.encode(txRaw).finish();
        return {
            bytes: txRawBytes,
            hex: bufferToHex(Buffer.from(txRawBytes)),
        };
    }
    getAuthInfoBytes({ sequence, pubKey, denom, gasLimit, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const bigGasPrice = BigInt(gasPrice);
        const bigGasLimit = BigInt(gasLimit);
        const feeAmount = [
            {
                amount: String(bigGasPrice * bigGasLimit),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
    getSimulateBytes({ from, bucketName, primarySpAddress, expiredHeight, sig, visibility, chargedReadQuota, paymentAddress, }) {
        const message = MsgCreateBucket.fromPartial({});
        message.bucketName = bucketName;
        message.chargedReadQuota = chargedReadQuota
            ? Long$1.fromNumber(0)
            : Long$1.fromNumber(chargedReadQuota);
        message.creator = from;
        message.visibility = visibilityTypeFromJSON(visibility);
        message.paymentAddress = paymentAddress;
        message.primarySpAddress = primarySpAddress;
        message.primarySpApproval = {
            expiredHeight: Long$1.fromString(expiredHeight),
            sig: bytesFromBase64(sig),
        };
        const messageBytes = MsgCreateBucket.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
}

class DelBucketTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, TYPE_URL$5);
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = TYPE_URL$5;
    }
    async signTx({ from, bucketName, accountNumber, sequence, gasLimit, denom, gasPrice, }) {
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
        const msg = newMsgDeleteBucket({
            bucketName,
            from,
        });
        const types = generateTypes(MsgDeleteBucketSDKTypeEIP712);
        const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
        const eip712 = createEIP712(types, this.chainId, messages);
        return await sign712Tx(from, JSON.stringify(eip712));
    }
    async getRawTxInfo({ bucketName, from, sequence, gasLimit, sign, pubKey, denom, gasPrice, }) {
        const bodyBytes = this.getSimulateBytes({
            from,
            bucketName,
        });
        const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
        const signtureFromWallet = this.getSignture(sign);
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [signtureFromWallet],
        });
        const txRawBytes = TxRaw.encode(txRaw).finish();
        return {
            bytes: txRawBytes,
            hex: bufferToHex(Buffer.from(txRawBytes)),
        };
    }
    getSimulateBytes({ from, bucketName, }) {
        const message = MsgDeleteBucket.fromJSON({
            operator: from,
            bucketName,
        });
        const messageBytes = MsgDeleteBucket.encode(message).finish();
        const msgDemoWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgDemoWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, denom, gasLimit, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

class CreateObjectTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgCreateObject');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgCreateObject';
    }
    async signTx(params) {
        const { accountNumber, bucketName, contentType, denom, expectChecksums, expectSecondarySpAddresses, expiredHeight, from, gasLimit, objectName, payloadSize, redundancyType, sequence, sig, visibility, gasPrice, } = params;
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
        const msg = newMsgCreateObject({
            bucketName,
            contentType,
            expectChecksums,
            expectSecondarySpAddresses,
            expiredHeight,
            from,
            objectName,
            payloadSize,
            redundancyType,
            sig,
            visibility,
        });
        const types = generateTypes(MsgCreateObjectSDKTypeEIP712);
        const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
        const eip712 = createEIP712(types, this.chainId, messages);
        return await sign712Tx(from, JSON.stringify(eip712));
    }
    async getRawTxInfo({ bucketName, contentType, denom, expectChecksums, expectSecondarySpAddresses, expiredHeight, from, gasLimit, objectName, payloadSize, pubKey, redundancyType, sequence, sig, sign, visibility, gasPrice, }) {
        const bodyBytes = this.getSimulateBytes({
            from,
            bucketName,
            expiredHeight,
            sig,
            visibility,
            contentType,
            expectChecksums,
            objectName,
            payloadSize,
            expectSecondarySpAddresses,
            redundancyType,
        });
        const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
        const signtureFromWallet = this.getSignture(sign);
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [signtureFromWallet],
        });
        const txRawBytes = TxRaw.encode(txRaw).finish();
        return {
            bytes: txRawBytes,
            hex: bufferToHex(Buffer.from(txRawBytes)),
        };
    }
    getSimulateBytes(params) {
        const { from, bucketName, objectName, contentType, visibility, payloadSize, expiredHeight, sig, expectChecksums, expectSecondarySpAddresses, redundancyType, } = params;
        const message = MsgCreateObject.fromPartial({
            bucketName,
            objectName,
            contentType,
            payloadSize,
            creator: from,
            expectSecondarySpAddresses,
        });
        message.visibility =
            visibility === undefined ? visibilityTypeFromJSON(0) : visibilityTypeFromJSON(visibility);
        message.redundancyType =
            redundancyType === undefined
                ? redundancyTypeFromJSON(0)
                : redundancyTypeFromJSON(redundancyType);
        message.primarySpApproval = {
            expiredHeight: Long$1.fromString(expiredHeight),
            sig: bytesFromBase64(sig),
        };
        message.expectChecksums = expectChecksums.map((e) => bytesFromBase64(e));
        const messageBytes = MsgCreateObject.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

class DelObjectTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgDeleteObject');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgDeleteObject';
    }
    async signTx({ bucketName, objectName, from, sequence, accountNumber, gasLimit, denom, gasPrice, }) {
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
        const msg = newMsgDeleteObject({
            bucketName,
            from,
            objectName,
        });
        const types = generateTypes(MsgDeleteObjectSDKTypeEIP712);
        const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
        const eip712 = createEIP712(types, this.chainId, messages);
        return await sign712Tx(from, JSON.stringify(eip712));
    }
    async getRawTxInfo({ bucketName, from, sequence, gasLimit, sign, pubKey, objectName, denom, gasPrice, }) {
        const bodyBytes = this.getSimulateBytes({
            from,
            bucketName,
            objectName,
        });
        const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
        const signtureFromWallet = this.getSignture(sign);
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [signtureFromWallet],
        });
        const txRawBytes = TxRaw.encode(txRaw).finish();
        return {
            bytes: txRawBytes,
            hex: bufferToHex(Buffer.from(txRawBytes)),
        };
    }
    getSimulateBytes({ from, bucketName, objectName, }) {
        const message = MsgDeleteObject.fromJSON({
            operator: from,
            bucketName,
            objectName,
        });
        const messageBytes = MsgDeleteObject.encode(message).finish();
        const msgDemoWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgDemoWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

class CancelCreateObjectTx extends BaseTx {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, chainId, '/bnbchain.greenfield.storage.MsgCancelCreateObject');
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.txType = '/bnbchain.greenfield.storage.MsgCancelCreateObject';
    }
    async signTx(params) {
        const { accountNumber, bucketName, denom, gasLimit, gasPrice, objectName, sequence, from } = params;
        const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), from, '');
        const msg = newMsgCancelCreateObject({
            bucketName,
            objectName,
            from,
        });
        const types = generateTypes(MsgCancelCreateObjectSDKTypeEIP712);
        const messages = generateMessage(accountNumber, sequence, this.chainId, '', fee, msg, '0');
        const eip712 = createEIP712(types, this.chainId, messages);
        return await sign712Tx(from, JSON.stringify(eip712));
    }
    async getRawTxInfo({ bucketName, from, sequence, gasLimit, sign, pubKey, objectName, denom, gasPrice, }) {
        const bodyBytes = this.getSimulateBytes({
            from,
            bucketName,
            objectName,
        });
        const authInfoBytes = this.getAuthInfoBytes({ denom, sequence, pubKey, gasLimit, gasPrice });
        const signtureFromWallet = this.getSignture(sign);
        const txRaw = TxRaw.fromPartial({
            bodyBytes,
            authInfoBytes,
            signatures: [signtureFromWallet],
        });
        const txRawBytes = TxRaw.encode(txRaw).finish();
        return {
            bytes: txRawBytes,
            hex: bufferToHex(Buffer.from(txRawBytes)),
        };
    }
    getSimulateBytes(params) {
        const { from, bucketName, objectName } = params;
        const message = MsgCancelCreateObject.fromJSON({
            operator: from,
            bucketName,
            objectName,
        });
        const messageBytes = MsgCancelCreateObject.encode(message).finish();
        const msgWrapped = Any.fromPartial({
            typeUrl: this.txType,
            value: messageBytes,
        });
        const txBody = TxBody.fromPartial({
            messages: [msgWrapped],
        });
        return TxBody.encode(txBody).finish();
    }
    getAuthInfoBytes({ sequence, pubKey, gasLimit, denom, gasPrice, }) {
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                amount: String(BigInt(gasPrice) * BigInt(gasLimit)),
                denom,
            },
        ];
        const feeGranter = undefined;
        const feePayer = undefined;
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, feeGranter, feePayer, 712);
        return authInfoBytes;
    }
}

const BucketTypeAbbr = 'b';
const ObjectTypeAbbr = 'o';
const GroupTypeAbbr = 'g';
const newBucketGRN = (bucketName) => {
    return {
        resType: ResourceType.RESOURCE_TYPE_BUCKET,
        groupOwner: '',
        name: bucketName,
    };
};
const newObjectGRN = (owner, groupName) => {
    return {
        resType: ResourceType.RESOURCE_TYPE_GROUP,
        groupOwner: owner,
        name: groupName,
    };
};
const GRNToString = (grn) => {
    let res = '';
    switch (grn.resType) {
        case ResourceType.RESOURCE_TYPE_BUCKET:
            res = `grn:${BucketTypeAbbr}::${grn.name}`;
            break;
        case ResourceType.RESOURCE_TYPE_OBJECT:
            res = `grn:${ObjectTypeAbbr}::${grn.name}`;
            break;
        case ResourceType.RESOURCE_TYPE_GROUP:
            res = `grn:${GroupTypeAbbr}:${grn.groupOwner}:${grn.name}`;
            break;
        default:
            return '';
    }
    return res.trim();
};

export { CancelCreateObjectTx, Client, CreateBucketTx, CreateObjectTx, DelBucketTx, DelObjectTx, GRNToString, TYPE_URL, TransferOutTx, TransferTx, ZERO_PUBKEY, decodeFromHex, decodeObjectFromHexString, encodeObjectToHexString, encodeToHex, encodeToHexString, generateUrlByBucketName, getGasFeeBySimulate, isValidAddress, isValidBucketName, isValidObjectName, isValidUrl, makeCosmsPubKey, newBucketGRN, newObjectGRN, recoverPk, sign712Tx, trimString };
