/// <reference types="long" />
import { Description, DescriptionSDKType } from "./types";
import { Coin, CoinSDKType } from "../../cosmos/base/v1beta1/coin";
import { Params, ParamsSDKType } from "./params";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.sp";
/** MsgCreateStorageProvider defines message for creating a new storage provider. */
export interface MsgCreateStorageProvider {
    /** creator is the msg signer */
    creator: string;
    /** description defines the description terms for the validator. */
    description?: Description;
    /** sp_address defines the address of the sp's operator; It also is the unqiue index key of sp. */
    spAddress: string;
    /** fund_address is the account address of the storage provider for deposit, remuneration. */
    fundingAddress: string;
    /** seal_address is the account address of the storage provider for sealObject */
    sealAddress: string;
    /** approval_address is the account address of the storage provider for ack CreateBucket/Object. */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose. */
    gcAddress: string;
    /** endpoint is the service address of the storage provider */
    endpoint: string;
    /** deposit define the deposit token */
    deposit?: Coin;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** free read quota, in byte */
    freeReadQuota: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
/** MsgCreateStorageProvider defines message for creating a new storage provider. */
export interface MsgCreateStorageProviderSDKType {
    creator: string;
    description?: DescriptionSDKType;
    sp_address: string;
    funding_address: string;
    seal_address: string;
    approval_address: string;
    gc_address: string;
    endpoint: string;
    deposit?: CoinSDKType;
    read_price: string;
    free_read_quota: Long;
    store_price: string;
}
/** MsgCreateStorageProviderResponse defines the Msg/CreateStorageProvider response type. */
export interface MsgCreateStorageProviderResponse {
}
/** MsgCreateStorageProviderResponse defines the Msg/CreateStorageProvider response type. */
export interface MsgCreateStorageProviderResponseSDKType {
}
/** MsgDeposit defines a SDK message for deposit token for sp. */
export interface MsgDeposit {
    /** creator is the msg signer, it should be sp's fund address */
    creator: string;
    /** sp_address is the operator address of sp */
    spAddress: string;
    /** deposit is a mount of token which used to deposit for SP */
    deposit?: Coin;
}
/** MsgDeposit defines a SDK message for deposit token for sp. */
export interface MsgDepositSDKType {
    creator: string;
    sp_address: string;
    deposit?: CoinSDKType;
}
/** MsgDepositResponse defines the Msg/Deposit response type. */
export interface MsgDepositResponse {
}
/** MsgDepositResponse defines the Msg/Deposit response type. */
export interface MsgDepositResponseSDKType {
}
/** MsgEditStorageProvider defines a SDK message for editing an existing sp. */
export interface MsgEditStorageProvider {
    spAddress: string;
    endpoint: string;
    description?: Description;
    /** seal_address is the account address of the storage provider for sealObject */
    sealAddress: string;
    /** approval_address is the account address of the storage provider for ack CreateBucket/Object */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose */
    gcAddress: string;
}
/** MsgEditStorageProvider defines a SDK message for editing an existing sp. */
export interface MsgEditStorageProviderSDKType {
    sp_address: string;
    endpoint: string;
    description?: DescriptionSDKType;
    seal_address: string;
    approval_address: string;
    gc_address: string;
}
/** MsgEditStorageProviderResponse defines the Msg/EditStorageProvider response type. */
export interface MsgEditStorageProviderResponse {
}
/** MsgEditStorageProviderResponse defines the Msg/EditStorageProvider response type. */
export interface MsgEditStorageProviderResponseSDKType {
}
export interface MsgUpdateSpStoragePrice {
    /** sp address */
    spAddress: string;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** free read quota, in byte */
    freeReadQuota: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
export interface MsgUpdateSpStoragePriceSDKType {
    sp_address: string;
    read_price: string;
    free_read_quota: Long;
    store_price: string;
}
export interface MsgUpdateSpStoragePriceResponse {
}
export interface MsgUpdateSpStoragePriceResponseSDKType {
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
    /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
    authority: string;
    /**
     * params defines the x/sp parameters to update.
     *
     * NOTE: All parameters must be supplied.
     */
    params?: Params;
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParamsSDKType {
    authority: string;
    params?: ParamsSDKType;
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponseSDKType {
}
export declare const MsgCreateStorageProvider: {
    encode(message: MsgCreateStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateStorageProvider;
    fromJSON(object: any): MsgCreateStorageProvider;
    toJSON(message: MsgCreateStorageProvider): unknown;
    fromPartial<I extends {
        creator?: string | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
        spAddress?: string | undefined;
        fundingAddress?: string | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
        endpoint?: string | undefined;
        deposit?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | Long.Long | undefined;
        storePrice?: string | undefined;
    } & {
        creator?: string | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
        spAddress?: string | undefined;
        fundingAddress?: string | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
        endpoint?: string | undefined;
        deposit?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["deposit"], keyof Coin>, never>) | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["freeReadQuota"], keyof Long.Long>, never>) | undefined;
        storePrice?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgCreateStorageProvider>, never>>(object: I): MsgCreateStorageProvider;
    fromSDK(object: MsgCreateStorageProviderSDKType): MsgCreateStorageProvider;
    toSDK(message: MsgCreateStorageProvider): MsgCreateStorageProviderSDKType;
};
export declare const MsgCreateStorageProviderResponse: {
    encode(_: MsgCreateStorageProviderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateStorageProviderResponse;
    fromJSON(_: any): MsgCreateStorageProviderResponse;
    toJSON(_: MsgCreateStorageProviderResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCreateStorageProviderResponse;
    fromSDK(_: MsgCreateStorageProviderResponseSDKType): MsgCreateStorageProviderResponse;
    toSDK(_: MsgCreateStorageProviderResponse): MsgCreateStorageProviderResponseSDKType;
};
export declare const MsgDeposit: {
    encode(message: MsgDeposit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeposit;
    fromJSON(object: any): MsgDeposit;
    toJSON(message: MsgDeposit): unknown;
    fromPartial<I extends {
        creator?: string | undefined;
        spAddress?: string | undefined;
        deposit?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
    } & {
        creator?: string | undefined;
        spAddress?: string | undefined;
        deposit?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["deposit"], keyof Coin>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgDeposit>, never>>(object: I): MsgDeposit;
    fromSDK(object: MsgDepositSDKType): MsgDeposit;
    toSDK(message: MsgDeposit): MsgDepositSDKType;
};
export declare const MsgDepositResponse: {
    encode(_: MsgDepositResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDepositResponse;
    fromJSON(_: any): MsgDepositResponse;
    toJSON(_: MsgDepositResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDepositResponse;
    fromSDK(_: MsgDepositResponseSDKType): MsgDepositResponse;
    toSDK(_: MsgDepositResponse): MsgDepositResponseSDKType;
};
export declare const MsgEditStorageProvider: {
    encode(message: MsgEditStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditStorageProvider;
    fromJSON(object: any): MsgEditStorageProvider;
    toJSON(message: MsgEditStorageProvider): unknown;
    fromPartial<I extends {
        spAddress?: string | undefined;
        endpoint?: string | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
    } & {
        spAddress?: string | undefined;
        endpoint?: string | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgEditStorageProvider>, never>>(object: I): MsgEditStorageProvider;
    fromSDK(object: MsgEditStorageProviderSDKType): MsgEditStorageProvider;
    toSDK(message: MsgEditStorageProvider): MsgEditStorageProviderSDKType;
};
export declare const MsgEditStorageProviderResponse: {
    encode(_: MsgEditStorageProviderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditStorageProviderResponse;
    fromJSON(_: any): MsgEditStorageProviderResponse;
    toJSON(_: MsgEditStorageProviderResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgEditStorageProviderResponse;
    fromSDK(_: MsgEditStorageProviderResponseSDKType): MsgEditStorageProviderResponse;
    toSDK(_: MsgEditStorageProviderResponse): MsgEditStorageProviderResponseSDKType;
};
export declare const MsgUpdateSpStoragePrice: {
    encode(message: MsgUpdateSpStoragePrice, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateSpStoragePrice;
    fromJSON(object: any): MsgUpdateSpStoragePrice;
    toJSON(message: MsgUpdateSpStoragePrice): unknown;
    fromPartial<I extends {
        spAddress?: string | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | Long.Long | undefined;
        storePrice?: string | undefined;
    } & {
        spAddress?: string | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["freeReadQuota"], keyof Long.Long>, never>) | undefined;
        storePrice?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgUpdateSpStoragePrice>, never>>(object: I): MsgUpdateSpStoragePrice;
    fromSDK(object: MsgUpdateSpStoragePriceSDKType): MsgUpdateSpStoragePrice;
    toSDK(message: MsgUpdateSpStoragePrice): MsgUpdateSpStoragePriceSDKType;
};
export declare const MsgUpdateSpStoragePriceResponse: {
    encode(_: MsgUpdateSpStoragePriceResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateSpStoragePriceResponse;
    fromJSON(_: any): MsgUpdateSpStoragePriceResponse;
    toJSON(_: MsgUpdateSpStoragePriceResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateSpStoragePriceResponse;
    fromSDK(_: MsgUpdateSpStoragePriceResponseSDKType): MsgUpdateSpStoragePriceResponse;
    toSDK(_: MsgUpdateSpStoragePriceResponse): MsgUpdateSpStoragePriceResponseSDKType;
};
export declare const MsgUpdateParams: {
    encode(message: MsgUpdateParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams;
    fromJSON(object: any): MsgUpdateParams;
    toJSON(message: MsgUpdateParams): unknown;
    fromPartial<I extends {
        authority?: string | undefined;
        params?: {
            depositDenom?: string | undefined;
            minDeposit?: string | undefined;
            secondarySpStorePriceRatio?: string | undefined;
        } | undefined;
    } & {
        authority?: string | undefined;
        params?: ({
            depositDenom?: string | undefined;
            minDeposit?: string | undefined;
            secondarySpStorePriceRatio?: string | undefined;
        } & {
            depositDenom?: string | undefined;
            minDeposit?: string | undefined;
            secondarySpStorePriceRatio?: string | undefined;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgUpdateParams>, never>>(object: I): MsgUpdateParams;
    fromSDK(object: MsgUpdateParamsSDKType): MsgUpdateParams;
    toSDK(message: MsgUpdateParams): MsgUpdateParamsSDKType;
};
export declare const MsgUpdateParamsResponse: {
    encode(_: MsgUpdateParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParamsResponse;
    fromJSON(_: any): MsgUpdateParamsResponse;
    toJSON(_: MsgUpdateParamsResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateParamsResponse;
    fromSDK(_: MsgUpdateParamsResponseSDKType): MsgUpdateParamsResponse;
    toSDK(_: MsgUpdateParamsResponse): MsgUpdateParamsResponseSDKType;
};
/** Msg defines the Msg service for creating a new storage provider.
 TODO: add a transaction that the Storage Provide claim themself enter short time maintenance to avoid slash */
export interface Msg {
    CreateStorageProvider(request: MsgCreateStorageProvider): Promise<MsgCreateStorageProviderResponse>;
    Deposit(request: MsgDeposit): Promise<MsgDepositResponse>;
    EditStorageProvider(request: MsgEditStorageProvider): Promise<MsgEditStorageProviderResponse>;
    UpdateSpStoragePrice(request: MsgUpdateSpStoragePrice): Promise<MsgUpdateSpStoragePriceResponse>;
    /**
     * UpdateParams defines a governance operation for updating the x/sp module parameters.
     * The authority is defined in the keeper.
     *
     * Since: cosmos-sdk 0.47
     */
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    constructor(rpc: Rpc);
    CreateStorageProvider(request: MsgCreateStorageProvider): Promise<MsgCreateStorageProviderResponse>;
    Deposit(request: MsgDeposit): Promise<MsgDepositResponse>;
    EditStorageProvider(request: MsgEditStorageProvider): Promise<MsgEditStorageProviderResponse>;
    UpdateSpStoragePrice(request: MsgUpdateSpStoragePrice): Promise<MsgUpdateSpStoragePriceResponse>;
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}
