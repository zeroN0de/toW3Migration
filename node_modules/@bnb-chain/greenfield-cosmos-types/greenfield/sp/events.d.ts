/// <reference types="long" />
import { Coin, CoinSDKType } from "../../cosmos/base/v1beta1/coin";
import { Status, Description, DescriptionSDKType } from "./types";
import * as _m0 from "protobufjs/minimal";
import { Long } from "../../helpers";
export declare const protobufPackage = "greenfield.sp";
/** EventCreateStorageProvider is emitted when there is a storage provider created */
export interface EventCreateStorageProvider {
    /** sp_address is the operator address of the storage provider */
    spAddress: string;
    /** funding_address is the funding account address of the storage provider */
    fundingAddress: string;
    /** seal_address is the account address for SealObject Tx */
    sealAddress: string;
    /** approval_address is the account address for approve create bucket/object signature */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose */
    gcAddress: string;
    /** endpoint is the domain name address used by SP to provide storage services */
    endpoint: string;
    /** total_deposit is the token coin that the storage provider deposit to the storage module */
    totalDeposit?: Coin;
    /** status defines the status of the storage provider */
    status: Status;
    /** description defines the description terms for the storage provider */
    description?: Description;
}
/** EventCreateStorageProvider is emitted when there is a storage provider created */
export interface EventCreateStorageProviderSDKType {
    sp_address: string;
    funding_address: string;
    seal_address: string;
    approval_address: string;
    gc_address: string;
    endpoint: string;
    total_deposit?: CoinSDKType;
    status: Status;
    description?: DescriptionSDKType;
}
/** EventEditStorageProvider is emitted when SP's metadata is edited. */
export interface EventEditStorageProvider {
    /** sp_address is the operator address of the storage provider */
    spAddress: string;
    /** endpoint is the service endpoint of the storage provider */
    endpoint: string;
    /** description defines the description terms for the storage provider */
    description?: Description;
    /** seal_address is the account address for SealObject Tx */
    sealAddress: string;
    /** approval_address is the account address for approve create bucket/object signature */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose */
    gcAddress: string;
}
/** EventEditStorageProvider is emitted when SP's metadata is edited. */
export interface EventEditStorageProviderSDKType {
    sp_address: string;
    endpoint: string;
    description?: DescriptionSDKType;
    seal_address: string;
    approval_address: string;
    gc_address: string;
}
/** EventDeposit is emitted when sp deposit tokens. */
export interface EventDeposit {
    /** funding_address is the funding account address of the storage provider */
    fundingAddress: string;
    /** deposit is the token coin deposited this message */
    deposit: string;
    /** total_deposit is the total token coins this storage provider deposited */
    totalDeposit: string;
}
/** EventDeposit is emitted when sp deposit tokens. */
export interface EventDepositSDKType {
    funding_address: string;
    deposit: string;
    total_deposit: string;
}
export interface EventSpStoragePriceUpdate {
    /** sp address */
    spAddress: string;
    /** update time, in unix timestamp */
    updateTimeSec: Long;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** free read quota, in byte */
    freeReadQuota: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
export interface EventSpStoragePriceUpdateSDKType {
    sp_address: string;
    update_time_sec: Long;
    read_price: string;
    free_read_quota: Long;
    store_price: string;
}
export interface EventSecondarySpStorePriceUpdate {
    /** update time, in unix timestamp */
    updateTimeSec: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
export interface EventSecondarySpStorePriceUpdateSDKType {
    update_time_sec: Long;
    store_price: string;
}
export declare const EventCreateStorageProvider: {
    encode(message: EventCreateStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateStorageProvider;
    fromJSON(object: any): EventCreateStorageProvider;
    toJSON(message: EventCreateStorageProvider): unknown;
    fromPartial<I extends {
        spAddress?: string | undefined;
        fundingAddress?: string | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
        endpoint?: string | undefined;
        totalDeposit?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        status?: Status | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
    } & {
        spAddress?: string | undefined;
        fundingAddress?: string | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
        endpoint?: string | undefined;
        totalDeposit?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["totalDeposit"], keyof Coin>, never>) | undefined;
        status?: Status | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventCreateStorageProvider>, never>>(object: I): EventCreateStorageProvider;
    fromSDK(object: EventCreateStorageProviderSDKType): EventCreateStorageProvider;
    toSDK(message: EventCreateStorageProvider): EventCreateStorageProviderSDKType;
};
export declare const EventEditStorageProvider: {
    encode(message: EventEditStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventEditStorageProvider;
    fromJSON(object: any): EventEditStorageProvider;
    toJSON(message: EventEditStorageProvider): unknown;
    fromPartial<I extends {
        spAddress?: string | undefined;
        endpoint?: string | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
    } & {
        spAddress?: string | undefined;
        endpoint?: string | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventEditStorageProvider>, never>>(object: I): EventEditStorageProvider;
    fromSDK(object: EventEditStorageProviderSDKType): EventEditStorageProvider;
    toSDK(message: EventEditStorageProvider): EventEditStorageProviderSDKType;
};
export declare const EventDeposit: {
    encode(message: EventDeposit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeposit;
    fromJSON(object: any): EventDeposit;
    toJSON(message: EventDeposit): unknown;
    fromPartial<I extends {
        fundingAddress?: string | undefined;
        deposit?: string | undefined;
        totalDeposit?: string | undefined;
    } & {
        fundingAddress?: string | undefined;
        deposit?: string | undefined;
        totalDeposit?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventDeposit>, never>>(object: I): EventDeposit;
    fromSDK(object: EventDepositSDKType): EventDeposit;
    toSDK(message: EventDeposit): EventDepositSDKType;
};
export declare const EventSpStoragePriceUpdate: {
    encode(message: EventSpStoragePriceUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSpStoragePriceUpdate;
    fromJSON(object: any): EventSpStoragePriceUpdate;
    toJSON(message: EventSpStoragePriceUpdate): unknown;
    fromPartial<I extends {
        spAddress?: string | undefined;
        updateTimeSec?: string | number | Long.Long | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | Long.Long | undefined;
        storePrice?: string | undefined;
    } & {
        spAddress?: string | undefined;
        updateTimeSec?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateTimeSec"], keyof Long.Long>, never>) | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["freeReadQuota"], keyof Long.Long>, never>) | undefined;
        storePrice?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventSpStoragePriceUpdate>, never>>(object: I): EventSpStoragePriceUpdate;
    fromSDK(object: EventSpStoragePriceUpdateSDKType): EventSpStoragePriceUpdate;
    toSDK(message: EventSpStoragePriceUpdate): EventSpStoragePriceUpdateSDKType;
};
export declare const EventSecondarySpStorePriceUpdate: {
    encode(message: EventSecondarySpStorePriceUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSecondarySpStorePriceUpdate;
    fromJSON(object: any): EventSecondarySpStorePriceUpdate;
    toJSON(message: EventSecondarySpStorePriceUpdate): unknown;
    fromPartial<I extends {
        updateTimeSec?: string | number | Long.Long | undefined;
        storePrice?: string | undefined;
    } & {
        updateTimeSec?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateTimeSec"], keyof Long.Long>, never>) | undefined;
        storePrice?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventSecondarySpStorePriceUpdate>, never>>(object: I): EventSecondarySpStorePriceUpdate;
    fromSDK(object: EventSecondarySpStorePriceUpdateSDKType): EventSecondarySpStorePriceUpdate;
    toSDK(message: EventSecondarySpStorePriceUpdate): EventSecondarySpStorePriceUpdateSDKType;
};
