/// <reference types="long" />
import { Coin, CoinSDKType } from "../../cosmos/base/v1beta1/coin";
import * as _m0 from "protobufjs/minimal";
import { Long } from "../../helpers";
export declare const protobufPackage = "greenfield.sp";
/** Status is the status of a storage provider. */
export declare enum Status {
    STATUS_IN_SERVICE = 0,
    STATUS_IN_JAILED = 1,
    STATUS_GRACEFUL_EXITING = 2,
    STATUS_OUT_OF_SERVICE = 3,
    UNRECOGNIZED = -1
}
export declare const StatusSDKType: typeof Status;
export declare function statusFromJSON(object: any): Status;
export declare function statusToJSON(object: Status): string;
/** Description defines a storage provider description. */
export interface Description {
    /** moniker defines a human-readable name for the storage provider */
    moniker: string;
    /** identity defines an optional identity signature (ex. UPort or Keybase). */
    identity: string;
    /** website defines an optional website link. */
    website: string;
    /** security_contact defines an optional email for security contact. */
    securityContact: string;
    /** details define other optional details. */
    details: string;
}
/** Description defines a storage provider description. */
export interface DescriptionSDKType {
    moniker: string;
    identity: string;
    website: string;
    security_contact: string;
    details: string;
}
/** StorageProvider defines the meta info of storage provider */
export interface StorageProvider {
    /** operator_address defines the account address of the storage provider's operator; It also is the unique index key of sp. */
    operatorAddress: string;
    /** funding_address defines one of the storage provider's accounts which is used to deposit and reward. */
    fundingAddress: string;
    /** seal_address defines one of the storage provider's accounts which is used to SealObject */
    sealAddress: string;
    /** approval_address defines one of the storage provider's accounts which is used to approve use's createBucket/createObject request */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose. */
    gcAddress: string;
    /** total_deposit defines the number of tokens deposited by this storage provider for staking. */
    totalDeposit: string;
    /** status defines the current service status of this storage provider */
    status: Status;
    /** endpoint define the storage provider's network service address */
    endpoint: string;
    /** description defines the description terms for the storage provider. */
    description?: Description;
}
/** StorageProvider defines the meta info of storage provider */
export interface StorageProviderSDKType {
    operator_address: string;
    funding_address: string;
    seal_address: string;
    approval_address: string;
    gc_address: string;
    total_deposit: string;
    status: Status;
    endpoint: string;
    description?: DescriptionSDKType;
}
export interface RewardInfo {
    address: string;
    amount?: Coin;
}
export interface RewardInfoSDKType {
    address: string;
    amount?: CoinSDKType;
}
/** storage price of a specific sp */
export interface SpStoragePrice {
    /** sp address */
    spAddress: string;
    /** update time, unix timestamp in seconds */
    updateTimeSec: Long;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** free read quota, in byte */
    freeReadQuota: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
/** storage price of a specific sp */
export interface SpStoragePriceSDKType {
    sp_address: string;
    update_time_sec: Long;
    read_price: string;
    free_read_quota: Long;
    store_price: string;
}
/** global secondary sp store price, the price for all secondary sps */
export interface SecondarySpStorePrice {
    /** update time, unix timestamp in seconds */
    updateTimeSec: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
/** global secondary sp store price, the price for all secondary sps */
export interface SecondarySpStorePriceSDKType {
    update_time_sec: Long;
    store_price: string;
}
export declare const Description: {
    encode(message: Description, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Description;
    fromJSON(object: any): Description;
    toJSON(message: Description): unknown;
    fromPartial<I extends {
        moniker?: string | undefined;
        identity?: string | undefined;
        website?: string | undefined;
        securityContact?: string | undefined;
        details?: string | undefined;
    } & {
        moniker?: string | undefined;
        identity?: string | undefined;
        website?: string | undefined;
        securityContact?: string | undefined;
        details?: string | undefined;
    } & Record<Exclude<keyof I, keyof Description>, never>>(object: I): Description;
    fromSDK(object: DescriptionSDKType): Description;
    toSDK(message: Description): DescriptionSDKType;
};
export declare const StorageProvider: {
    encode(message: StorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StorageProvider;
    fromJSON(object: any): StorageProvider;
    toJSON(message: StorageProvider): unknown;
    fromPartial<I extends {
        operatorAddress?: string | undefined;
        fundingAddress?: string | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
        totalDeposit?: string | undefined;
        status?: Status | undefined;
        endpoint?: string | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
    } & {
        operatorAddress?: string | undefined;
        fundingAddress?: string | undefined;
        sealAddress?: string | undefined;
        approvalAddress?: string | undefined;
        gcAddress?: string | undefined;
        totalDeposit?: string | undefined;
        status?: Status | undefined;
        endpoint?: string | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof StorageProvider>, never>>(object: I): StorageProvider;
    fromSDK(object: StorageProviderSDKType): StorageProvider;
    toSDK(message: StorageProvider): StorageProviderSDKType;
};
export declare const RewardInfo: {
    encode(message: RewardInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RewardInfo;
    fromJSON(object: any): RewardInfo;
    toJSON(message: RewardInfo): unknown;
    fromPartial<I extends {
        address?: string | undefined;
        amount?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
    } & {
        address?: string | undefined;
        amount?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["amount"], keyof Coin>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof RewardInfo>, never>>(object: I): RewardInfo;
    fromSDK(object: RewardInfoSDKType): RewardInfo;
    toSDK(message: RewardInfo): RewardInfoSDKType;
};
export declare const SpStoragePrice: {
    encode(message: SpStoragePrice, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SpStoragePrice;
    fromJSON(object: any): SpStoragePrice;
    toJSON(message: SpStoragePrice): unknown;
    fromPartial<I extends {
        spAddress?: string | undefined;
        updateTimeSec?: string | number | Long.Long | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | Long.Long | undefined;
        storePrice?: string | undefined;
    } & {
        spAddress?: string | undefined;
        updateTimeSec?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateTimeSec"], keyof Long.Long>, never>) | undefined;
        readPrice?: string | undefined;
        freeReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["freeReadQuota"], keyof Long.Long>, never>) | undefined;
        storePrice?: string | undefined;
    } & Record<Exclude<keyof I, keyof SpStoragePrice>, never>>(object: I): SpStoragePrice;
    fromSDK(object: SpStoragePriceSDKType): SpStoragePrice;
    toSDK(message: SpStoragePrice): SpStoragePriceSDKType;
};
export declare const SecondarySpStorePrice: {
    encode(message: SecondarySpStorePrice, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SecondarySpStorePrice;
    fromJSON(object: any): SecondarySpStorePrice;
    toJSON(message: SecondarySpStorePrice): unknown;
    fromPartial<I extends {
        updateTimeSec?: string | number | Long.Long | undefined;
        storePrice?: string | undefined;
    } & {
        updateTimeSec?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateTimeSec"], keyof Long.Long>, never>) | undefined;
        storePrice?: string | undefined;
    } & Record<Exclude<keyof I, keyof SecondarySpStorePrice>, never>>(object: I): SecondarySpStorePrice;
    fromSDK(object: SecondarySpStorePriceSDKType): SecondarySpStorePrice;
    toSDK(message: SecondarySpStorePrice): SecondarySpStorePriceSDKType;
};
