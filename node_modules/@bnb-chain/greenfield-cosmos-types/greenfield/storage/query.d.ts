import { PageRequest, PageRequestSDKType, PageResponse, PageResponseSDKType } from "../../cosmos/base/query/v1beta1/pagination";
import { ActionType, Effect } from "../permission/common";
import { Params, ParamsSDKType } from "./params";
import { BucketInfo, BucketInfoSDKType, ObjectInfo, ObjectInfoSDKType, BucketMetaData, BucketMetaDataSDKType, ObjectMetaData, ObjectMetaDataSDKType, GroupMetaData, GroupMetaDataSDKType, GroupInfo, GroupInfoSDKType } from "./types";
import { Policy, PolicySDKType, GroupMember, GroupMemberSDKType } from "../permission/types";
import * as _m0 from "protobufjs/minimal";
import { Rpc } from "../../helpers";
export declare const protobufPackage = "greenfield.storage";
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestSDKType {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
    /** params holds all the parameters of this module. */
    params?: Params;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseSDKType {
    params?: ParamsSDKType;
}
export interface QueryHeadBucketRequest {
    bucketName: string;
}
export interface QueryHeadBucketRequestSDKType {
    bucket_name: string;
}
export interface QueryHeadBucketByIdRequest {
    bucketId: string;
}
export interface QueryHeadBucketByIdRequestSDKType {
    bucket_id: string;
}
export interface QueryHeadBucketResponse {
    bucketInfo?: BucketInfo;
}
export interface QueryHeadBucketResponseSDKType {
    bucket_info?: BucketInfoSDKType;
}
export interface QueryHeadObjectRequest {
    bucketName: string;
    objectName: string;
}
export interface QueryHeadObjectRequestSDKType {
    bucket_name: string;
    object_name: string;
}
export interface QueryHeadObjectByIdRequest {
    objectId: string;
}
export interface QueryHeadObjectByIdRequestSDKType {
    object_id: string;
}
export interface QueryHeadObjectResponse {
    objectInfo?: ObjectInfo;
}
export interface QueryHeadObjectResponseSDKType {
    object_info?: ObjectInfoSDKType;
}
export interface QueryListBucketsRequest {
    pagination?: PageRequest;
}
export interface QueryListBucketsRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryListBucketsResponse {
    bucketInfos: BucketInfo[];
    pagination?: PageResponse;
}
export interface QueryListBucketsResponseSDKType {
    bucket_infos: BucketInfoSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryListObjectsRequest {
    pagination?: PageRequest;
    bucketName: string;
}
export interface QueryListObjectsRequestSDKType {
    pagination?: PageRequestSDKType;
    bucket_name: string;
}
export interface QueryListObjectsByBucketIdRequest {
    pagination?: PageRequest;
    bucketId: string;
}
export interface QueryListObjectsByBucketIdRequestSDKType {
    pagination?: PageRequestSDKType;
    bucket_id: string;
}
export interface QueryListObjectsResponse {
    objectInfos: ObjectInfo[];
    pagination?: PageResponse;
}
export interface QueryListObjectsResponseSDKType {
    object_infos: ObjectInfoSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryNFTRequest {
    tokenId: string;
}
export interface QueryNFTRequestSDKType {
    token_id: string;
}
export interface QueryBucketNFTResponse {
    metaData?: BucketMetaData;
}
export interface QueryBucketNFTResponseSDKType {
    meta_data?: BucketMetaDataSDKType;
}
export interface QueryObjectNFTResponse {
    metaData?: ObjectMetaData;
}
export interface QueryObjectNFTResponseSDKType {
    meta_data?: ObjectMetaDataSDKType;
}
export interface QueryGroupNFTResponse {
    metaData?: GroupMetaData;
}
export interface QueryGroupNFTResponseSDKType {
    meta_data?: GroupMetaDataSDKType;
}
export interface QueryPolicyForAccountRequest {
    resource: string;
    principalAddress: string;
}
export interface QueryPolicyForAccountRequestSDKType {
    resource: string;
    principal_address: string;
}
export interface QueryPolicyForAccountResponse {
    policy?: Policy;
}
export interface QueryPolicyForAccountResponseSDKType {
    policy?: PolicySDKType;
}
export interface QueryVerifyPermissionRequest {
    operator: string;
    bucketName: string;
    objectName: string;
    actionType: ActionType;
}
export interface QueryVerifyPermissionRequestSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    action_type: ActionType;
}
export interface QueryVerifyPermissionResponse {
    effect: Effect;
}
export interface QueryVerifyPermissionResponseSDKType {
    effect: Effect;
}
export interface QueryHeadGroupRequest {
    groupOwner: string;
    groupName: string;
}
export interface QueryHeadGroupRequestSDKType {
    group_owner: string;
    group_name: string;
}
export interface QueryHeadGroupResponse {
    groupInfo?: GroupInfo;
}
export interface QueryHeadGroupResponseSDKType {
    group_info?: GroupInfoSDKType;
}
export interface QueryListGroupRequest {
    pagination?: PageRequest;
    groupOwner: string;
}
export interface QueryListGroupRequestSDKType {
    pagination?: PageRequestSDKType;
    group_owner: string;
}
export interface QueryListGroupResponse {
    pagination?: PageResponse;
    groupInfos: GroupInfo[];
}
export interface QueryListGroupResponseSDKType {
    pagination?: PageResponseSDKType;
    group_infos: GroupInfoSDKType[];
}
export interface QueryHeadGroupMemberRequest {
    member: string;
    groupOwner: string;
    groupName: string;
}
export interface QueryHeadGroupMemberRequestSDKType {
    member: string;
    group_owner: string;
    group_name: string;
}
export interface QueryHeadGroupMemberResponse {
    groupMember?: GroupMember;
}
export interface QueryHeadGroupMemberResponseSDKType {
    group_member?: GroupMemberSDKType;
}
export interface QueryPolicyForGroupRequest {
    resource: string;
    principalGroupId: string;
}
export interface QueryPolicyForGroupRequestSDKType {
    resource: string;
    principal_group_id: string;
}
export interface QueryPolicyForGroupResponse {
    policy?: Policy;
}
export interface QueryPolicyForGroupResponseSDKType {
    policy?: PolicySDKType;
}
export interface QueryPolicyByIdRequest {
    policyId: string;
}
export interface QueryPolicyByIdRequestSDKType {
    policy_id: string;
}
export interface QueryPolicyByIdResponse {
    policy?: Policy;
}
export interface QueryPolicyByIdResponseSDKType {
    policy?: PolicySDKType;
}
export declare const QueryParamsRequest: {
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
    fromSDK(_: QueryParamsRequestSDKType): QueryParamsRequest;
    toSDK(_: QueryParamsRequest): QueryParamsRequestSDKType;
};
export declare const QueryParamsResponse: {
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | import("long").Long | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | import("long").Long | undefined;
            } | undefined;
            maxPayloadSize?: string | number | import("long").Long | undefined;
            mirrorBucketRelayerFee?: string | undefined;
            mirrorBucketAckRelayerFee?: string | undefined;
            mirrorObjectRelayerFee?: string | undefined;
            mirrorObjectAckRelayerFee?: string | undefined;
            mirrorGroupRelayerFee?: string | undefined;
            mirrorGroupAckRelayerFee?: string | undefined;
            maxBucketsPerAccount?: number | undefined;
            discontinueCountingWindow?: string | number | import("long").Long | undefined;
            discontinueObjectMax?: string | number | import("long").Long | undefined;
            discontinueBucketMax?: string | number | import("long").Long | undefined;
            discontinueConfirmPeriod?: string | number | import("long").Long | undefined;
            discontinueDeletionMax?: string | number | import("long").Long | undefined;
            stalePolicyCleanupMax?: string | number | import("long").Long | undefined;
        } | undefined;
    } & {
        params?: ({
            versionedParams?: {
                maxSegmentSize?: string | number | import("long").Long | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | import("long").Long | undefined;
            } | undefined;
            maxPayloadSize?: string | number | import("long").Long | undefined;
            mirrorBucketRelayerFee?: string | undefined;
            mirrorBucketAckRelayerFee?: string | undefined;
            mirrorObjectRelayerFee?: string | undefined;
            mirrorObjectAckRelayerFee?: string | undefined;
            mirrorGroupRelayerFee?: string | undefined;
            mirrorGroupAckRelayerFee?: string | undefined;
            maxBucketsPerAccount?: number | undefined;
            discontinueCountingWindow?: string | number | import("long").Long | undefined;
            discontinueObjectMax?: string | number | import("long").Long | undefined;
            discontinueBucketMax?: string | number | import("long").Long | undefined;
            discontinueConfirmPeriod?: string | number | import("long").Long | undefined;
            discontinueDeletionMax?: string | number | import("long").Long | undefined;
            stalePolicyCleanupMax?: string | number | import("long").Long | undefined;
        } & {
            versionedParams?: ({
                maxSegmentSize?: string | number | import("long").Long | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | import("long").Long | undefined;
            } & {
                maxSegmentSize?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["maxSegmentSize"], keyof import("long").Long>, never>) | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["minChargeSize"], keyof import("long").Long>, never>) | undefined;
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>) | undefined;
            maxPayloadSize?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["maxPayloadSize"], keyof import("long").Long>, never>) | undefined;
            mirrorBucketRelayerFee?: string | undefined;
            mirrorBucketAckRelayerFee?: string | undefined;
            mirrorObjectRelayerFee?: string | undefined;
            mirrorObjectAckRelayerFee?: string | undefined;
            mirrorGroupRelayerFee?: string | undefined;
            mirrorGroupAckRelayerFee?: string | undefined;
            maxBucketsPerAccount?: number | undefined;
            discontinueCountingWindow?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["discontinueCountingWindow"], keyof import("long").Long>, never>) | undefined;
            discontinueObjectMax?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["discontinueObjectMax"], keyof import("long").Long>, never>) | undefined;
            discontinueBucketMax?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["discontinueBucketMax"], keyof import("long").Long>, never>) | undefined;
            discontinueConfirmPeriod?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["discontinueConfirmPeriod"], keyof import("long").Long>, never>) | undefined;
            discontinueDeletionMax?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["discontinueDeletionMax"], keyof import("long").Long>, never>) | undefined;
            stalePolicyCleanupMax?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["stalePolicyCleanupMax"], keyof import("long").Long>, never>) | undefined;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>) | undefined;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
    fromSDK(object: QueryParamsResponseSDKType): QueryParamsResponse;
    toSDK(message: QueryParamsResponse): QueryParamsResponseSDKType;
};
export declare const QueryHeadBucketRequest: {
    encode(message: QueryHeadBucketRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketRequest;
    fromJSON(object: any): QueryHeadBucketRequest;
    toJSON(message: QueryHeadBucketRequest): unknown;
    fromPartial<I extends {
        bucketName?: string | undefined;
    } & {
        bucketName?: string | undefined;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryHeadBucketRequest;
    fromSDK(object: QueryHeadBucketRequestSDKType): QueryHeadBucketRequest;
    toSDK(message: QueryHeadBucketRequest): QueryHeadBucketRequestSDKType;
};
export declare const QueryHeadBucketByIdRequest: {
    encode(message: QueryHeadBucketByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketByIdRequest;
    fromJSON(object: any): QueryHeadBucketByIdRequest;
    toJSON(message: QueryHeadBucketByIdRequest): unknown;
    fromPartial<I extends {
        bucketId?: string | undefined;
    } & {
        bucketId?: string | undefined;
    } & Record<Exclude<keyof I, "bucketId">, never>>(object: I): QueryHeadBucketByIdRequest;
    fromSDK(object: QueryHeadBucketByIdRequestSDKType): QueryHeadBucketByIdRequest;
    toSDK(message: QueryHeadBucketByIdRequest): QueryHeadBucketByIdRequestSDKType;
};
export declare const QueryHeadBucketResponse: {
    encode(message: QueryHeadBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketResponse;
    fromJSON(object: any): QueryHeadBucketResponse;
    toJSON(message: QueryHeadBucketResponse): unknown;
    fromPartial<I extends {
        bucketInfo?: {
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | import("long").Long | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | import("long").Long | undefined;
            billingInfo?: {
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        } | undefined;
    } & {
        bucketInfo?: ({
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | import("long").Long | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | import("long").Long | undefined;
            billingInfo?: {
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        } & {
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["bucketInfo"]["createAt"], keyof import("long").Long>, never>) | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["bucketInfo"]["chargedReadQuota"], keyof import("long").Long>, never>) | undefined;
            billingInfo?: ({
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } & {
                priceTime?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["bucketInfo"]["billingInfo"]["priceTime"], keyof import("long").Long>, never>) | undefined;
                totalChargeSize?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["bucketInfo"]["billingInfo"]["totalChargeSize"], keyof import("long").Long>, never>) | undefined;
                secondarySpObjectsSize?: ({
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] & ({
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                } & {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["bucketInfo"]["billingInfo"]["secondarySpObjectsSize"][number]["totalChargeSize"], keyof import("long").Long>, never>) | undefined;
                } & Record<Exclude<keyof I["bucketInfo"]["billingInfo"]["secondarySpObjectsSize"][number], keyof import("./types").SecondarySpObjectsSize>, never>)[] & Record<Exclude<keyof I["bucketInfo"]["billingInfo"]["secondarySpObjectsSize"], keyof {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[]>, never>) | undefined;
            } & Record<Exclude<keyof I["bucketInfo"]["billingInfo"], keyof import("./types").BillingInfo>, never>) | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        } & Record<Exclude<keyof I["bucketInfo"], keyof BucketInfo>, never>) | undefined;
    } & Record<Exclude<keyof I, "bucketInfo">, never>>(object: I): QueryHeadBucketResponse;
    fromSDK(object: QueryHeadBucketResponseSDKType): QueryHeadBucketResponse;
    toSDK(message: QueryHeadBucketResponse): QueryHeadBucketResponseSDKType;
};
export declare const QueryHeadObjectRequest: {
    encode(message: QueryHeadObjectRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectRequest;
    fromJSON(object: any): QueryHeadObjectRequest;
    toJSON(message: QueryHeadObjectRequest): unknown;
    fromPartial<I extends {
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & {
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryHeadObjectRequest>, never>>(object: I): QueryHeadObjectRequest;
    fromSDK(object: QueryHeadObjectRequestSDKType): QueryHeadObjectRequest;
    toSDK(message: QueryHeadObjectRequest): QueryHeadObjectRequestSDKType;
};
export declare const QueryHeadObjectByIdRequest: {
    encode(message: QueryHeadObjectByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectByIdRequest;
    fromJSON(object: any): QueryHeadObjectByIdRequest;
    toJSON(message: QueryHeadObjectByIdRequest): unknown;
    fromPartial<I extends {
        objectId?: string | undefined;
    } & {
        objectId?: string | undefined;
    } & Record<Exclude<keyof I, "objectId">, never>>(object: I): QueryHeadObjectByIdRequest;
    fromSDK(object: QueryHeadObjectByIdRequestSDKType): QueryHeadObjectByIdRequest;
    toSDK(message: QueryHeadObjectByIdRequest): QueryHeadObjectByIdRequestSDKType;
};
export declare const QueryHeadObjectResponse: {
    encode(message: QueryHeadObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectResponse;
    fromJSON(object: any): QueryHeadObjectResponse;
    toJSON(message: QueryHeadObjectResponse): unknown;
    fromPartial<I extends {
        objectInfo?: {
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | import("long").Long | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | import("long").Long | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: Uint8Array[] | undefined;
            secondarySpAddresses?: string[] | undefined;
        } | undefined;
    } & {
        objectInfo?: ({
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | import("long").Long | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | import("long").Long | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: Uint8Array[] | undefined;
            secondarySpAddresses?: string[] | undefined;
        } & {
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["objectInfo"]["payloadSize"], keyof import("long").Long>, never>) | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["objectInfo"]["createAt"], keyof import("long").Long>, never>) | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["objectInfo"]["checksums"], keyof Uint8Array[]>, never>) | undefined;
            secondarySpAddresses?: (string[] & string[] & Record<Exclude<keyof I["objectInfo"]["secondarySpAddresses"], keyof string[]>, never>) | undefined;
        } & Record<Exclude<keyof I["objectInfo"], keyof ObjectInfo>, never>) | undefined;
    } & Record<Exclude<keyof I, "objectInfo">, never>>(object: I): QueryHeadObjectResponse;
    fromSDK(object: QueryHeadObjectResponseSDKType): QueryHeadObjectResponse;
    toSDK(message: QueryHeadObjectResponse): QueryHeadObjectResponseSDKType;
};
export declare const QueryListBucketsRequest: {
    encode(message: QueryListBucketsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListBucketsRequest;
    fromJSON(object: any): QueryListBucketsRequest;
    toJSON(message: QueryListBucketsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } | undefined;
    } & {
        pagination?: ({
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & {
            key?: Uint8Array | undefined;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>) | undefined;
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>) | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>) | undefined;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryListBucketsRequest;
    fromSDK(object: QueryListBucketsRequestSDKType): QueryListBucketsRequest;
    toSDK(message: QueryListBucketsRequest): QueryListBucketsRequestSDKType;
};
export declare const QueryListBucketsResponse: {
    encode(message: QueryListBucketsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListBucketsResponse;
    fromJSON(object: any): QueryListBucketsResponse;
    toJSON(message: QueryListBucketsResponse): unknown;
    fromPartial<I extends {
        bucketInfos?: {
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | import("long").Long | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | import("long").Long | undefined;
            billingInfo?: {
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        }[] | undefined;
        pagination?: {
            nextKey?: Uint8Array | undefined;
            total?: string | number | import("long").Long | undefined;
        } | undefined;
    } & {
        bucketInfos?: ({
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | import("long").Long | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | import("long").Long | undefined;
            billingInfo?: {
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        }[] & ({
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | import("long").Long | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | import("long").Long | undefined;
            billingInfo?: {
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        } & {
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["bucketInfos"][number]["createAt"], keyof import("long").Long>, never>) | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["bucketInfos"][number]["chargedReadQuota"], keyof import("long").Long>, never>) | undefined;
            billingInfo?: ({
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } & {
                priceTime?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["bucketInfos"][number]["billingInfo"]["priceTime"], keyof import("long").Long>, never>) | undefined;
                totalChargeSize?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["bucketInfos"][number]["billingInfo"]["totalChargeSize"], keyof import("long").Long>, never>) | undefined;
                secondarySpObjectsSize?: ({
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] & ({
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                } & {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["bucketInfos"][number]["billingInfo"]["secondarySpObjectsSize"][number]["totalChargeSize"], keyof import("long").Long>, never>) | undefined;
                } & Record<Exclude<keyof I["bucketInfos"][number]["billingInfo"]["secondarySpObjectsSize"][number], keyof import("./types").SecondarySpObjectsSize>, never>)[] & Record<Exclude<keyof I["bucketInfos"][number]["billingInfo"]["secondarySpObjectsSize"], keyof {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[]>, never>) | undefined;
            } & Record<Exclude<keyof I["bucketInfos"][number]["billingInfo"], keyof import("./types").BillingInfo>, never>) | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        } & Record<Exclude<keyof I["bucketInfos"][number], keyof BucketInfo>, never>)[] & Record<Exclude<keyof I["bucketInfos"], keyof {
            owner?: string | undefined;
            bucketName?: string | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            id?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            createAt?: string | number | import("long").Long | undefined;
            paymentAddress?: string | undefined;
            primarySpAddress?: string | undefined;
            chargedReadQuota?: string | number | import("long").Long | undefined;
            billingInfo?: {
                priceTime?: string | number | import("long").Long | undefined;
                totalChargeSize?: string | number | import("long").Long | undefined;
                secondarySpObjectsSize?: {
                    spAddress?: string | undefined;
                    totalChargeSize?: string | number | import("long").Long | undefined;
                }[] | undefined;
            } | undefined;
            bucketStatus?: import("./common").BucketStatus | undefined;
        }[]>, never>) | undefined;
        pagination?: ({
            nextKey?: Uint8Array | undefined;
            total?: string | number | import("long").Long | undefined;
        } & {
            nextKey?: Uint8Array | undefined;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>) | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof QueryListBucketsResponse>, never>>(object: I): QueryListBucketsResponse;
    fromSDK(object: QueryListBucketsResponseSDKType): QueryListBucketsResponse;
    toSDK(message: QueryListBucketsResponse): QueryListBucketsResponseSDKType;
};
export declare const QueryListObjectsRequest: {
    encode(message: QueryListObjectsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsRequest;
    fromJSON(object: any): QueryListObjectsRequest;
    toJSON(message: QueryListObjectsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } | undefined;
        bucketName?: string | undefined;
    } & {
        pagination?: ({
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & {
            key?: Uint8Array | undefined;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>) | undefined;
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>) | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>) | undefined;
        bucketName?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryListObjectsRequest>, never>>(object: I): QueryListObjectsRequest;
    fromSDK(object: QueryListObjectsRequestSDKType): QueryListObjectsRequest;
    toSDK(message: QueryListObjectsRequest): QueryListObjectsRequestSDKType;
};
export declare const QueryListObjectsByBucketIdRequest: {
    encode(message: QueryListObjectsByBucketIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsByBucketIdRequest;
    fromJSON(object: any): QueryListObjectsByBucketIdRequest;
    toJSON(message: QueryListObjectsByBucketIdRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } | undefined;
        bucketId?: string | undefined;
    } & {
        pagination?: ({
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & {
            key?: Uint8Array | undefined;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>) | undefined;
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>) | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>) | undefined;
        bucketId?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryListObjectsByBucketIdRequest>, never>>(object: I): QueryListObjectsByBucketIdRequest;
    fromSDK(object: QueryListObjectsByBucketIdRequestSDKType): QueryListObjectsByBucketIdRequest;
    toSDK(message: QueryListObjectsByBucketIdRequest): QueryListObjectsByBucketIdRequestSDKType;
};
export declare const QueryListObjectsResponse: {
    encode(message: QueryListObjectsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsResponse;
    fromJSON(object: any): QueryListObjectsResponse;
    toJSON(message: QueryListObjectsResponse): unknown;
    fromPartial<I extends {
        objectInfos?: {
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | import("long").Long | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | import("long").Long | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: Uint8Array[] | undefined;
            secondarySpAddresses?: string[] | undefined;
        }[] | undefined;
        pagination?: {
            nextKey?: Uint8Array | undefined;
            total?: string | number | import("long").Long | undefined;
        } | undefined;
    } & {
        objectInfos?: ({
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | import("long").Long | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | import("long").Long | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: Uint8Array[] | undefined;
            secondarySpAddresses?: string[] | undefined;
        }[] & ({
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | import("long").Long | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | import("long").Long | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: Uint8Array[] | undefined;
            secondarySpAddresses?: string[] | undefined;
        } & {
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["objectInfos"][number]["payloadSize"], keyof import("long").Long>, never>) | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["objectInfos"][number]["createAt"], keyof import("long").Long>, never>) | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["objectInfos"][number]["checksums"], keyof Uint8Array[]>, never>) | undefined;
            secondarySpAddresses?: (string[] & string[] & Record<Exclude<keyof I["objectInfos"][number]["secondarySpAddresses"], keyof string[]>, never>) | undefined;
        } & Record<Exclude<keyof I["objectInfos"][number], keyof ObjectInfo>, never>)[] & Record<Exclude<keyof I["objectInfos"], keyof {
            owner?: string | undefined;
            bucketName?: string | undefined;
            objectName?: string | undefined;
            id?: string | undefined;
            payloadSize?: string | number | import("long").Long | undefined;
            visibility?: import("./common").VisibilityType | undefined;
            contentType?: string | undefined;
            createAt?: string | number | import("long").Long | undefined;
            objectStatus?: import("./common").ObjectStatus | undefined;
            redundancyType?: import("./common").RedundancyType | undefined;
            sourceType?: import("./common").SourceType | undefined;
            checksums?: Uint8Array[] | undefined;
            secondarySpAddresses?: string[] | undefined;
        }[]>, never>) | undefined;
        pagination?: ({
            nextKey?: Uint8Array | undefined;
            total?: string | number | import("long").Long | undefined;
        } & {
            nextKey?: Uint8Array | undefined;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>) | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof QueryListObjectsResponse>, never>>(object: I): QueryListObjectsResponse;
    fromSDK(object: QueryListObjectsResponseSDKType): QueryListObjectsResponse;
    toSDK(message: QueryListObjectsResponse): QueryListObjectsResponseSDKType;
};
export declare const QueryNFTRequest: {
    encode(message: QueryNFTRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryNFTRequest;
    fromJSON(object: any): QueryNFTRequest;
    toJSON(message: QueryNFTRequest): unknown;
    fromPartial<I extends {
        tokenId?: string | undefined;
    } & {
        tokenId?: string | undefined;
    } & Record<Exclude<keyof I, "tokenId">, never>>(object: I): QueryNFTRequest;
    fromSDK(object: QueryNFTRequestSDKType): QueryNFTRequest;
    toSDK(message: QueryNFTRequest): QueryNFTRequestSDKType;
};
export declare const QueryBucketNFTResponse: {
    encode(message: QueryBucketNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryBucketNFTResponse;
    fromJSON(object: any): QueryBucketNFTResponse;
    toJSON(message: QueryBucketNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string | undefined;
            externalUrl?: string | undefined;
            bucketName?: string | undefined;
            image?: string | undefined;
            attributes?: {
                traitType?: string | undefined;
                value?: string | undefined;
            }[] | undefined;
        } | undefined;
    } & {
        metaData?: ({
            description?: string | undefined;
            externalUrl?: string | undefined;
            bucketName?: string | undefined;
            image?: string | undefined;
            attributes?: {
                traitType?: string | undefined;
                value?: string | undefined;
            }[] | undefined;
        } & {
            description?: string | undefined;
            externalUrl?: string | undefined;
            bucketName?: string | undefined;
            image?: string | undefined;
            attributes?: ({
                traitType?: string | undefined;
                value?: string | undefined;
            }[] & ({
                traitType?: string | undefined;
                value?: string | undefined;
            } & {
                traitType?: string | undefined;
                value?: string | undefined;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string | undefined;
                value?: string | undefined;
            }[]>, never>) | undefined;
        } & Record<Exclude<keyof I["metaData"], keyof BucketMetaData>, never>) | undefined;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryBucketNFTResponse;
    fromSDK(object: QueryBucketNFTResponseSDKType): QueryBucketNFTResponse;
    toSDK(message: QueryBucketNFTResponse): QueryBucketNFTResponseSDKType;
};
export declare const QueryObjectNFTResponse: {
    encode(message: QueryObjectNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryObjectNFTResponse;
    fromJSON(object: any): QueryObjectNFTResponse;
    toJSON(message: QueryObjectNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string | undefined;
            externalUrl?: string | undefined;
            objectName?: string | undefined;
            image?: string | undefined;
            attributes?: {
                traitType?: string | undefined;
                value?: string | undefined;
            }[] | undefined;
        } | undefined;
    } & {
        metaData?: ({
            description?: string | undefined;
            externalUrl?: string | undefined;
            objectName?: string | undefined;
            image?: string | undefined;
            attributes?: {
                traitType?: string | undefined;
                value?: string | undefined;
            }[] | undefined;
        } & {
            description?: string | undefined;
            externalUrl?: string | undefined;
            objectName?: string | undefined;
            image?: string | undefined;
            attributes?: ({
                traitType?: string | undefined;
                value?: string | undefined;
            }[] & ({
                traitType?: string | undefined;
                value?: string | undefined;
            } & {
                traitType?: string | undefined;
                value?: string | undefined;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string | undefined;
                value?: string | undefined;
            }[]>, never>) | undefined;
        } & Record<Exclude<keyof I["metaData"], keyof ObjectMetaData>, never>) | undefined;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryObjectNFTResponse;
    fromSDK(object: QueryObjectNFTResponseSDKType): QueryObjectNFTResponse;
    toSDK(message: QueryObjectNFTResponse): QueryObjectNFTResponseSDKType;
};
export declare const QueryGroupNFTResponse: {
    encode(message: QueryGroupNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupNFTResponse;
    fromJSON(object: any): QueryGroupNFTResponse;
    toJSON(message: QueryGroupNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string | undefined;
            externalUrl?: string | undefined;
            groupName?: string | undefined;
            image?: string | undefined;
            attributes?: {
                traitType?: string | undefined;
                value?: string | undefined;
            }[] | undefined;
        } | undefined;
    } & {
        metaData?: ({
            description?: string | undefined;
            externalUrl?: string | undefined;
            groupName?: string | undefined;
            image?: string | undefined;
            attributes?: {
                traitType?: string | undefined;
                value?: string | undefined;
            }[] | undefined;
        } & {
            description?: string | undefined;
            externalUrl?: string | undefined;
            groupName?: string | undefined;
            image?: string | undefined;
            attributes?: ({
                traitType?: string | undefined;
                value?: string | undefined;
            }[] & ({
                traitType?: string | undefined;
                value?: string | undefined;
            } & {
                traitType?: string | undefined;
                value?: string | undefined;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string | undefined;
                value?: string | undefined;
            }[]>, never>) | undefined;
        } & Record<Exclude<keyof I["metaData"], keyof GroupMetaData>, never>) | undefined;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryGroupNFTResponse;
    fromSDK(object: QueryGroupNFTResponseSDKType): QueryGroupNFTResponse;
    toSDK(message: QueryGroupNFTResponse): QueryGroupNFTResponseSDKType;
};
export declare const QueryPolicyForAccountRequest: {
    encode(message: QueryPolicyForAccountRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForAccountRequest;
    fromJSON(object: any): QueryPolicyForAccountRequest;
    toJSON(message: QueryPolicyForAccountRequest): unknown;
    fromPartial<I extends {
        resource?: string | undefined;
        principalAddress?: string | undefined;
    } & {
        resource?: string | undefined;
        principalAddress?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryPolicyForAccountRequest>, never>>(object: I): QueryPolicyForAccountRequest;
    fromSDK(object: QueryPolicyForAccountRequestSDKType): QueryPolicyForAccountRequest;
    toSDK(message: QueryPolicyForAccountRequest): QueryPolicyForAccountRequestSDKType;
};
export declare const QueryPolicyForAccountResponse: {
    encode(message: QueryPolicyForAccountResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForAccountResponse;
    fromJSON(object: any): QueryPolicyForAccountResponse;
    toJSON(message: QueryPolicyForAccountResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string | undefined;
            principal?: {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] | undefined;
            expirationTime?: {
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } | undefined;
        } | undefined;
    } & {
        policy?: ({
            id?: string | undefined;
            principal?: {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] | undefined;
            expirationTime?: {
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } | undefined;
        } & {
            id?: string | undefined;
            principal?: ({
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } & {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>) | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: ({
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] & ({
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            } & {
                effect?: Effect | undefined;
                actions?: (ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>) | undefined;
                resources?: (string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>) | undefined;
                expirationTime?: ({
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } & {
                    seconds?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof import("long").Long>, never>) | undefined;
                    nanos?: number | undefined;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>) | undefined;
                limitSize?: ({
                    value?: string | number | import("long").Long | undefined;
                } & {
                    value?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof import("long").Long>, never>) | undefined;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>) | undefined;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[]>, never>) | undefined;
            expirationTime?: ({
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } & {
                seconds?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof import("long").Long>, never>) | undefined;
                nanos?: number | undefined;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>) | undefined;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>) | undefined;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyForAccountResponse;
    fromSDK(object: QueryPolicyForAccountResponseSDKType): QueryPolicyForAccountResponse;
    toSDK(message: QueryPolicyForAccountResponse): QueryPolicyForAccountResponseSDKType;
};
export declare const QueryVerifyPermissionRequest: {
    encode(message: QueryVerifyPermissionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerifyPermissionRequest;
    fromJSON(object: any): QueryVerifyPermissionRequest;
    toJSON(message: QueryVerifyPermissionRequest): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        actionType?: ActionType | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        actionType?: ActionType | undefined;
    } & Record<Exclude<keyof I, keyof QueryVerifyPermissionRequest>, never>>(object: I): QueryVerifyPermissionRequest;
    fromSDK(object: QueryVerifyPermissionRequestSDKType): QueryVerifyPermissionRequest;
    toSDK(message: QueryVerifyPermissionRequest): QueryVerifyPermissionRequestSDKType;
};
export declare const QueryVerifyPermissionResponse: {
    encode(message: QueryVerifyPermissionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerifyPermissionResponse;
    fromJSON(object: any): QueryVerifyPermissionResponse;
    toJSON(message: QueryVerifyPermissionResponse): unknown;
    fromPartial<I extends {
        effect?: Effect | undefined;
    } & {
        effect?: Effect | undefined;
    } & Record<Exclude<keyof I, "effect">, never>>(object: I): QueryVerifyPermissionResponse;
    fromSDK(object: QueryVerifyPermissionResponseSDKType): QueryVerifyPermissionResponse;
    toSDK(message: QueryVerifyPermissionResponse): QueryVerifyPermissionResponseSDKType;
};
export declare const QueryHeadGroupRequest: {
    encode(message: QueryHeadGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupRequest;
    fromJSON(object: any): QueryHeadGroupRequest;
    toJSON(message: QueryHeadGroupRequest): unknown;
    fromPartial<I extends {
        groupOwner?: string | undefined;
        groupName?: string | undefined;
    } & {
        groupOwner?: string | undefined;
        groupName?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryHeadGroupRequest>, never>>(object: I): QueryHeadGroupRequest;
    fromSDK(object: QueryHeadGroupRequestSDKType): QueryHeadGroupRequest;
    toSDK(message: QueryHeadGroupRequest): QueryHeadGroupRequestSDKType;
};
export declare const QueryHeadGroupResponse: {
    encode(message: QueryHeadGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupResponse;
    fromJSON(object: any): QueryHeadGroupResponse;
    toJSON(message: QueryHeadGroupResponse): unknown;
    fromPartial<I extends {
        groupInfo?: {
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        } | undefined;
    } & {
        groupInfo?: ({
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        } & {
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        } & Record<Exclude<keyof I["groupInfo"], keyof GroupInfo>, never>) | undefined;
    } & Record<Exclude<keyof I, "groupInfo">, never>>(object: I): QueryHeadGroupResponse;
    fromSDK(object: QueryHeadGroupResponseSDKType): QueryHeadGroupResponse;
    toSDK(message: QueryHeadGroupResponse): QueryHeadGroupResponseSDKType;
};
export declare const QueryListGroupRequest: {
    encode(message: QueryListGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListGroupRequest;
    fromJSON(object: any): QueryListGroupRequest;
    toJSON(message: QueryListGroupRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } | undefined;
        groupOwner?: string | undefined;
    } & {
        pagination?: ({
            key?: Uint8Array | undefined;
            offset?: string | number | import("long").Long | undefined;
            limit?: string | number | import("long").Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & {
            key?: Uint8Array | undefined;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>) | undefined;
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>) | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>) | undefined;
        groupOwner?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryListGroupRequest>, never>>(object: I): QueryListGroupRequest;
    fromSDK(object: QueryListGroupRequestSDKType): QueryListGroupRequest;
    toSDK(message: QueryListGroupRequest): QueryListGroupRequestSDKType;
};
export declare const QueryListGroupResponse: {
    encode(message: QueryListGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListGroupResponse;
    fromJSON(object: any): QueryListGroupResponse;
    toJSON(message: QueryListGroupResponse): unknown;
    fromPartial<I extends {
        pagination?: {
            nextKey?: Uint8Array | undefined;
            total?: string | number | import("long").Long | undefined;
        } | undefined;
        groupInfos?: {
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        }[] | undefined;
    } & {
        pagination?: ({
            nextKey?: Uint8Array | undefined;
            total?: string | number | import("long").Long | undefined;
        } & {
            nextKey?: Uint8Array | undefined;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>) | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>) | undefined;
        groupInfos?: ({
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        }[] & ({
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        } & {
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        } & Record<Exclude<keyof I["groupInfos"][number], keyof GroupInfo>, never>)[] & Record<Exclude<keyof I["groupInfos"], keyof {
            owner?: string | undefined;
            groupName?: string | undefined;
            sourceType?: import("./common").SourceType | undefined;
            id?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof QueryListGroupResponse>, never>>(object: I): QueryListGroupResponse;
    fromSDK(object: QueryListGroupResponseSDKType): QueryListGroupResponse;
    toSDK(message: QueryListGroupResponse): QueryListGroupResponseSDKType;
};
export declare const QueryHeadGroupMemberRequest: {
    encode(message: QueryHeadGroupMemberRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupMemberRequest;
    fromJSON(object: any): QueryHeadGroupMemberRequest;
    toJSON(message: QueryHeadGroupMemberRequest): unknown;
    fromPartial<I extends {
        member?: string | undefined;
        groupOwner?: string | undefined;
        groupName?: string | undefined;
    } & {
        member?: string | undefined;
        groupOwner?: string | undefined;
        groupName?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryHeadGroupMemberRequest>, never>>(object: I): QueryHeadGroupMemberRequest;
    fromSDK(object: QueryHeadGroupMemberRequestSDKType): QueryHeadGroupMemberRequest;
    toSDK(message: QueryHeadGroupMemberRequest): QueryHeadGroupMemberRequestSDKType;
};
export declare const QueryHeadGroupMemberResponse: {
    encode(message: QueryHeadGroupMemberResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupMemberResponse;
    fromJSON(object: any): QueryHeadGroupMemberResponse;
    toJSON(message: QueryHeadGroupMemberResponse): unknown;
    fromPartial<I extends {
        groupMember?: {
            id?: string | undefined;
            groupId?: string | undefined;
            member?: string | undefined;
        } | undefined;
    } & {
        groupMember?: ({
            id?: string | undefined;
            groupId?: string | undefined;
            member?: string | undefined;
        } & {
            id?: string | undefined;
            groupId?: string | undefined;
            member?: string | undefined;
        } & Record<Exclude<keyof I["groupMember"], keyof GroupMember>, never>) | undefined;
    } & Record<Exclude<keyof I, "groupMember">, never>>(object: I): QueryHeadGroupMemberResponse;
    fromSDK(object: QueryHeadGroupMemberResponseSDKType): QueryHeadGroupMemberResponse;
    toSDK(message: QueryHeadGroupMemberResponse): QueryHeadGroupMemberResponseSDKType;
};
export declare const QueryPolicyForGroupRequest: {
    encode(message: QueryPolicyForGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForGroupRequest;
    fromJSON(object: any): QueryPolicyForGroupRequest;
    toJSON(message: QueryPolicyForGroupRequest): unknown;
    fromPartial<I extends {
        resource?: string | undefined;
        principalGroupId?: string | undefined;
    } & {
        resource?: string | undefined;
        principalGroupId?: string | undefined;
    } & Record<Exclude<keyof I, keyof QueryPolicyForGroupRequest>, never>>(object: I): QueryPolicyForGroupRequest;
    fromSDK(object: QueryPolicyForGroupRequestSDKType): QueryPolicyForGroupRequest;
    toSDK(message: QueryPolicyForGroupRequest): QueryPolicyForGroupRequestSDKType;
};
export declare const QueryPolicyForGroupResponse: {
    encode(message: QueryPolicyForGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForGroupResponse;
    fromJSON(object: any): QueryPolicyForGroupResponse;
    toJSON(message: QueryPolicyForGroupResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string | undefined;
            principal?: {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] | undefined;
            expirationTime?: {
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } | undefined;
        } | undefined;
    } & {
        policy?: ({
            id?: string | undefined;
            principal?: {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] | undefined;
            expirationTime?: {
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } | undefined;
        } & {
            id?: string | undefined;
            principal?: ({
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } & {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>) | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: ({
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] & ({
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            } & {
                effect?: Effect | undefined;
                actions?: (ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>) | undefined;
                resources?: (string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>) | undefined;
                expirationTime?: ({
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } & {
                    seconds?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof import("long").Long>, never>) | undefined;
                    nanos?: number | undefined;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>) | undefined;
                limitSize?: ({
                    value?: string | number | import("long").Long | undefined;
                } & {
                    value?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof import("long").Long>, never>) | undefined;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>) | undefined;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[]>, never>) | undefined;
            expirationTime?: ({
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } & {
                seconds?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof import("long").Long>, never>) | undefined;
                nanos?: number | undefined;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>) | undefined;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>) | undefined;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyForGroupResponse;
    fromSDK(object: QueryPolicyForGroupResponseSDKType): QueryPolicyForGroupResponse;
    toSDK(message: QueryPolicyForGroupResponse): QueryPolicyForGroupResponseSDKType;
};
export declare const QueryPolicyByIdRequest: {
    encode(message: QueryPolicyByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyByIdRequest;
    fromJSON(object: any): QueryPolicyByIdRequest;
    toJSON(message: QueryPolicyByIdRequest): unknown;
    fromPartial<I extends {
        policyId?: string | undefined;
    } & {
        policyId?: string | undefined;
    } & Record<Exclude<keyof I, "policyId">, never>>(object: I): QueryPolicyByIdRequest;
    fromSDK(object: QueryPolicyByIdRequestSDKType): QueryPolicyByIdRequest;
    toSDK(message: QueryPolicyByIdRequest): QueryPolicyByIdRequestSDKType;
};
export declare const QueryPolicyByIdResponse: {
    encode(message: QueryPolicyByIdResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyByIdResponse;
    fromJSON(object: any): QueryPolicyByIdResponse;
    toJSON(message: QueryPolicyByIdResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string | undefined;
            principal?: {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] | undefined;
            expirationTime?: {
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } | undefined;
        } | undefined;
    } & {
        policy?: ({
            id?: string | undefined;
            principal?: {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] | undefined;
            expirationTime?: {
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } | undefined;
        } & {
            id?: string | undefined;
            principal?: ({
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } & {
                type?: import("../permission/common").PrincipalType | undefined;
                value?: string | undefined;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>) | undefined;
            resourceType?: import("../resource/types").ResourceType | undefined;
            resourceId?: string | undefined;
            statements?: ({
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[] & ({
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            } & {
                effect?: Effect | undefined;
                actions?: (ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>) | undefined;
                resources?: (string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>) | undefined;
                expirationTime?: ({
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } & {
                    seconds?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof import("long").Long>, never>) | undefined;
                    nanos?: number | undefined;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>) | undefined;
                limitSize?: ({
                    value?: string | number | import("long").Long | undefined;
                } & {
                    value?: string | number | (import("long").Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long").Long) => import("long").Long;
                        and: (other: string | number | import("long").Long) => import("long").Long;
                        compare: (other: string | number | import("long").Long) => number;
                        comp: (other: string | number | import("long").Long) => number;
                        divide: (divisor: string | number | import("long").Long) => import("long").Long;
                        div: (divisor: string | number | import("long").Long) => import("long").Long;
                        equals: (other: string | number | import("long").Long) => boolean;
                        eq: (other: string | number | import("long").Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long").Long) => boolean;
                        gt: (other: string | number | import("long").Long) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        gte: (other: string | number | import("long").Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | import("long").Long) => boolean;
                        lt: (other: string | number | import("long").Long) => boolean;
                        lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                        lte: (other: string | number | import("long").Long) => boolean;
                        modulo: (other: string | number | import("long").Long) => import("long").Long;
                        mod: (other: string | number | import("long").Long) => import("long").Long;
                        multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                        mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                        negate: () => import("long").Long;
                        neg: () => import("long").Long;
                        not: () => import("long").Long;
                        notEquals: (other: string | number | import("long").Long) => boolean;
                        neq: (other: string | number | import("long").Long) => boolean;
                        or: (other: string | number | import("long").Long) => import("long").Long;
                        shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                        shl: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                        shr: (numBits: number | import("long").Long) => import("long").Long;
                        shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                        shru: (numBits: number | import("long").Long) => import("long").Long;
                        subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean | undefined) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long").Long;
                        toString: (radix?: number | undefined) => string;
                        toUnsigned: () => import("long").Long;
                        xor: (other: string | number | import("long").Long) => import("long").Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof import("long").Long>, never>) | undefined;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>) | undefined;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect | undefined;
                actions?: ActionType[] | undefined;
                resources?: string[] | undefined;
                expirationTime?: {
                    seconds?: string | number | import("long").Long | undefined;
                    nanos?: number | undefined;
                } | undefined;
                limitSize?: {
                    value?: string | number | import("long").Long | undefined;
                } | undefined;
            }[]>, never>) | undefined;
            expirationTime?: ({
                seconds?: string | number | import("long").Long | undefined;
                nanos?: number | undefined;
            } & {
                seconds?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof import("long").Long>, never>) | undefined;
                nanos?: number | undefined;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>) | undefined;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>) | undefined;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyByIdResponse;
    fromSDK(object: QueryPolicyByIdResponseSDKType): QueryPolicyByIdResponse;
    toSDK(message: QueryPolicyByIdResponse): QueryPolicyByIdResponseSDKType;
};
/** Query defines the gRPC querier service. */
export interface Query {
    /** Parameters queries the parameters of the module. */
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** Queries a bucket with specify name. */
    HeadBucket(request: QueryHeadBucketRequest): Promise<QueryHeadBucketResponse>;
    /** Queries a bucket by id */
    HeadBucketById(request: QueryHeadBucketByIdRequest): Promise<QueryHeadBucketResponse>;
    /** Queries a bucket with EIP712 standard metadata info */
    HeadBucketNFT(request: QueryNFTRequest): Promise<QueryBucketNFTResponse>;
    /** Queries a object with specify name. */
    HeadObject(request: QueryHeadObjectRequest): Promise<QueryHeadObjectResponse>;
    /** Queries an object by id */
    HeadObjectById(request: QueryHeadObjectByIdRequest): Promise<QueryHeadObjectResponse>;
    /** Queries a object with EIP712 standard metadata info */
    HeadObjectNFT(request: QueryNFTRequest): Promise<QueryObjectNFTResponse>;
    /** Queries a list of bucket items. */
    ListBuckets(request?: QueryListBucketsRequest): Promise<QueryListBucketsResponse>;
    /** Queries a list of object items under the bucket. */
    ListObjects(request: QueryListObjectsRequest): Promise<QueryListObjectsResponse>;
    /** Queries a list of object items under the bucket. */
    ListObjectsByBucketId(request: QueryListObjectsByBucketIdRequest): Promise<QueryListObjectsResponse>;
    /** Queries a group with EIP712 standard metadata info */
    HeadGroupNFT(request: QueryNFTRequest): Promise<QueryGroupNFTResponse>;
    /** Queries a policy which grants permission to account */
    QueryPolicyForAccount(request: QueryPolicyForAccountRequest): Promise<QueryPolicyForAccountResponse>;
    /** Queries a list of VerifyPermission items. */
    VerifyPermission(request: QueryVerifyPermissionRequest): Promise<QueryVerifyPermissionResponse>;
    /** Queries a group with specify owner and name . */
    HeadGroup(request: QueryHeadGroupRequest): Promise<QueryHeadGroupResponse>;
    /** Queries a list of ListGroup items. */
    ListGroup(request: QueryListGroupRequest): Promise<QueryListGroupResponse>;
    /** Queries a list of HeadGroupMember items. */
    HeadGroupMember(request: QueryHeadGroupMemberRequest): Promise<QueryHeadGroupMemberResponse>;
    /** Queries a policy that grants permission to a group */
    QueryPolicyForGroup(request: QueryPolicyForGroupRequest): Promise<QueryPolicyForGroupResponse>;
    /** Queries a policy by policy id */
    QueryPolicyById(request: QueryPolicyByIdRequest): Promise<QueryPolicyByIdResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    HeadBucket(request: QueryHeadBucketRequest): Promise<QueryHeadBucketResponse>;
    HeadBucketById(request: QueryHeadBucketByIdRequest): Promise<QueryHeadBucketResponse>;
    HeadBucketNFT(request: QueryNFTRequest): Promise<QueryBucketNFTResponse>;
    HeadObject(request: QueryHeadObjectRequest): Promise<QueryHeadObjectResponse>;
    HeadObjectById(request: QueryHeadObjectByIdRequest): Promise<QueryHeadObjectResponse>;
    HeadObjectNFT(request: QueryNFTRequest): Promise<QueryObjectNFTResponse>;
    ListBuckets(request?: QueryListBucketsRequest): Promise<QueryListBucketsResponse>;
    ListObjects(request: QueryListObjectsRequest): Promise<QueryListObjectsResponse>;
    ListObjectsByBucketId(request: QueryListObjectsByBucketIdRequest): Promise<QueryListObjectsResponse>;
    HeadGroupNFT(request: QueryNFTRequest): Promise<QueryGroupNFTResponse>;
    QueryPolicyForAccount(request: QueryPolicyForAccountRequest): Promise<QueryPolicyForAccountResponse>;
    VerifyPermission(request: QueryVerifyPermissionRequest): Promise<QueryVerifyPermissionResponse>;
    HeadGroup(request: QueryHeadGroupRequest): Promise<QueryHeadGroupResponse>;
    ListGroup(request: QueryListGroupRequest): Promise<QueryListGroupResponse>;
    HeadGroupMember(request: QueryHeadGroupMemberRequest): Promise<QueryHeadGroupMemberResponse>;
    QueryPolicyForGroup(request: QueryPolicyForGroupRequest): Promise<QueryPolicyForGroupResponse>;
    QueryPolicyById(request: QueryPolicyByIdRequest): Promise<QueryPolicyByIdResponse>;
}
