/// <reference types="long" />
import { VisibilityType, SourceType, BucketStatus, ObjectStatus, RedundancyType } from "./common";
import { Long } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
export interface BucketInfo {
    /** owner is the account address of bucket creator, it is also the bucket owner. */
    owner: string;
    /** bucket_name is a globally unique name of bucket */
    bucketName: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get storage objects in it. */
    visibility: VisibilityType;
    /** id is the unique identification for bucket. */
    id: string;
    /** source_type defines which chain the user should send the bucket management transactions to */
    sourceType: SourceType;
    /** create_at define the block timestamp when the bucket created. */
    createAt: Long;
    /** payment_address is the address of the payment account */
    paymentAddress: string;
    /**
     * primary_sp_address is the address of the primary sp. Objects belongs to this bucket will never
     * leave this SP, unless you explicitly shift them to another SP.
     */
    primarySpAddress: string;
    /**
     * charged_read_quota defines the traffic quota for read in bytes per month.
     * The available read data for each user is the sum of the free read data provided by SP and
     * the ChargeReadQuota specified here.
     */
    chargedReadQuota: Long;
    /** billing info of the bucket */
    billingInfo?: BillingInfo;
    /** bucket_status define the status of the bucket. */
    bucketStatus: BucketStatus;
}
export interface BucketInfoSDKType {
    owner: string;
    bucket_name: string;
    visibility: VisibilityType;
    id: string;
    source_type: SourceType;
    create_at: Long;
    payment_address: string;
    primary_sp_address: string;
    charged_read_quota: Long;
    billing_info?: BillingInfoSDKType;
    bucket_status: BucketStatus;
}
/** BillingInfo is the billing information of the bucket */
export interface BillingInfo {
    /** the time of the payment price, used to calculate the charge rate of the bucket */
    priceTime: Long;
    /** the total size of the objects in the bucket, used to calculate the charge rate of the bucket */
    totalChargeSize: Long;
    /** secondary sp objects size statistics */
    secondarySpObjectsSize: SecondarySpObjectsSize[];
}
/** BillingInfo is the billing information of the bucket */
export interface BillingInfoSDKType {
    price_time: Long;
    total_charge_size: Long;
    secondary_sp_objects_size: SecondarySpObjectsSizeSDKType[];
}
/** secondary sp objects size statistics */
export interface SecondarySpObjectsSize {
    /** address is the address of the secondary sp */
    spAddress: string;
    /** size is the total size of the objects in the secondary sp */
    totalChargeSize: Long;
}
/** secondary sp objects size statistics */
export interface SecondarySpObjectsSizeSDKType {
    sp_address: string;
    total_charge_size: Long;
}
export interface ObjectInfo {
    owner: string;
    /** bucket_name is the name of the bucket */
    bucketName: string;
    /** object_name is the name of object */
    objectName: string;
    /** id is the unique identifier of object */
    id: string;
    /** payloadSize is the total size of the object payload */
    payloadSize: Long;
    /** visibility defines the highest permissions for object. When an object is public, everyone can access it. */
    visibility: VisibilityType;
    /** content_type define the format of the object which should be a standard MIME type. */
    contentType: string;
    /** create_at define the block timestamp when the object is created */
    createAt: Long;
    /** object_status define the upload status of the object. */
    objectStatus: ObjectStatus;
    /** redundancy_type define the type of the redundancy which can be multi-replication or EC. */
    redundancyType: RedundancyType;
    /** source_type define the source of the object. */
    sourceType: SourceType;
    /**
     * checksums define the root hash of the pieces which stored in a SP.
     * add omit tag to omit the field when converting to NFT metadata
     */
    checksums: Uint8Array[];
    /** secondary_sp_addresses define the addresses of secondary_sps */
    secondarySpAddresses: string[];
}
export interface ObjectInfoSDKType {
    owner: string;
    bucket_name: string;
    object_name: string;
    id: string;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    create_at: Long;
    object_status: ObjectStatus;
    redundancy_type: RedundancyType;
    source_type: SourceType;
    checksums: Uint8Array[];
    secondary_sp_addresses: string[];
}
export interface GroupInfo {
    /** owner is the owner of the group. It can not changed once it created. */
    owner: string;
    /** group_name is the name of group which is unique under an account. */
    groupName: string;
    /** source_type */
    sourceType: SourceType;
    /** id is the unique identifier of group */
    id: string;
}
export interface GroupInfoSDKType {
    owner: string;
    group_name: string;
    source_type: SourceType;
    id: string;
}
export interface Trait {
    traitType: string;
    value: string;
}
export interface TraitSDKType {
    trait_type: string;
    value: string;
}
export interface BucketMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of bucket NFT */
    bucketName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface BucketMetaDataSDKType {
    description: string;
    external_url: string;
    bucket_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface ObjectMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of object NFT */
    objectName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface ObjectMetaDataSDKType {
    description: string;
    external_url: string;
    object_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface GroupMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of group NFT */
    groupName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface GroupMetaDataSDKType {
    description: string;
    external_url: string;
    group_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface Ids {
    /** ids of the objects or buckets */
    id: string[];
}
export interface IdsSDKType {
    id: string[];
}
export interface DeleteInfo {
    bucketIds?: Ids;
    objectIds?: Ids;
    groupIds?: Ids;
}
export interface DeleteInfoSDKType {
    bucket_ids?: IdsSDKType;
    object_ids?: IdsSDKType;
    group_ids?: IdsSDKType;
}
export declare const BucketInfo: {
    encode(message: BucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BucketInfo;
    fromJSON(object: any): BucketInfo;
    toJSON(message: BucketInfo): unknown;
    fromPartial<I extends {
        owner?: string | undefined;
        bucketName?: string | undefined;
        visibility?: VisibilityType | undefined;
        id?: string | undefined;
        sourceType?: SourceType | undefined;
        createAt?: string | number | Long.Long | undefined;
        paymentAddress?: string | undefined;
        primarySpAddress?: string | undefined;
        chargedReadQuota?: string | number | Long.Long | undefined;
        billingInfo?: {
            priceTime?: string | number | Long.Long | undefined;
            totalChargeSize?: string | number | Long.Long | undefined;
            secondarySpObjectsSize?: {
                spAddress?: string | undefined;
                totalChargeSize?: string | number | Long.Long | undefined;
            }[] | undefined;
        } | undefined;
        bucketStatus?: BucketStatus | undefined;
    } & {
        owner?: string | undefined;
        bucketName?: string | undefined;
        visibility?: VisibilityType | undefined;
        id?: string | undefined;
        sourceType?: SourceType | undefined;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>) | undefined;
        paymentAddress?: string | undefined;
        primarySpAddress?: string | undefined;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>) | undefined;
        billingInfo?: ({
            priceTime?: string | number | Long.Long | undefined;
            totalChargeSize?: string | number | Long.Long | undefined;
            secondarySpObjectsSize?: {
                spAddress?: string | undefined;
                totalChargeSize?: string | number | Long.Long | undefined;
            }[] | undefined;
        } & {
            priceTime?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["billingInfo"]["priceTime"], keyof Long.Long>, never>) | undefined;
            totalChargeSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["billingInfo"]["totalChargeSize"], keyof Long.Long>, never>) | undefined;
            secondarySpObjectsSize?: ({
                spAddress?: string | undefined;
                totalChargeSize?: string | number | Long.Long | undefined;
            }[] & ({
                spAddress?: string | undefined;
                totalChargeSize?: string | number | Long.Long | undefined;
            } & {
                spAddress?: string | undefined;
                totalChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["billingInfo"]["secondarySpObjectsSize"][number]["totalChargeSize"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["billingInfo"]["secondarySpObjectsSize"][number], keyof SecondarySpObjectsSize>, never>)[] & Record<Exclude<keyof I["billingInfo"]["secondarySpObjectsSize"], keyof {
                spAddress?: string | undefined;
                totalChargeSize?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
        } & Record<Exclude<keyof I["billingInfo"], keyof BillingInfo>, never>) | undefined;
        bucketStatus?: BucketStatus | undefined;
    } & Record<Exclude<keyof I, keyof BucketInfo>, never>>(object: I): BucketInfo;
    fromSDK(object: BucketInfoSDKType): BucketInfo;
    toSDK(message: BucketInfo): BucketInfoSDKType;
};
export declare const BillingInfo: {
    encode(message: BillingInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BillingInfo;
    fromJSON(object: any): BillingInfo;
    toJSON(message: BillingInfo): unknown;
    fromPartial<I extends {
        priceTime?: string | number | Long.Long | undefined;
        totalChargeSize?: string | number | Long.Long | undefined;
        secondarySpObjectsSize?: {
            spAddress?: string | undefined;
            totalChargeSize?: string | number | Long.Long | undefined;
        }[] | undefined;
    } & {
        priceTime?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["priceTime"], keyof Long.Long>, never>) | undefined;
        totalChargeSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["totalChargeSize"], keyof Long.Long>, never>) | undefined;
        secondarySpObjectsSize?: ({
            spAddress?: string | undefined;
            totalChargeSize?: string | number | Long.Long | undefined;
        }[] & ({
            spAddress?: string | undefined;
            totalChargeSize?: string | number | Long.Long | undefined;
        } & {
            spAddress?: string | undefined;
            totalChargeSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["secondarySpObjectsSize"][number]["totalChargeSize"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["secondarySpObjectsSize"][number], keyof SecondarySpObjectsSize>, never>)[] & Record<Exclude<keyof I["secondarySpObjectsSize"], keyof {
            spAddress?: string | undefined;
            totalChargeSize?: string | number | Long.Long | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof BillingInfo>, never>>(object: I): BillingInfo;
    fromSDK(object: BillingInfoSDKType): BillingInfo;
    toSDK(message: BillingInfo): BillingInfoSDKType;
};
export declare const SecondarySpObjectsSize: {
    encode(message: SecondarySpObjectsSize, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SecondarySpObjectsSize;
    fromJSON(object: any): SecondarySpObjectsSize;
    toJSON(message: SecondarySpObjectsSize): unknown;
    fromPartial<I extends {
        spAddress?: string | undefined;
        totalChargeSize?: string | number | Long.Long | undefined;
    } & {
        spAddress?: string | undefined;
        totalChargeSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["totalChargeSize"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof SecondarySpObjectsSize>, never>>(object: I): SecondarySpObjectsSize;
    fromSDK(object: SecondarySpObjectsSizeSDKType): SecondarySpObjectsSize;
    toSDK(message: SecondarySpObjectsSize): SecondarySpObjectsSizeSDKType;
};
export declare const ObjectInfo: {
    encode(message: ObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ObjectInfo;
    fromJSON(object: any): ObjectInfo;
    toJSON(message: ObjectInfo): unknown;
    fromPartial<I extends {
        owner?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        id?: string | undefined;
        payloadSize?: string | number | Long.Long | undefined;
        visibility?: VisibilityType | undefined;
        contentType?: string | undefined;
        createAt?: string | number | Long.Long | undefined;
        objectStatus?: ObjectStatus | undefined;
        redundancyType?: RedundancyType | undefined;
        sourceType?: SourceType | undefined;
        checksums?: Uint8Array[] | undefined;
        secondarySpAddresses?: string[] | undefined;
    } & {
        owner?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        id?: string | undefined;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>) | undefined;
        visibility?: VisibilityType | undefined;
        contentType?: string | undefined;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>) | undefined;
        objectStatus?: ObjectStatus | undefined;
        redundancyType?: RedundancyType | undefined;
        sourceType?: SourceType | undefined;
        checksums?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["checksums"], keyof Uint8Array[]>, never>) | undefined;
        secondarySpAddresses?: (string[] & string[] & Record<Exclude<keyof I["secondarySpAddresses"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof ObjectInfo>, never>>(object: I): ObjectInfo;
    fromSDK(object: ObjectInfoSDKType): ObjectInfo;
    toSDK(message: ObjectInfo): ObjectInfoSDKType;
};
export declare const GroupInfo: {
    encode(message: GroupInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GroupInfo;
    fromJSON(object: any): GroupInfo;
    toJSON(message: GroupInfo): unknown;
    fromPartial<I extends {
        owner?: string | undefined;
        groupName?: string | undefined;
        sourceType?: SourceType | undefined;
        id?: string | undefined;
    } & {
        owner?: string | undefined;
        groupName?: string | undefined;
        sourceType?: SourceType | undefined;
        id?: string | undefined;
    } & Record<Exclude<keyof I, keyof GroupInfo>, never>>(object: I): GroupInfo;
    fromSDK(object: GroupInfoSDKType): GroupInfo;
    toSDK(message: GroupInfo): GroupInfoSDKType;
};
export declare const Trait: {
    encode(message: Trait, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Trait;
    fromJSON(object: any): Trait;
    toJSON(message: Trait): unknown;
    fromPartial<I extends {
        traitType?: string | undefined;
        value?: string | undefined;
    } & {
        traitType?: string | undefined;
        value?: string | undefined;
    } & Record<Exclude<keyof I, keyof Trait>, never>>(object: I): Trait;
    fromSDK(object: TraitSDKType): Trait;
    toSDK(message: Trait): TraitSDKType;
};
export declare const BucketMetaData: {
    encode(message: BucketMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BucketMetaData;
    fromJSON(object: any): BucketMetaData;
    toJSON(message: BucketMetaData): unknown;
    fromPartial<I extends {
        description?: string | undefined;
        externalUrl?: string | undefined;
        bucketName?: string | undefined;
        image?: string | undefined;
        attributes?: {
            traitType?: string | undefined;
            value?: string | undefined;
        }[] | undefined;
    } & {
        description?: string | undefined;
        externalUrl?: string | undefined;
        bucketName?: string | undefined;
        image?: string | undefined;
        attributes?: ({
            traitType?: string | undefined;
            value?: string | undefined;
        }[] & ({
            traitType?: string | undefined;
            value?: string | undefined;
        } & {
            traitType?: string | undefined;
            value?: string | undefined;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string | undefined;
            value?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof BucketMetaData>, never>>(object: I): BucketMetaData;
    fromSDK(object: BucketMetaDataSDKType): BucketMetaData;
    toSDK(message: BucketMetaData): BucketMetaDataSDKType;
};
export declare const ObjectMetaData: {
    encode(message: ObjectMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ObjectMetaData;
    fromJSON(object: any): ObjectMetaData;
    toJSON(message: ObjectMetaData): unknown;
    fromPartial<I extends {
        description?: string | undefined;
        externalUrl?: string | undefined;
        objectName?: string | undefined;
        image?: string | undefined;
        attributes?: {
            traitType?: string | undefined;
            value?: string | undefined;
        }[] | undefined;
    } & {
        description?: string | undefined;
        externalUrl?: string | undefined;
        objectName?: string | undefined;
        image?: string | undefined;
        attributes?: ({
            traitType?: string | undefined;
            value?: string | undefined;
        }[] & ({
            traitType?: string | undefined;
            value?: string | undefined;
        } & {
            traitType?: string | undefined;
            value?: string | undefined;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string | undefined;
            value?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof ObjectMetaData>, never>>(object: I): ObjectMetaData;
    fromSDK(object: ObjectMetaDataSDKType): ObjectMetaData;
    toSDK(message: ObjectMetaData): ObjectMetaDataSDKType;
};
export declare const GroupMetaData: {
    encode(message: GroupMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GroupMetaData;
    fromJSON(object: any): GroupMetaData;
    toJSON(message: GroupMetaData): unknown;
    fromPartial<I extends {
        description?: string | undefined;
        externalUrl?: string | undefined;
        groupName?: string | undefined;
        image?: string | undefined;
        attributes?: {
            traitType?: string | undefined;
            value?: string | undefined;
        }[] | undefined;
    } & {
        description?: string | undefined;
        externalUrl?: string | undefined;
        groupName?: string | undefined;
        image?: string | undefined;
        attributes?: ({
            traitType?: string | undefined;
            value?: string | undefined;
        }[] & ({
            traitType?: string | undefined;
            value?: string | undefined;
        } & {
            traitType?: string | undefined;
            value?: string | undefined;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string | undefined;
            value?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof GroupMetaData>, never>>(object: I): GroupMetaData;
    fromSDK(object: GroupMetaDataSDKType): GroupMetaData;
    toSDK(message: GroupMetaData): GroupMetaDataSDKType;
};
export declare const Ids: {
    encode(message: Ids, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Ids;
    fromJSON(object: any): Ids;
    toJSON(message: Ids): unknown;
    fromPartial<I extends {
        id?: string[] | undefined;
    } & {
        id?: (string[] & string[] & Record<Exclude<keyof I["id"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, "id">, never>>(object: I): Ids;
    fromSDK(object: IdsSDKType): Ids;
    toSDK(message: Ids): IdsSDKType;
};
export declare const DeleteInfo: {
    encode(message: DeleteInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteInfo;
    fromJSON(object: any): DeleteInfo;
    toJSON(message: DeleteInfo): unknown;
    fromPartial<I extends {
        bucketIds?: {
            id?: string[] | undefined;
        } | undefined;
        objectIds?: {
            id?: string[] | undefined;
        } | undefined;
        groupIds?: {
            id?: string[] | undefined;
        } | undefined;
    } & {
        bucketIds?: ({
            id?: string[] | undefined;
        } & {
            id?: (string[] & string[] & Record<Exclude<keyof I["bucketIds"]["id"], keyof string[]>, never>) | undefined;
        } & Record<Exclude<keyof I["bucketIds"], "id">, never>) | undefined;
        objectIds?: ({
            id?: string[] | undefined;
        } & {
            id?: (string[] & string[] & Record<Exclude<keyof I["objectIds"]["id"], keyof string[]>, never>) | undefined;
        } & Record<Exclude<keyof I["objectIds"], "id">, never>) | undefined;
        groupIds?: ({
            id?: string[] | undefined;
        } & {
            id?: (string[] & string[] & Record<Exclude<keyof I["groupIds"]["id"], keyof string[]>, never>) | undefined;
        } & Record<Exclude<keyof I["groupIds"], "id">, never>) | undefined;
    } & Record<Exclude<keyof I, keyof DeleteInfo>, never>>(object: I): DeleteInfo;
    fromSDK(object: DeleteInfoSDKType): DeleteInfo;
    toSDK(message: DeleteInfo): DeleteInfoSDKType;
};
