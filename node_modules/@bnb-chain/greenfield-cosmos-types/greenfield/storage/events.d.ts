/// <reference types="long" />
import { VisibilityType, SourceType, BucketStatus, ObjectStatus, RedundancyType } from "./common";
import { DeleteInfo, DeleteInfoSDKType } from "./types";
import { Long } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
/** EventCreateBucket is emitted on MsgCreateBucket */
export interface EventCreateBucket {
    /** owner define the account address of bucket owner */
    owner: string;
    /** bucket_name is a globally unique name of bucket */
    bucketName: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get the object under it. */
    visibility: VisibilityType;
    /** create_at define the block timestamp when the bucket has been created */
    createAt: Long;
    /** bucket_id is the unique u256 for bucket. Not global, only unique in buckets. */
    bucketId: string;
    /** source_type define the source of the bucket. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** read_quota defines the charged traffic quota for read, not include free quota which provided by each storage provider */
    chargedReadQuota: Long;
    /** payment_address is the address of the payment account */
    paymentAddress: string;
    /** primary_sp_address is the operator address of the primary sp. */
    primarySpAddress: string;
    /** status define the status of the bucket. */
    status: BucketStatus;
}
/** EventCreateBucket is emitted on MsgCreateBucket */
export interface EventCreateBucketSDKType {
    owner: string;
    bucket_name: string;
    visibility: VisibilityType;
    create_at: Long;
    bucket_id: string;
    source_type: SourceType;
    charged_read_quota: Long;
    payment_address: string;
    primary_sp_address: string;
    status: BucketStatus;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */
export interface EventDeleteBucket {
    /** operator define the account address of operator who delete the bucket */
    operator: string;
    /** owner define the account address of the bucket owner */
    owner: string;
    /** bucket_name define the name of the deleted bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** primary_sp_address define the account address of primary sp */
    primarySpAddress: string;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */
export interface EventDeleteBucketSDKType {
    operator: string;
    owner: string;
    bucket_name: string;
    bucket_id: string;
    primary_sp_address: string;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */
export interface EventUpdateBucketInfo {
    /** operator define the account address of operator who update the bucket */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** charged_read_quota_before define the read quota before updated */
    chargedReadQuotaBefore: Long;
    /** charged_read_quota_after define the read quota after updated */
    chargedReadQuotaAfter: Long;
    /** payment_address_before define the payment address before updated */
    paymentAddressBefore: string;
    /** payment_address_after define the payment address after updated */
    paymentAddressAfter: string;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */
export interface EventUpdateBucketInfoSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    charged_read_quota_before: Long;
    charged_read_quota_after: Long;
    payment_address_before: string;
    payment_address_after: string;
    visibility: VisibilityType;
}
/** EventDiscontinueBucket is emitted on MsgDiscontinueBucket */
export interface EventDiscontinueBucket {
    /** bucket_id define id of the bucket */
    bucketId: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** the reason */
    reason: string;
    /** the timestamp after which the metadata will be deleted */
    deleteAt: Long;
}
/** EventDiscontinueBucket is emitted on MsgDiscontinueBucket */
export interface EventDiscontinueBucketSDKType {
    bucket_id: string;
    bucket_name: string;
    reason: string;
    delete_at: Long;
}
/** EventCreateObject is emitted on MsgCreateObject */
export interface EventCreateObject {
    /** creator define the account address of msg creator */
    creator: string;
    /** owner define the account address of object owner */
    owner: string;
    /** bucket_name define the name of bucket */
    bucketName: string;
    /** object_name define the name of object */
    objectName: string;
    /** bucket_id define an u256 id for object */
    bucketId: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** primary_sp_address define the account address of primary sp */
    primarySpAddress: string;
    /** payload_size define the size of payload data which you want upload */
    payloadSize: Long;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
    /** content_type define the content type of the payload data */
    contentType: string;
    /** create_at define the block timestamp when the object created */
    createAt: Long;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status: ObjectStatus;
    /** redundancy_type define the type of redundancy. Replication or EC */
    redundancyType: RedundancyType;
    /** source_type define the source of the object.  CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** checksums define the total checksums of the object which generated by redundancy */
    checksums: Uint8Array[];
}
/** EventCreateObject is emitted on MsgCreateObject */
export interface EventCreateObjectSDKType {
    creator: string;
    owner: string;
    bucket_name: string;
    object_name: string;
    bucket_id: string;
    object_id: string;
    primary_sp_address: string;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    create_at: Long;
    status: ObjectStatus;
    redundancy_type: RedundancyType;
    source_type: SourceType;
    checksums: Uint8Array[];
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventCancelCreateObject {
    /** operator define the account address of operator who cancel create object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** primary_sp_address define the operator account address of the sp */
    primarySpAddress: string;
    /** id define an u256 id for object */
    objectId: string;
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventCancelCreateObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    primary_sp_address: string;
    object_id: string;
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventSealObject {
    /** operator define the account address of operator who seal object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status: ObjectStatus;
    /** secondary_sp_address define all the operator address of the secondary sps */
    secondarySpAddresses: string[];
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    status: ObjectStatus;
    secondary_sp_addresses: string[];
}
/** EventCopyObject is emitted on MsgCopyObject */
export interface EventCopyObject {
    /** operator define the account address of operator who copy the object */
    operator: string;
    /** src_bucket_name define the name of the src bucket */
    srcBucketName: string;
    /** src_object_name define the name of the src object */
    srcObjectName: string;
    /** dst_bucket_name define the name of the dst bucket */
    dstBucketName: string;
    /** dst_object_name define the name of the dst object */
    dstObjectName: string;
    /** src_object_id define the u256 id for src object */
    srcObjectId: string;
    /** dst_object_id define the u256 id for dst object */
    dstObjectId: string;
}
/** EventCopyObject is emitted on MsgCopyObject */
export interface EventCopyObjectSDKType {
    operator: string;
    src_bucket_name: string;
    src_object_name: string;
    dst_bucket_name: string;
    dst_object_name: string;
    src_object_id: string;
    dst_object_id: string;
}
/** EventDeleteObject is emitted on MsgDeleteObject */
export interface EventDeleteObject {
    /** operator define the account address of operator who delete the object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
    /** primary_sp_address define the operator account address of the sp */
    primarySpAddress: string;
    /** secondary_sp_address define all the operator address of the secondary sps */
    secondarySpAddresses: string[];
}
/** EventDeleteObject is emitted on MsgDeleteObject */
export interface EventDeleteObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    primary_sp_address: string;
    secondary_sp_addresses: string[];
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */
export interface EventRejectSealObject {
    /** operator define the account address of operator who reject seal object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */
export interface EventRejectSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
}
/** EventDiscontinueObject is emitted on MsgDiscontinueObject */
export interface EventDiscontinueObject {
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_id defines id of the object */
    objectId: string;
    /** the reason */
    reason: string;
    /** the timestamp after which the metadata will be deleted */
    deleteAt: Long;
}
/** EventDiscontinueObject is emitted on MsgDiscontinueObject */
export interface EventDiscontinueObjectSDKType {
    bucket_name: string;
    object_id: string;
    reason: string;
    delete_at: Long;
}
/** EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo */
export interface EventUpdateObjectInfo {
    /** operator define the account address of operator who update the bucket */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
}
/** EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo */
export interface EventUpdateObjectInfoSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    visibility: VisibilityType;
}
/** EventCreateGroup is emitted on MsgCreateGroup */
export interface EventCreateGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** source_type define the source of the group. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** members define the all the address of the members. */
    members: string[];
}
/** EventCreateGroup is emitted on MsgCreateGroup */
export interface EventCreateGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
    source_type: SourceType;
    members: string[];
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */
export interface EventDeleteGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */
export interface EventDeleteGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */
export interface EventLeaveGroup {
    /** member_address define the address of the member who leave the group */
    memberAddress: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */
export interface EventLeaveGroupSDKType {
    member_address: string;
    owner: string;
    group_name: string;
    group_id: string;
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */
export interface EventUpdateGroupMember {
    /** operator define the account address of operator who update the group member */
    operator: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** members_to_add defines all the members to be added to the group */
    membersToAdd: string[];
    /** members_to_add defines all the members to be deleted from the group */
    membersToDelete: string[];
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */
export interface EventUpdateGroupMemberSDKType {
    operator: string;
    owner: string;
    group_name: string;
    group_id: string;
    members_to_add: string[];
    members_to_delete: string[];
}
/** EventMirrorBucket is emitted on MirrorBucket */
export interface EventMirrorBucket {
    /** operator define the account address of operator who mirror the bucket */
    operator: string;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
}
/** EventMirrorBucket is emitted on MirrorBucket */
export interface EventMirrorBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
}
/** EventMirrorBucketResult is emitted on receiving ack package from destination chain */
export interface EventMirrorBucketResult {
    /** status define the status of the result */
    status: number;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
}
/** EventMirrorBucketResult is emitted on receiving ack package from destination chain */
export interface EventMirrorBucketResultSDKType {
    status: number;
    bucket_name: string;
    bucket_id: string;
}
/** EventMirrorObject is emitted on MirrorObject */
export interface EventMirrorObject {
    /** operator define the account address of operator who delete the object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
}
/** EventMirrorObject is emitted on MirrorObject */
export interface EventMirrorObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
}
/** EventMirrorObjectResult is emitted on receiving ack package from destination chain */
export interface EventMirrorObjectResult {
    /** status define the status of the result */
    status: number;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
}
/** EventMirrorObjectResult is emitted on receiving ack package from destination chain */
export interface EventMirrorObjectResultSDKType {
    status: number;
    bucket_name: string;
    object_name: string;
    object_id: string;
}
/** EventMirrorGroup is emitted on MirrorGroup */
export interface EventMirrorGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** group_id define an u256 id for group */
    groupId: string;
}
/** EventMirrorGroup is emitted on MirrorGroup */
export interface EventMirrorGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
}
/** EventMirrorGroupResult is emitted on receiving ack package from destination chain */
export interface EventMirrorGroupResult {
    /** status define the status of the result */
    status: number;
    /** group_name define the name of the group */
    groupName: string;
    /** group_id define an u256 id for group */
    groupId: string;
}
/** EventMirrorGroupResult is emitted on receiving ack package from destination chain */
export interface EventMirrorGroupResultSDKType {
    status: number;
    group_name: string;
    group_id: string;
}
/** EventStalePolicyCleanup is emitted when specified block height's stale policies need to be Garbage collected */
export interface EventStalePolicyCleanup {
    blockNum: Long;
    deleteInfo?: DeleteInfo;
}
/** EventStalePolicyCleanup is emitted when specified block height's stale policies need to be Garbage collected */
export interface EventStalePolicyCleanupSDKType {
    blockNum: Long;
    delete_info?: DeleteInfoSDKType;
}
export declare const EventCreateBucket: {
    encode(message: EventCreateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateBucket;
    fromJSON(object: any): EventCreateBucket;
    toJSON(message: EventCreateBucket): unknown;
    fromPartial<I extends {
        owner?: string | undefined;
        bucketName?: string | undefined;
        visibility?: VisibilityType | undefined;
        createAt?: string | number | Long.Long | undefined;
        bucketId?: string | undefined;
        sourceType?: SourceType | undefined;
        chargedReadQuota?: string | number | Long.Long | undefined;
        paymentAddress?: string | undefined;
        primarySpAddress?: string | undefined;
        status?: BucketStatus | undefined;
    } & {
        owner?: string | undefined;
        bucketName?: string | undefined;
        visibility?: VisibilityType | undefined;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>) | undefined;
        bucketId?: string | undefined;
        sourceType?: SourceType | undefined;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>) | undefined;
        paymentAddress?: string | undefined;
        primarySpAddress?: string | undefined;
        status?: BucketStatus | undefined;
    } & Record<Exclude<keyof I, keyof EventCreateBucket>, never>>(object: I): EventCreateBucket;
    fromSDK(object: EventCreateBucketSDKType): EventCreateBucket;
    toSDK(message: EventCreateBucket): EventCreateBucketSDKType;
};
export declare const EventDeleteBucket: {
    encode(message: EventDeleteBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteBucket;
    fromJSON(object: any): EventDeleteBucket;
    toJSON(message: EventDeleteBucket): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        owner?: string | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
        primarySpAddress?: string | undefined;
    } & {
        operator?: string | undefined;
        owner?: string | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
        primarySpAddress?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventDeleteBucket>, never>>(object: I): EventDeleteBucket;
    fromSDK(object: EventDeleteBucketSDKType): EventDeleteBucket;
    toSDK(message: EventDeleteBucket): EventDeleteBucketSDKType;
};
export declare const EventUpdateBucketInfo: {
    encode(message: EventUpdateBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateBucketInfo;
    fromJSON(object: any): EventUpdateBucketInfo;
    toJSON(message: EventUpdateBucketInfo): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
        chargedReadQuotaBefore?: string | number | Long.Long | undefined;
        chargedReadQuotaAfter?: string | number | Long.Long | undefined;
        paymentAddressBefore?: string | undefined;
        paymentAddressAfter?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
        chargedReadQuotaBefore?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuotaBefore"], keyof Long.Long>, never>) | undefined;
        chargedReadQuotaAfter?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuotaAfter"], keyof Long.Long>, never>) | undefined;
        paymentAddressBefore?: string | undefined;
        paymentAddressAfter?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & Record<Exclude<keyof I, keyof EventUpdateBucketInfo>, never>>(object: I): EventUpdateBucketInfo;
    fromSDK(object: EventUpdateBucketInfoSDKType): EventUpdateBucketInfo;
    toSDK(message: EventUpdateBucketInfo): EventUpdateBucketInfoSDKType;
};
export declare const EventDiscontinueBucket: {
    encode(message: EventDiscontinueBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDiscontinueBucket;
    fromJSON(object: any): EventDiscontinueBucket;
    toJSON(message: EventDiscontinueBucket): unknown;
    fromPartial<I extends {
        bucketId?: string | undefined;
        bucketName?: string | undefined;
        reason?: string | undefined;
        deleteAt?: string | number | Long.Long | undefined;
    } & {
        bucketId?: string | undefined;
        bucketName?: string | undefined;
        reason?: string | undefined;
        deleteAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["deleteAt"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventDiscontinueBucket>, never>>(object: I): EventDiscontinueBucket;
    fromSDK(object: EventDiscontinueBucketSDKType): EventDiscontinueBucket;
    toSDK(message: EventDiscontinueBucket): EventDiscontinueBucketSDKType;
};
export declare const EventCreateObject: {
    encode(message: EventCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateObject;
    fromJSON(object: any): EventCreateObject;
    toJSON(message: EventCreateObject): unknown;
    fromPartial<I extends {
        creator?: string | undefined;
        owner?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        bucketId?: string | undefined;
        objectId?: string | undefined;
        primarySpAddress?: string | undefined;
        payloadSize?: string | number | Long.Long | undefined;
        visibility?: VisibilityType | undefined;
        contentType?: string | undefined;
        createAt?: string | number | Long.Long | undefined;
        status?: ObjectStatus | undefined;
        redundancyType?: RedundancyType | undefined;
        sourceType?: SourceType | undefined;
        checksums?: Uint8Array[] | undefined;
    } & {
        creator?: string | undefined;
        owner?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        bucketId?: string | undefined;
        objectId?: string | undefined;
        primarySpAddress?: string | undefined;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>) | undefined;
        visibility?: VisibilityType | undefined;
        contentType?: string | undefined;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>) | undefined;
        status?: ObjectStatus | undefined;
        redundancyType?: RedundancyType | undefined;
        sourceType?: SourceType | undefined;
        checksums?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["checksums"], keyof Uint8Array[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventCreateObject>, never>>(object: I): EventCreateObject;
    fromSDK(object: EventCreateObjectSDKType): EventCreateObject;
    toSDK(message: EventCreateObject): EventCreateObjectSDKType;
};
export declare const EventCancelCreateObject: {
    encode(message: EventCancelCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCancelCreateObject;
    fromJSON(object: any): EventCancelCreateObject;
    toJSON(message: EventCancelCreateObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        primarySpAddress?: string | undefined;
        objectId?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        primarySpAddress?: string | undefined;
        objectId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventCancelCreateObject>, never>>(object: I): EventCancelCreateObject;
    fromSDK(object: EventCancelCreateObjectSDKType): EventCancelCreateObject;
    toSDK(message: EventCancelCreateObject): EventCancelCreateObjectSDKType;
};
export declare const EventSealObject: {
    encode(message: EventSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSealObject;
    fromJSON(object: any): EventSealObject;
    toJSON(message: EventSealObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
        status?: ObjectStatus | undefined;
        secondarySpAddresses?: string[] | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
        status?: ObjectStatus | undefined;
        secondarySpAddresses?: (string[] & string[] & Record<Exclude<keyof I["secondarySpAddresses"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventSealObject>, never>>(object: I): EventSealObject;
    fromSDK(object: EventSealObjectSDKType): EventSealObject;
    toSDK(message: EventSealObject): EventSealObjectSDKType;
};
export declare const EventCopyObject: {
    encode(message: EventCopyObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCopyObject;
    fromJSON(object: any): EventCopyObject;
    toJSON(message: EventCopyObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        srcBucketName?: string | undefined;
        srcObjectName?: string | undefined;
        dstBucketName?: string | undefined;
        dstObjectName?: string | undefined;
        srcObjectId?: string | undefined;
        dstObjectId?: string | undefined;
    } & {
        operator?: string | undefined;
        srcBucketName?: string | undefined;
        srcObjectName?: string | undefined;
        dstBucketName?: string | undefined;
        dstObjectName?: string | undefined;
        srcObjectId?: string | undefined;
        dstObjectId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventCopyObject>, never>>(object: I): EventCopyObject;
    fromSDK(object: EventCopyObjectSDKType): EventCopyObject;
    toSDK(message: EventCopyObject): EventCopyObjectSDKType;
};
export declare const EventDeleteObject: {
    encode(message: EventDeleteObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteObject;
    fromJSON(object: any): EventDeleteObject;
    toJSON(message: EventDeleteObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
        primarySpAddress?: string | undefined;
        secondarySpAddresses?: string[] | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
        primarySpAddress?: string | undefined;
        secondarySpAddresses?: (string[] & string[] & Record<Exclude<keyof I["secondarySpAddresses"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventDeleteObject>, never>>(object: I): EventDeleteObject;
    fromSDK(object: EventDeleteObjectSDKType): EventDeleteObject;
    toSDK(message: EventDeleteObject): EventDeleteObjectSDKType;
};
export declare const EventRejectSealObject: {
    encode(message: EventRejectSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRejectSealObject;
    fromJSON(object: any): EventRejectSealObject;
    toJSON(message: EventRejectSealObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventRejectSealObject>, never>>(object: I): EventRejectSealObject;
    fromSDK(object: EventRejectSealObjectSDKType): EventRejectSealObject;
    toSDK(message: EventRejectSealObject): EventRejectSealObjectSDKType;
};
export declare const EventDiscontinueObject: {
    encode(message: EventDiscontinueObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDiscontinueObject;
    fromJSON(object: any): EventDiscontinueObject;
    toJSON(message: EventDiscontinueObject): unknown;
    fromPartial<I extends {
        bucketName?: string | undefined;
        objectId?: string | undefined;
        reason?: string | undefined;
        deleteAt?: string | number | Long.Long | undefined;
    } & {
        bucketName?: string | undefined;
        objectId?: string | undefined;
        reason?: string | undefined;
        deleteAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["deleteAt"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventDiscontinueObject>, never>>(object: I): EventDiscontinueObject;
    fromSDK(object: EventDiscontinueObjectSDKType): EventDiscontinueObject;
    toSDK(message: EventDiscontinueObject): EventDiscontinueObjectSDKType;
};
export declare const EventUpdateObjectInfo: {
    encode(message: EventUpdateObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateObjectInfo;
    fromJSON(object: any): EventUpdateObjectInfo;
    toJSON(message: EventUpdateObjectInfo): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & Record<Exclude<keyof I, keyof EventUpdateObjectInfo>, never>>(object: I): EventUpdateObjectInfo;
    fromSDK(object: EventUpdateObjectInfoSDKType): EventUpdateObjectInfo;
    toSDK(message: EventUpdateObjectInfo): EventUpdateObjectInfoSDKType;
};
export declare const EventCreateGroup: {
    encode(message: EventCreateGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateGroup;
    fromJSON(object: any): EventCreateGroup;
    toJSON(message: EventCreateGroup): unknown;
    fromPartial<I extends {
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
        sourceType?: SourceType | undefined;
        members?: string[] | undefined;
    } & {
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
        sourceType?: SourceType | undefined;
        members?: (string[] & string[] & Record<Exclude<keyof I["members"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventCreateGroup>, never>>(object: I): EventCreateGroup;
    fromSDK(object: EventCreateGroupSDKType): EventCreateGroup;
    toSDK(message: EventCreateGroup): EventCreateGroupSDKType;
};
export declare const EventDeleteGroup: {
    encode(message: EventDeleteGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteGroup;
    fromJSON(object: any): EventDeleteGroup;
    toJSON(message: EventDeleteGroup): unknown;
    fromPartial<I extends {
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & {
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventDeleteGroup>, never>>(object: I): EventDeleteGroup;
    fromSDK(object: EventDeleteGroupSDKType): EventDeleteGroup;
    toSDK(message: EventDeleteGroup): EventDeleteGroupSDKType;
};
export declare const EventLeaveGroup: {
    encode(message: EventLeaveGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventLeaveGroup;
    fromJSON(object: any): EventLeaveGroup;
    toJSON(message: EventLeaveGroup): unknown;
    fromPartial<I extends {
        memberAddress?: string | undefined;
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & {
        memberAddress?: string | undefined;
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventLeaveGroup>, never>>(object: I): EventLeaveGroup;
    fromSDK(object: EventLeaveGroupSDKType): EventLeaveGroup;
    toSDK(message: EventLeaveGroup): EventLeaveGroupSDKType;
};
export declare const EventUpdateGroupMember: {
    encode(message: EventUpdateGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateGroupMember;
    fromJSON(object: any): EventUpdateGroupMember;
    toJSON(message: EventUpdateGroupMember): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
        membersToAdd?: string[] | undefined;
        membersToDelete?: string[] | undefined;
    } & {
        operator?: string | undefined;
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
        membersToAdd?: (string[] & string[] & Record<Exclude<keyof I["membersToAdd"], keyof string[]>, never>) | undefined;
        membersToDelete?: (string[] & string[] & Record<Exclude<keyof I["membersToDelete"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventUpdateGroupMember>, never>>(object: I): EventUpdateGroupMember;
    fromSDK(object: EventUpdateGroupMemberSDKType): EventUpdateGroupMember;
    toSDK(message: EventUpdateGroupMember): EventUpdateGroupMemberSDKType;
};
export declare const EventMirrorBucket: {
    encode(message: EventMirrorBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorBucket;
    fromJSON(object: any): EventMirrorBucket;
    toJSON(message: EventMirrorBucket): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventMirrorBucket>, never>>(object: I): EventMirrorBucket;
    fromSDK(object: EventMirrorBucketSDKType): EventMirrorBucket;
    toSDK(message: EventMirrorBucket): EventMirrorBucketSDKType;
};
export declare const EventMirrorBucketResult: {
    encode(message: EventMirrorBucketResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorBucketResult;
    fromJSON(object: any): EventMirrorBucketResult;
    toJSON(message: EventMirrorBucketResult): unknown;
    fromPartial<I extends {
        status?: number | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
    } & {
        status?: number | undefined;
        bucketName?: string | undefined;
        bucketId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventMirrorBucketResult>, never>>(object: I): EventMirrorBucketResult;
    fromSDK(object: EventMirrorBucketResultSDKType): EventMirrorBucketResult;
    toSDK(message: EventMirrorBucketResult): EventMirrorBucketResultSDKType;
};
export declare const EventMirrorObject: {
    encode(message: EventMirrorObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorObject;
    fromJSON(object: any): EventMirrorObject;
    toJSON(message: EventMirrorObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventMirrorObject>, never>>(object: I): EventMirrorObject;
    fromSDK(object: EventMirrorObjectSDKType): EventMirrorObject;
    toSDK(message: EventMirrorObject): EventMirrorObjectSDKType;
};
export declare const EventMirrorObjectResult: {
    encode(message: EventMirrorObjectResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorObjectResult;
    fromJSON(object: any): EventMirrorObjectResult;
    toJSON(message: EventMirrorObjectResult): unknown;
    fromPartial<I extends {
        status?: number | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
    } & {
        status?: number | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        objectId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventMirrorObjectResult>, never>>(object: I): EventMirrorObjectResult;
    fromSDK(object: EventMirrorObjectResultSDKType): EventMirrorObjectResult;
    toSDK(message: EventMirrorObjectResult): EventMirrorObjectResultSDKType;
};
export declare const EventMirrorGroup: {
    encode(message: EventMirrorGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorGroup;
    fromJSON(object: any): EventMirrorGroup;
    toJSON(message: EventMirrorGroup): unknown;
    fromPartial<I extends {
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & {
        owner?: string | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventMirrorGroup>, never>>(object: I): EventMirrorGroup;
    fromSDK(object: EventMirrorGroupSDKType): EventMirrorGroup;
    toSDK(message: EventMirrorGroup): EventMirrorGroupSDKType;
};
export declare const EventMirrorGroupResult: {
    encode(message: EventMirrorGroupResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorGroupResult;
    fromJSON(object: any): EventMirrorGroupResult;
    toJSON(message: EventMirrorGroupResult): unknown;
    fromPartial<I extends {
        status?: number | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & {
        status?: number | undefined;
        groupName?: string | undefined;
        groupId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventMirrorGroupResult>, never>>(object: I): EventMirrorGroupResult;
    fromSDK(object: EventMirrorGroupResultSDKType): EventMirrorGroupResult;
    toSDK(message: EventMirrorGroupResult): EventMirrorGroupResultSDKType;
};
export declare const EventStalePolicyCleanup: {
    encode(message: EventStalePolicyCleanup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventStalePolicyCleanup;
    fromJSON(object: any): EventStalePolicyCleanup;
    toJSON(message: EventStalePolicyCleanup): unknown;
    fromPartial<I extends {
        blockNum?: string | number | Long.Long | undefined;
        deleteInfo?: {
            bucketIds?: {
                id?: string[] | undefined;
            } | undefined;
            objectIds?: {
                id?: string[] | undefined;
            } | undefined;
            groupIds?: {
                id?: string[] | undefined;
            } | undefined;
        } | undefined;
    } & {
        blockNum?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockNum"], keyof Long.Long>, never>) | undefined;
        deleteInfo?: ({
            bucketIds?: {
                id?: string[] | undefined;
            } | undefined;
            objectIds?: {
                id?: string[] | undefined;
            } | undefined;
            groupIds?: {
                id?: string[] | undefined;
            } | undefined;
        } & {
            bucketIds?: ({
                id?: string[] | undefined;
            } & {
                id?: (string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["bucketIds"]["id"], keyof string[]>, never>) | undefined;
            } & Record<Exclude<keyof I["deleteInfo"]["bucketIds"], "id">, never>) | undefined;
            objectIds?: ({
                id?: string[] | undefined;
            } & {
                id?: (string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["objectIds"]["id"], keyof string[]>, never>) | undefined;
            } & Record<Exclude<keyof I["deleteInfo"]["objectIds"], "id">, never>) | undefined;
            groupIds?: ({
                id?: string[] | undefined;
            } & {
                id?: (string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["groupIds"]["id"], keyof string[]>, never>) | undefined;
            } & Record<Exclude<keyof I["deleteInfo"]["groupIds"], "id">, never>) | undefined;
        } & Record<Exclude<keyof I["deleteInfo"], keyof DeleteInfo>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventStalePolicyCleanup>, never>>(object: I): EventStalePolicyCleanup;
    fromSDK(object: EventStalePolicyCleanupSDKType): EventStalePolicyCleanup;
    toSDK(message: EventStalePolicyCleanup): EventStalePolicyCleanupSDKType;
};
