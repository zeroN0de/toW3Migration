/// <reference types="long" />
import { VisibilityType, Approval, ApprovalSDKType, RedundancyType } from "./common";
import { UInt64Value, UInt64ValueSDKType } from "../common/wrapper";
import { Principal, PrincipalSDKType, Statement, StatementSDKType } from "../permission/common";
import { Timestamp, TimestampSDKType } from "../../google/protobuf/timestamp";
import { Params, ParamsSDKType } from "./params";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
export interface MsgCreateBucket {
    /** creator defines the account address of bucket creator, it is also the bucket owner. */
    creator: string;
    /** bucket_name defines a globally unique name of bucket */
    bucketName: string;
    /**
     * visibility means the bucket is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility: VisibilityType;
    /** payment_address defines an account address specified by bucket owner to pay the read fee. Default: creator */
    paymentAddress: string;
    /** primary_sp_address defines the address of primary sp. */
    primarySpAddress: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    primarySpApproval?: Approval;
    /**
     * charged_read_quota defines the read data that users are charged for, measured in bytes.
     * The available read data for each user is the sum of the free read data provided by SP and
     * the ChargeReadQuota specified here.
     */
    chargedReadQuota: Long;
}
export interface MsgCreateBucketSDKType {
    creator: string;
    bucket_name: string;
    visibility: VisibilityType;
    payment_address: string;
    primary_sp_address: string;
    primary_sp_approval?: ApprovalSDKType;
    charged_read_quota: Long;
}
export interface MsgCreateBucketResponse {
    bucketId: string;
}
export interface MsgCreateBucketResponseSDKType {
    bucket_id: string;
}
export interface MsgDeleteBucket {
    /** creator defines the account address of the grantee who has the DeleteBucket permission of the bucket to be deleted. */
    operator: string;
    /** bucket_name defines the name of the bucket to be deleted. */
    bucketName: string;
}
export interface MsgDeleteBucketSDKType {
    operator: string;
    bucket_name: string;
}
export interface MsgDeleteBucketResponse {
}
export interface MsgDeleteBucketResponseSDKType {
}
export interface MsgDiscontinueBucket {
    /** operator is the sp who wants to stop serving the bucket. */
    operator: string;
    /** bucket_name defines the name of the bucket where the object which to be discontinued is stored. */
    bucketName: string;
    /** the reason for the request. */
    reason: string;
}
export interface MsgDiscontinueBucketSDKType {
    operator: string;
    bucket_name: string;
    reason: string;
}
export interface MsgDiscontinueBucketResponse {
}
export interface MsgDiscontinueBucketResponseSDKType {
}
export interface MsgCreateObject {
    /** creator defines the account address of object uploader */
    creator: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucketName: string;
    /** object_name defines the name of object */
    objectName: string;
    /** payload_size defines size of the object's payload */
    payloadSize: Long;
    /**
     * visibility means the object is private or public. if private, only object owner or grantee can access it,
     * otherwise every greenfield user can access it.
     */
    visibility: VisibilityType;
    /** content_type defines a standard MIME type describing the format of the object. */
    contentType: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    primarySpApproval?: Approval;
    /** expect_checksums defines a list of hashes which was generate by redundancy algorithm. */
    expectChecksums: Uint8Array[];
    /** redundancy_type can be ec or replica */
    redundancyType: RedundancyType;
    /** expect_secondarySPs defines a list of StorageProvider address, which is optional */
    expectSecondarySpAddresses: string[];
}
export interface MsgCreateObjectSDKType {
    creator: string;
    bucket_name: string;
    object_name: string;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    primary_sp_approval?: ApprovalSDKType;
    expect_checksums: Uint8Array[];
    redundancy_type: RedundancyType;
    expect_secondary_sp_addresses: string[];
}
export interface MsgCreateObjectResponse {
    objectId: string;
}
export interface MsgCreateObjectResponseSDKType {
    object_id: string;
}
export interface MsgSealObject {
    /** operator defines the account address of primary SP */
    operator: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucketName: string;
    /** object_name defines the name of object to be sealed. */
    objectName: string;
    /** secondary_sp_addresses defines a list of storage provider which store the redundant data. */
    secondarySpAddresses: string[];
    /**
     * secondary_sp_signatures defines the signature of the secondary sp that can
     * acknowledge that the payload data has received and stored.
     */
    secondarySpSignatures: Uint8Array[];
}
export interface MsgSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    secondary_sp_addresses: string[];
    secondary_sp_signatures: Uint8Array[];
}
export interface MsgSealObjectResponse {
}
export interface MsgSealObjectResponseSDKType {
}
export interface MsgRejectSealObject {
    /** operator defines the account address of the object owner */
    operator: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucketName: string;
    /** object_name defines the name of unsealed object to be reject. */
    objectName: string;
}
export interface MsgRejectSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
}
export interface MsgRejectSealObjectResponse {
}
export interface MsgRejectSealObjectResponseSDKType {
}
export interface MsgCopyObject {
    /** operator defines the account address of the operator who has the CopyObject permission of the object to be deleted. */
    operator: string;
    /** src_bucket_name defines the name of the bucket where the object to be copied is located */
    srcBucketName: string;
    /** dst_bucket_name defines the name of the bucket where the object is copied to. */
    dstBucketName: string;
    /** src_object_name defines the name of the object which to be copied */
    srcObjectName: string;
    /** dst_object_name defines the name of the object which is copied to */
    dstObjectName: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    dstPrimarySpApproval?: Approval;
}
export interface MsgCopyObjectSDKType {
    operator: string;
    src_bucket_name: string;
    dst_bucket_name: string;
    src_object_name: string;
    dst_object_name: string;
    dst_primary_sp_approval?: ApprovalSDKType;
}
export interface MsgCopyObjectResponse {
    objectId: string;
}
export interface MsgCopyObjectResponseSDKType {
    object_id: string;
}
export interface MsgDeleteObject {
    /** operator defines the account address of the operator who has the DeleteObject permission of the object to be deleted. */
    operator: string;
    /** bucket_name defines the name of the bucket where the object which to be deleted is stored. */
    bucketName: string;
    /** object_name defines the name of the object which to be deleted. */
    objectName: string;
}
export interface MsgDeleteObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
}
export interface MsgDeleteObjectResponse {
}
export interface MsgDeleteObjectResponseSDKType {
}
export interface MsgDiscontinueObject {
    /** operator is the sp who wants to stop serving the objects. */
    operator: string;
    /** bucket_name defines the name of the bucket where the object which to be discontinued is stored. */
    bucketName: string;
    /** object_ids are the ids of object info. */
    objectIds: string[];
    /** the reason for the request. */
    reason: string;
}
export interface MsgDiscontinueObjectSDKType {
    operator: string;
    bucket_name: string;
    object_ids: string[];
    reason: string;
}
export interface MsgDiscontinueObjectResponse {
}
export interface MsgDiscontinueObjectResponseSDKType {
}
export interface MsgCreateGroup {
    /** owner defines the account address of group owner who create the group */
    creator: string;
    /** group_name defines the name of the group. it's not globally unique. */
    groupName: string;
    /** member_request defines a list of member which to be add or remove */
    members: string[];
}
export interface MsgCreateGroupSDKType {
    creator: string;
    group_name: string;
    members: string[];
}
export interface MsgCreateGroupResponse {
    groupId: string;
}
export interface MsgCreateGroupResponseSDKType {
    group_id: string;
}
export interface MsgDeleteGroup {
    /** operator defines the account address of the operator who has the DeleteGroup permission of the group to be deleted. */
    operator: string;
    /** group_name defines the name of the group which to be deleted */
    groupName: string;
}
export interface MsgDeleteGroupSDKType {
    operator: string;
    group_name: string;
}
export interface MsgDeleteGroupResponse {
}
export interface MsgDeleteGroupResponseSDKType {
}
export interface MsgUpdateGroupMember {
    /** operator defines the account address of the operator who has the UpdateGroupMember permission of the group. */
    operator: string;
    /** group_owner defines the account address of the group owner */
    groupOwner: string;
    /** group_name defines the name of the group which to be updated */
    groupName: string;
    /** members_to_add defines a list of members account address which will be add to the group */
    membersToAdd: string[];
    /** members_to_delete defines a list of members account address which will be remove from the group */
    membersToDelete: string[];
}
export interface MsgUpdateGroupMemberSDKType {
    operator: string;
    group_owner: string;
    group_name: string;
    members_to_add: string[];
    members_to_delete: string[];
}
export interface MsgUpdateGroupMemberResponse {
}
export interface MsgUpdateGroupMemberResponseSDKType {
}
export interface MsgLeaveGroup {
    /** member defines the account address of the member who want to leave the group */
    member: string;
    /** group_owner defines the owner of the group you want to leave */
    groupOwner: string;
    /** group_name defines the name of the group you want to leave */
    groupName: string;
}
export interface MsgLeaveGroupSDKType {
    member: string;
    group_owner: string;
    group_name: string;
}
export interface MsgLeaveGroupResponse {
}
export interface MsgLeaveGroupResponseSDKType {
}
export interface MsgUpdateBucketInfo {
    /** operator defines the account address of the operator */
    operator: string;
    /** bucket_name defines the name of bucket which you'll update */
    bucketName: string;
    /**
     * charged_read_quota defines the traffic quota that you read from primary sp
     * if read_quota is nil, it means don't change the read_quota
     */
    chargedReadQuota?: UInt64Value;
    /**
     * payment_address defines the account address of the payment account
     * if payment_address is empty, it means don't change the payment_address
     */
    paymentAddress: string;
    /**
     * visibility means the bucket is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility: VisibilityType;
}
export interface MsgUpdateBucketInfoSDKType {
    operator: string;
    bucket_name: string;
    charged_read_quota?: UInt64ValueSDKType;
    payment_address: string;
    visibility: VisibilityType;
}
export interface MsgUpdateBucketInfoResponse {
}
export interface MsgUpdateBucketInfoResponseSDKType {
}
export interface MsgCancelCreateObject {
    /** operator defines the account address of the operator */
    operator: string;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** object_name defines the name of the object */
    objectName: string;
}
export interface MsgCancelCreateObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
}
export interface MsgCancelCreateObjectResponse {
}
export interface MsgCancelCreateObjectResponseSDKType {
}
export interface MsgPutPolicy {
    /** operator defines the granter who grant the permission to another principal */
    operator: string;
    /** Principal defines the roles that can grant permissions. Currently, it can be account or group. */
    principal?: Principal;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource: string;
    /** statements defines a list of individual statement which describe the detail rules of policy */
    statements: Statement[];
    /**
     * expiration_time defines the whole expiration time of all the statements.
     * Notices: Its priority is higher than the expiration time inside the Statement
     */
    expirationTime?: Timestamp;
}
export interface MsgPutPolicySDKType {
    operator: string;
    principal?: PrincipalSDKType;
    resource: string;
    statements: StatementSDKType[];
    expiration_time?: TimestampSDKType;
}
export interface MsgPutPolicyResponse {
    policyId: string;
}
export interface MsgPutPolicyResponseSDKType {
    policy_id: string;
}
export interface MsgDeletePolicy {
    /** operator defines the granter who grant the permission to another principal */
    operator: string;
    /** Principal defines the roles that can grant permissions. Currently, it can be account or group. */
    principal?: Principal;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource: string;
}
export interface MsgDeletePolicySDKType {
    operator: string;
    principal?: PrincipalSDKType;
    resource: string;
}
export interface MsgDeletePolicyResponse {
    policyId: string;
}
export interface MsgDeletePolicyResponseSDKType {
    policy_id: string;
}
export interface MsgMirrorObject {
    /** operator defines the account address of the operator who has the DeleteObject permission of the object to be deleted. */
    operator: string;
    /** id defines the unique u256 for object. */
    id: string;
}
export interface MsgMirrorObjectSDKType {
    operator: string;
    id: string;
}
export interface MsgMirrorObjectResponse {
}
export interface MsgMirrorObjectResponseSDKType {
}
export interface MsgMirrorBucket {
    /** creator defines the account address of the grantee who has the DeleteBucket permission of the bucket to be deleted. */
    operator: string;
    /** id defines the unique u256 for bucket. */
    id: string;
}
export interface MsgMirrorBucketSDKType {
    operator: string;
    id: string;
}
export interface MsgUpdateObjectInfoResponse {
}
export interface MsgUpdateObjectInfoResponseSDKType {
}
export interface MsgUpdateObjectInfo {
    /** operator defines the account address of the operator */
    operator: string;
    /** bucket_name is the name of the bucket */
    bucketName: string;
    /** object_name defines the name of bucket which you'll update */
    objectName: string;
    /**
     * visibility means the object is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility: VisibilityType;
}
export interface MsgUpdateObjectInfoSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    visibility: VisibilityType;
}
export interface MsgMirrorBucketResponse {
}
export interface MsgMirrorBucketResponseSDKType {
}
export interface MsgMirrorGroup {
    /** operator defines the account address of the operator who has the DeleteGroup permission of the group to be deleted. */
    operator: string;
    /** id defines the unique u256 for group. */
    id: string;
}
export interface MsgMirrorGroupSDKType {
    operator: string;
    id: string;
}
export interface MsgMirrorGroupResponse {
}
export interface MsgMirrorGroupResponseSDKType {
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
    /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
    authority: string;
    /**
     * params defines the x/storage parameters to update.
     *
     * NOTE: All parameters must be supplied.
     */
    params?: Params;
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParamsSDKType {
    authority: string;
    params?: ParamsSDKType;
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponseSDKType {
}
export declare const MsgCreateBucket: {
    encode(message: MsgCreateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBucket;
    fromJSON(object: any): MsgCreateBucket;
    toJSON(message: MsgCreateBucket): unknown;
    fromPartial<I extends {
        creator?: string | undefined;
        bucketName?: string | undefined;
        visibility?: VisibilityType | undefined;
        paymentAddress?: string | undefined;
        primarySpAddress?: string | undefined;
        primarySpApproval?: {
            expiredHeight?: string | number | Long.Long | undefined;
            sig?: Uint8Array | undefined;
        } | undefined;
        chargedReadQuota?: string | number | Long.Long | undefined;
    } & {
        creator?: string | undefined;
        bucketName?: string | undefined;
        visibility?: VisibilityType | undefined;
        paymentAddress?: string | undefined;
        primarySpAddress?: string | undefined;
        primarySpApproval?: ({
            expiredHeight?: string | number | Long.Long | undefined;
            sig?: Uint8Array | undefined;
        } & {
            expiredHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["primarySpApproval"]["expiredHeight"], keyof Long.Long>, never>) | undefined;
            sig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["primarySpApproval"], keyof Approval>, never>) | undefined;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgCreateBucket>, never>>(object: I): MsgCreateBucket;
    fromSDK(object: MsgCreateBucketSDKType): MsgCreateBucket;
    toSDK(message: MsgCreateBucket): MsgCreateBucketSDKType;
};
export declare const MsgCreateBucketResponse: {
    encode(message: MsgCreateBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBucketResponse;
    fromJSON(object: any): MsgCreateBucketResponse;
    toJSON(message: MsgCreateBucketResponse): unknown;
    fromPartial<I extends {
        bucketId?: string | undefined;
    } & {
        bucketId?: string | undefined;
    } & Record<Exclude<keyof I, "bucketId">, never>>(object: I): MsgCreateBucketResponse;
    fromSDK(object: MsgCreateBucketResponseSDKType): MsgCreateBucketResponse;
    toSDK(message: MsgCreateBucketResponse): MsgCreateBucketResponseSDKType;
};
export declare const MsgDeleteBucket: {
    encode(message: MsgDeleteBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteBucket;
    fromJSON(object: any): MsgDeleteBucket;
    toJSON(message: MsgDeleteBucket): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgDeleteBucket>, never>>(object: I): MsgDeleteBucket;
    fromSDK(object: MsgDeleteBucketSDKType): MsgDeleteBucket;
    toSDK(message: MsgDeleteBucket): MsgDeleteBucketSDKType;
};
export declare const MsgDeleteBucketResponse: {
    encode(_: MsgDeleteBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteBucketResponse;
    fromJSON(_: any): MsgDeleteBucketResponse;
    toJSON(_: MsgDeleteBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDeleteBucketResponse;
    fromSDK(_: MsgDeleteBucketResponseSDKType): MsgDeleteBucketResponse;
    toSDK(_: MsgDeleteBucketResponse): MsgDeleteBucketResponseSDKType;
};
export declare const MsgDiscontinueBucket: {
    encode(message: MsgDiscontinueBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueBucket;
    fromJSON(object: any): MsgDiscontinueBucket;
    toJSON(message: MsgDiscontinueBucket): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        reason?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        reason?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgDiscontinueBucket>, never>>(object: I): MsgDiscontinueBucket;
    fromSDK(object: MsgDiscontinueBucketSDKType): MsgDiscontinueBucket;
    toSDK(message: MsgDiscontinueBucket): MsgDiscontinueBucketSDKType;
};
export declare const MsgDiscontinueBucketResponse: {
    encode(_: MsgDiscontinueBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueBucketResponse;
    fromJSON(_: any): MsgDiscontinueBucketResponse;
    toJSON(_: MsgDiscontinueBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDiscontinueBucketResponse;
    fromSDK(_: MsgDiscontinueBucketResponseSDKType): MsgDiscontinueBucketResponse;
    toSDK(_: MsgDiscontinueBucketResponse): MsgDiscontinueBucketResponseSDKType;
};
export declare const MsgCreateObject: {
    encode(message: MsgCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateObject;
    fromJSON(object: any): MsgCreateObject;
    toJSON(message: MsgCreateObject): unknown;
    fromPartial<I extends {
        creator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        payloadSize?: string | number | Long.Long | undefined;
        visibility?: VisibilityType | undefined;
        contentType?: string | undefined;
        primarySpApproval?: {
            expiredHeight?: string | number | Long.Long | undefined;
            sig?: Uint8Array | undefined;
        } | undefined;
        expectChecksums?: Uint8Array[] | undefined;
        redundancyType?: RedundancyType | undefined;
        expectSecondarySpAddresses?: string[] | undefined;
    } & {
        creator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>) | undefined;
        visibility?: VisibilityType | undefined;
        contentType?: string | undefined;
        primarySpApproval?: ({
            expiredHeight?: string | number | Long.Long | undefined;
            sig?: Uint8Array | undefined;
        } & {
            expiredHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["primarySpApproval"]["expiredHeight"], keyof Long.Long>, never>) | undefined;
            sig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["primarySpApproval"], keyof Approval>, never>) | undefined;
        expectChecksums?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["expectChecksums"], keyof Uint8Array[]>, never>) | undefined;
        redundancyType?: RedundancyType | undefined;
        expectSecondarySpAddresses?: (string[] & string[] & Record<Exclude<keyof I["expectSecondarySpAddresses"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgCreateObject>, never>>(object: I): MsgCreateObject;
    fromSDK(object: MsgCreateObjectSDKType): MsgCreateObject;
    toSDK(message: MsgCreateObject): MsgCreateObjectSDKType;
};
export declare const MsgCreateObjectResponse: {
    encode(message: MsgCreateObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateObjectResponse;
    fromJSON(object: any): MsgCreateObjectResponse;
    toJSON(message: MsgCreateObjectResponse): unknown;
    fromPartial<I extends {
        objectId?: string | undefined;
    } & {
        objectId?: string | undefined;
    } & Record<Exclude<keyof I, "objectId">, never>>(object: I): MsgCreateObjectResponse;
    fromSDK(object: MsgCreateObjectResponseSDKType): MsgCreateObjectResponse;
    toSDK(message: MsgCreateObjectResponse): MsgCreateObjectResponseSDKType;
};
export declare const MsgSealObject: {
    encode(message: MsgSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSealObject;
    fromJSON(object: any): MsgSealObject;
    toJSON(message: MsgSealObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        secondarySpAddresses?: string[] | undefined;
        secondarySpSignatures?: Uint8Array[] | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        secondarySpAddresses?: (string[] & string[] & Record<Exclude<keyof I["secondarySpAddresses"], keyof string[]>, never>) | undefined;
        secondarySpSignatures?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["secondarySpSignatures"], keyof Uint8Array[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgSealObject>, never>>(object: I): MsgSealObject;
    fromSDK(object: MsgSealObjectSDKType): MsgSealObject;
    toSDK(message: MsgSealObject): MsgSealObjectSDKType;
};
export declare const MsgSealObjectResponse: {
    encode(_: MsgSealObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSealObjectResponse;
    fromJSON(_: any): MsgSealObjectResponse;
    toJSON(_: MsgSealObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgSealObjectResponse;
    fromSDK(_: MsgSealObjectResponseSDKType): MsgSealObjectResponse;
    toSDK(_: MsgSealObjectResponse): MsgSealObjectResponseSDKType;
};
export declare const MsgRejectSealObject: {
    encode(message: MsgRejectSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRejectSealObject;
    fromJSON(object: any): MsgRejectSealObject;
    toJSON(message: MsgRejectSealObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgRejectSealObject>, never>>(object: I): MsgRejectSealObject;
    fromSDK(object: MsgRejectSealObjectSDKType): MsgRejectSealObject;
    toSDK(message: MsgRejectSealObject): MsgRejectSealObjectSDKType;
};
export declare const MsgRejectSealObjectResponse: {
    encode(_: MsgRejectSealObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRejectSealObjectResponse;
    fromJSON(_: any): MsgRejectSealObjectResponse;
    toJSON(_: MsgRejectSealObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgRejectSealObjectResponse;
    fromSDK(_: MsgRejectSealObjectResponseSDKType): MsgRejectSealObjectResponse;
    toSDK(_: MsgRejectSealObjectResponse): MsgRejectSealObjectResponseSDKType;
};
export declare const MsgCopyObject: {
    encode(message: MsgCopyObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCopyObject;
    fromJSON(object: any): MsgCopyObject;
    toJSON(message: MsgCopyObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        srcBucketName?: string | undefined;
        dstBucketName?: string | undefined;
        srcObjectName?: string | undefined;
        dstObjectName?: string | undefined;
        dstPrimarySpApproval?: {
            expiredHeight?: string | number | Long.Long | undefined;
            sig?: Uint8Array | undefined;
        } | undefined;
    } & {
        operator?: string | undefined;
        srcBucketName?: string | undefined;
        dstBucketName?: string | undefined;
        srcObjectName?: string | undefined;
        dstObjectName?: string | undefined;
        dstPrimarySpApproval?: ({
            expiredHeight?: string | number | Long.Long | undefined;
            sig?: Uint8Array | undefined;
        } & {
            expiredHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["dstPrimarySpApproval"]["expiredHeight"], keyof Long.Long>, never>) | undefined;
            sig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["dstPrimarySpApproval"], keyof Approval>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgCopyObject>, never>>(object: I): MsgCopyObject;
    fromSDK(object: MsgCopyObjectSDKType): MsgCopyObject;
    toSDK(message: MsgCopyObject): MsgCopyObjectSDKType;
};
export declare const MsgCopyObjectResponse: {
    encode(message: MsgCopyObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCopyObjectResponse;
    fromJSON(object: any): MsgCopyObjectResponse;
    toJSON(message: MsgCopyObjectResponse): unknown;
    fromPartial<I extends {
        objectId?: string | undefined;
    } & {
        objectId?: string | undefined;
    } & Record<Exclude<keyof I, "objectId">, never>>(object: I): MsgCopyObjectResponse;
    fromSDK(object: MsgCopyObjectResponseSDKType): MsgCopyObjectResponse;
    toSDK(message: MsgCopyObjectResponse): MsgCopyObjectResponseSDKType;
};
export declare const MsgDeleteObject: {
    encode(message: MsgDeleteObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteObject;
    fromJSON(object: any): MsgDeleteObject;
    toJSON(message: MsgDeleteObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgDeleteObject>, never>>(object: I): MsgDeleteObject;
    fromSDK(object: MsgDeleteObjectSDKType): MsgDeleteObject;
    toSDK(message: MsgDeleteObject): MsgDeleteObjectSDKType;
};
export declare const MsgDeleteObjectResponse: {
    encode(_: MsgDeleteObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteObjectResponse;
    fromJSON(_: any): MsgDeleteObjectResponse;
    toJSON(_: MsgDeleteObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDeleteObjectResponse;
    fromSDK(_: MsgDeleteObjectResponseSDKType): MsgDeleteObjectResponse;
    toSDK(_: MsgDeleteObjectResponse): MsgDeleteObjectResponseSDKType;
};
export declare const MsgDiscontinueObject: {
    encode(message: MsgDiscontinueObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueObject;
    fromJSON(object: any): MsgDiscontinueObject;
    toJSON(message: MsgDiscontinueObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectIds?: string[] | undefined;
        reason?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectIds?: (string[] & string[] & Record<Exclude<keyof I["objectIds"], keyof string[]>, never>) | undefined;
        reason?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgDiscontinueObject>, never>>(object: I): MsgDiscontinueObject;
    fromSDK(object: MsgDiscontinueObjectSDKType): MsgDiscontinueObject;
    toSDK(message: MsgDiscontinueObject): MsgDiscontinueObjectSDKType;
};
export declare const MsgDiscontinueObjectResponse: {
    encode(_: MsgDiscontinueObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueObjectResponse;
    fromJSON(_: any): MsgDiscontinueObjectResponse;
    toJSON(_: MsgDiscontinueObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDiscontinueObjectResponse;
    fromSDK(_: MsgDiscontinueObjectResponseSDKType): MsgDiscontinueObjectResponse;
    toSDK(_: MsgDiscontinueObjectResponse): MsgDiscontinueObjectResponseSDKType;
};
export declare const MsgCreateGroup: {
    encode(message: MsgCreateGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateGroup;
    fromJSON(object: any): MsgCreateGroup;
    toJSON(message: MsgCreateGroup): unknown;
    fromPartial<I extends {
        creator?: string | undefined;
        groupName?: string | undefined;
        members?: string[] | undefined;
    } & {
        creator?: string | undefined;
        groupName?: string | undefined;
        members?: (string[] & string[] & Record<Exclude<keyof I["members"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgCreateGroup>, never>>(object: I): MsgCreateGroup;
    fromSDK(object: MsgCreateGroupSDKType): MsgCreateGroup;
    toSDK(message: MsgCreateGroup): MsgCreateGroupSDKType;
};
export declare const MsgCreateGroupResponse: {
    encode(message: MsgCreateGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateGroupResponse;
    fromJSON(object: any): MsgCreateGroupResponse;
    toJSON(message: MsgCreateGroupResponse): unknown;
    fromPartial<I extends {
        groupId?: string | undefined;
    } & {
        groupId?: string | undefined;
    } & Record<Exclude<keyof I, "groupId">, never>>(object: I): MsgCreateGroupResponse;
    fromSDK(object: MsgCreateGroupResponseSDKType): MsgCreateGroupResponse;
    toSDK(message: MsgCreateGroupResponse): MsgCreateGroupResponseSDKType;
};
export declare const MsgDeleteGroup: {
    encode(message: MsgDeleteGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteGroup;
    fromJSON(object: any): MsgDeleteGroup;
    toJSON(message: MsgDeleteGroup): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        groupName?: string | undefined;
    } & {
        operator?: string | undefined;
        groupName?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgDeleteGroup>, never>>(object: I): MsgDeleteGroup;
    fromSDK(object: MsgDeleteGroupSDKType): MsgDeleteGroup;
    toSDK(message: MsgDeleteGroup): MsgDeleteGroupSDKType;
};
export declare const MsgDeleteGroupResponse: {
    encode(_: MsgDeleteGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteGroupResponse;
    fromJSON(_: any): MsgDeleteGroupResponse;
    toJSON(_: MsgDeleteGroupResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDeleteGroupResponse;
    fromSDK(_: MsgDeleteGroupResponseSDKType): MsgDeleteGroupResponse;
    toSDK(_: MsgDeleteGroupResponse): MsgDeleteGroupResponseSDKType;
};
export declare const MsgUpdateGroupMember: {
    encode(message: MsgUpdateGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateGroupMember;
    fromJSON(object: any): MsgUpdateGroupMember;
    toJSON(message: MsgUpdateGroupMember): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        groupOwner?: string | undefined;
        groupName?: string | undefined;
        membersToAdd?: string[] | undefined;
        membersToDelete?: string[] | undefined;
    } & {
        operator?: string | undefined;
        groupOwner?: string | undefined;
        groupName?: string | undefined;
        membersToAdd?: (string[] & string[] & Record<Exclude<keyof I["membersToAdd"], keyof string[]>, never>) | undefined;
        membersToDelete?: (string[] & string[] & Record<Exclude<keyof I["membersToDelete"], keyof string[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgUpdateGroupMember>, never>>(object: I): MsgUpdateGroupMember;
    fromSDK(object: MsgUpdateGroupMemberSDKType): MsgUpdateGroupMember;
    toSDK(message: MsgUpdateGroupMember): MsgUpdateGroupMemberSDKType;
};
export declare const MsgUpdateGroupMemberResponse: {
    encode(_: MsgUpdateGroupMemberResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateGroupMemberResponse;
    fromJSON(_: any): MsgUpdateGroupMemberResponse;
    toJSON(_: MsgUpdateGroupMemberResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateGroupMemberResponse;
    fromSDK(_: MsgUpdateGroupMemberResponseSDKType): MsgUpdateGroupMemberResponse;
    toSDK(_: MsgUpdateGroupMemberResponse): MsgUpdateGroupMemberResponseSDKType;
};
export declare const MsgLeaveGroup: {
    encode(message: MsgLeaveGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgLeaveGroup;
    fromJSON(object: any): MsgLeaveGroup;
    toJSON(message: MsgLeaveGroup): unknown;
    fromPartial<I extends {
        member?: string | undefined;
        groupOwner?: string | undefined;
        groupName?: string | undefined;
    } & {
        member?: string | undefined;
        groupOwner?: string | undefined;
        groupName?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgLeaveGroup>, never>>(object: I): MsgLeaveGroup;
    fromSDK(object: MsgLeaveGroupSDKType): MsgLeaveGroup;
    toSDK(message: MsgLeaveGroup): MsgLeaveGroupSDKType;
};
export declare const MsgLeaveGroupResponse: {
    encode(_: MsgLeaveGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgLeaveGroupResponse;
    fromJSON(_: any): MsgLeaveGroupResponse;
    toJSON(_: MsgLeaveGroupResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgLeaveGroupResponse;
    fromSDK(_: MsgLeaveGroupResponseSDKType): MsgLeaveGroupResponse;
    toSDK(_: MsgLeaveGroupResponse): MsgLeaveGroupResponseSDKType;
};
export declare const MsgUpdateBucketInfo: {
    encode(message: MsgUpdateBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateBucketInfo;
    fromJSON(object: any): MsgUpdateBucketInfo;
    toJSON(message: MsgUpdateBucketInfo): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        chargedReadQuota?: {
            value?: string | number | Long.Long | undefined;
        } | undefined;
        paymentAddress?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        chargedReadQuota?: ({
            value?: string | number | Long.Long | undefined;
        } & {
            value?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["chargedReadQuota"]["value"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["chargedReadQuota"], "value">, never>) | undefined;
        paymentAddress?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & Record<Exclude<keyof I, keyof MsgUpdateBucketInfo>, never>>(object: I): MsgUpdateBucketInfo;
    fromSDK(object: MsgUpdateBucketInfoSDKType): MsgUpdateBucketInfo;
    toSDK(message: MsgUpdateBucketInfo): MsgUpdateBucketInfoSDKType;
};
export declare const MsgUpdateBucketInfoResponse: {
    encode(_: MsgUpdateBucketInfoResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateBucketInfoResponse;
    fromJSON(_: any): MsgUpdateBucketInfoResponse;
    toJSON(_: MsgUpdateBucketInfoResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateBucketInfoResponse;
    fromSDK(_: MsgUpdateBucketInfoResponseSDKType): MsgUpdateBucketInfoResponse;
    toSDK(_: MsgUpdateBucketInfoResponse): MsgUpdateBucketInfoResponseSDKType;
};
export declare const MsgCancelCreateObject: {
    encode(message: MsgCancelCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelCreateObject;
    fromJSON(object: any): MsgCancelCreateObject;
    toJSON(message: MsgCancelCreateObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgCancelCreateObject>, never>>(object: I): MsgCancelCreateObject;
    fromSDK(object: MsgCancelCreateObjectSDKType): MsgCancelCreateObject;
    toSDK(message: MsgCancelCreateObject): MsgCancelCreateObjectSDKType;
};
export declare const MsgCancelCreateObjectResponse: {
    encode(_: MsgCancelCreateObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelCreateObjectResponse;
    fromJSON(_: any): MsgCancelCreateObjectResponse;
    toJSON(_: MsgCancelCreateObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCancelCreateObjectResponse;
    fromSDK(_: MsgCancelCreateObjectResponseSDKType): MsgCancelCreateObjectResponse;
    toSDK(_: MsgCancelCreateObjectResponse): MsgCancelCreateObjectResponseSDKType;
};
export declare const MsgPutPolicy: {
    encode(message: MsgPutPolicy, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgPutPolicy;
    fromJSON(object: any): MsgPutPolicy;
    toJSON(message: MsgPutPolicy): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        principal?: {
            type?: import("../permission/common").PrincipalType | undefined;
            value?: string | undefined;
        } | undefined;
        resource?: string | undefined;
        statements?: {
            effect?: import("../permission/common").Effect | undefined;
            actions?: import("../permission/common").ActionType[] | undefined;
            resources?: string[] | undefined;
            expirationTime?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            limitSize?: {
                value?: string | number | Long.Long | undefined;
            } | undefined;
        }[] | undefined;
        expirationTime?: {
            seconds?: string | number | Long.Long | undefined;
            nanos?: number | undefined;
        } | undefined;
    } & {
        operator?: string | undefined;
        principal?: ({
            type?: import("../permission/common").PrincipalType | undefined;
            value?: string | undefined;
        } & {
            type?: import("../permission/common").PrincipalType | undefined;
            value?: string | undefined;
        } & Record<Exclude<keyof I["principal"], keyof Principal>, never>) | undefined;
        resource?: string | undefined;
        statements?: ({
            effect?: import("../permission/common").Effect | undefined;
            actions?: import("../permission/common").ActionType[] | undefined;
            resources?: string[] | undefined;
            expirationTime?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            limitSize?: {
                value?: string | number | Long.Long | undefined;
            } | undefined;
        }[] & ({
            effect?: import("../permission/common").Effect | undefined;
            actions?: import("../permission/common").ActionType[] | undefined;
            resources?: string[] | undefined;
            expirationTime?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            limitSize?: {
                value?: string | number | Long.Long | undefined;
            } | undefined;
        } & {
            effect?: import("../permission/common").Effect | undefined;
            actions?: (import("../permission/common").ActionType[] & import("../permission/common").ActionType[] & Record<Exclude<keyof I["statements"][number]["actions"], keyof import("../permission/common").ActionType[]>, never>) | undefined;
            resources?: (string[] & string[] & Record<Exclude<keyof I["statements"][number]["resources"], keyof string[]>, never>) | undefined;
            expirationTime?: ({
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>) | undefined;
                nanos?: number | undefined;
            } & Record<Exclude<keyof I["statements"][number]["expirationTime"], keyof Timestamp>, never>) | undefined;
            limitSize?: ({
                value?: string | number | Long.Long | undefined;
            } & {
                value?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["statements"][number]["limitSize"], "value">, never>) | undefined;
        } & Record<Exclude<keyof I["statements"][number], keyof Statement>, never>)[] & Record<Exclude<keyof I["statements"], keyof {
            effect?: import("../permission/common").Effect | undefined;
            actions?: import("../permission/common").ActionType[] | undefined;
            resources?: string[] | undefined;
            expirationTime?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            limitSize?: {
                value?: string | number | Long.Long | undefined;
            } | undefined;
        }[]>, never>) | undefined;
        expirationTime?: ({
            seconds?: string | number | Long.Long | undefined;
            nanos?: number | undefined;
        } & {
            seconds?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["expirationTime"]["seconds"], keyof Long.Long>, never>) | undefined;
            nanos?: number | undefined;
        } & Record<Exclude<keyof I["expirationTime"], keyof Timestamp>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgPutPolicy>, never>>(object: I): MsgPutPolicy;
    fromSDK(object: MsgPutPolicySDKType): MsgPutPolicy;
    toSDK(message: MsgPutPolicy): MsgPutPolicySDKType;
};
export declare const MsgPutPolicyResponse: {
    encode(message: MsgPutPolicyResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgPutPolicyResponse;
    fromJSON(object: any): MsgPutPolicyResponse;
    toJSON(message: MsgPutPolicyResponse): unknown;
    fromPartial<I extends {
        policyId?: string | undefined;
    } & {
        policyId?: string | undefined;
    } & Record<Exclude<keyof I, "policyId">, never>>(object: I): MsgPutPolicyResponse;
    fromSDK(object: MsgPutPolicyResponseSDKType): MsgPutPolicyResponse;
    toSDK(message: MsgPutPolicyResponse): MsgPutPolicyResponseSDKType;
};
export declare const MsgDeletePolicy: {
    encode(message: MsgDeletePolicy, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeletePolicy;
    fromJSON(object: any): MsgDeletePolicy;
    toJSON(message: MsgDeletePolicy): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        principal?: {
            type?: import("../permission/common").PrincipalType | undefined;
            value?: string | undefined;
        } | undefined;
        resource?: string | undefined;
    } & {
        operator?: string | undefined;
        principal?: ({
            type?: import("../permission/common").PrincipalType | undefined;
            value?: string | undefined;
        } & {
            type?: import("../permission/common").PrincipalType | undefined;
            value?: string | undefined;
        } & Record<Exclude<keyof I["principal"], keyof Principal>, never>) | undefined;
        resource?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgDeletePolicy>, never>>(object: I): MsgDeletePolicy;
    fromSDK(object: MsgDeletePolicySDKType): MsgDeletePolicy;
    toSDK(message: MsgDeletePolicy): MsgDeletePolicySDKType;
};
export declare const MsgDeletePolicyResponse: {
    encode(message: MsgDeletePolicyResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeletePolicyResponse;
    fromJSON(object: any): MsgDeletePolicyResponse;
    toJSON(message: MsgDeletePolicyResponse): unknown;
    fromPartial<I extends {
        policyId?: string | undefined;
    } & {
        policyId?: string | undefined;
    } & Record<Exclude<keyof I, "policyId">, never>>(object: I): MsgDeletePolicyResponse;
    fromSDK(object: MsgDeletePolicyResponseSDKType): MsgDeletePolicyResponse;
    toSDK(message: MsgDeletePolicyResponse): MsgDeletePolicyResponseSDKType;
};
export declare const MsgMirrorObject: {
    encode(message: MsgMirrorObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorObject;
    fromJSON(object: any): MsgMirrorObject;
    toJSON(message: MsgMirrorObject): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        id?: string | undefined;
    } & {
        operator?: string | undefined;
        id?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgMirrorObject>, never>>(object: I): MsgMirrorObject;
    fromSDK(object: MsgMirrorObjectSDKType): MsgMirrorObject;
    toSDK(message: MsgMirrorObject): MsgMirrorObjectSDKType;
};
export declare const MsgMirrorObjectResponse: {
    encode(_: MsgMirrorObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorObjectResponse;
    fromJSON(_: any): MsgMirrorObjectResponse;
    toJSON(_: MsgMirrorObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgMirrorObjectResponse;
    fromSDK(_: MsgMirrorObjectResponseSDKType): MsgMirrorObjectResponse;
    toSDK(_: MsgMirrorObjectResponse): MsgMirrorObjectResponseSDKType;
};
export declare const MsgMirrorBucket: {
    encode(message: MsgMirrorBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorBucket;
    fromJSON(object: any): MsgMirrorBucket;
    toJSON(message: MsgMirrorBucket): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        id?: string | undefined;
    } & {
        operator?: string | undefined;
        id?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgMirrorBucket>, never>>(object: I): MsgMirrorBucket;
    fromSDK(object: MsgMirrorBucketSDKType): MsgMirrorBucket;
    toSDK(message: MsgMirrorBucket): MsgMirrorBucketSDKType;
};
export declare const MsgUpdateObjectInfoResponse: {
    encode(_: MsgUpdateObjectInfoResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateObjectInfoResponse;
    fromJSON(_: any): MsgUpdateObjectInfoResponse;
    toJSON(_: MsgUpdateObjectInfoResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateObjectInfoResponse;
    fromSDK(_: MsgUpdateObjectInfoResponseSDKType): MsgUpdateObjectInfoResponse;
    toSDK(_: MsgUpdateObjectInfoResponse): MsgUpdateObjectInfoResponseSDKType;
};
export declare const MsgUpdateObjectInfo: {
    encode(message: MsgUpdateObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateObjectInfo;
    fromJSON(object: any): MsgUpdateObjectInfo;
    toJSON(message: MsgUpdateObjectInfo): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & {
        operator?: string | undefined;
        bucketName?: string | undefined;
        objectName?: string | undefined;
        visibility?: VisibilityType | undefined;
    } & Record<Exclude<keyof I, keyof MsgUpdateObjectInfo>, never>>(object: I): MsgUpdateObjectInfo;
    fromSDK(object: MsgUpdateObjectInfoSDKType): MsgUpdateObjectInfo;
    toSDK(message: MsgUpdateObjectInfo): MsgUpdateObjectInfoSDKType;
};
export declare const MsgMirrorBucketResponse: {
    encode(_: MsgMirrorBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorBucketResponse;
    fromJSON(_: any): MsgMirrorBucketResponse;
    toJSON(_: MsgMirrorBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgMirrorBucketResponse;
    fromSDK(_: MsgMirrorBucketResponseSDKType): MsgMirrorBucketResponse;
    toSDK(_: MsgMirrorBucketResponse): MsgMirrorBucketResponseSDKType;
};
export declare const MsgMirrorGroup: {
    encode(message: MsgMirrorGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorGroup;
    fromJSON(object: any): MsgMirrorGroup;
    toJSON(message: MsgMirrorGroup): unknown;
    fromPartial<I extends {
        operator?: string | undefined;
        id?: string | undefined;
    } & {
        operator?: string | undefined;
        id?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgMirrorGroup>, never>>(object: I): MsgMirrorGroup;
    fromSDK(object: MsgMirrorGroupSDKType): MsgMirrorGroup;
    toSDK(message: MsgMirrorGroup): MsgMirrorGroupSDKType;
};
export declare const MsgMirrorGroupResponse: {
    encode(_: MsgMirrorGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorGroupResponse;
    fromJSON(_: any): MsgMirrorGroupResponse;
    toJSON(_: MsgMirrorGroupResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgMirrorGroupResponse;
    fromSDK(_: MsgMirrorGroupResponseSDKType): MsgMirrorGroupResponse;
    toSDK(_: MsgMirrorGroupResponse): MsgMirrorGroupResponseSDKType;
};
export declare const MsgUpdateParams: {
    encode(message: MsgUpdateParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams;
    fromJSON(object: any): MsgUpdateParams;
    toJSON(message: MsgUpdateParams): unknown;
    fromPartial<I extends {
        authority?: string | undefined;
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | Long.Long | undefined;
            } | undefined;
            maxPayloadSize?: string | number | Long.Long | undefined;
            mirrorBucketRelayerFee?: string | undefined;
            mirrorBucketAckRelayerFee?: string | undefined;
            mirrorObjectRelayerFee?: string | undefined;
            mirrorObjectAckRelayerFee?: string | undefined;
            mirrorGroupRelayerFee?: string | undefined;
            mirrorGroupAckRelayerFee?: string | undefined;
            maxBucketsPerAccount?: number | undefined;
            discontinueCountingWindow?: string | number | Long.Long | undefined;
            discontinueObjectMax?: string | number | Long.Long | undefined;
            discontinueBucketMax?: string | number | Long.Long | undefined;
            discontinueConfirmPeriod?: string | number | Long.Long | undefined;
            discontinueDeletionMax?: string | number | Long.Long | undefined;
            stalePolicyCleanupMax?: string | number | Long.Long | undefined;
        } | undefined;
    } & {
        authority?: string | undefined;
        params?: ({
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | Long.Long | undefined;
            } | undefined;
            maxPayloadSize?: string | number | Long.Long | undefined;
            mirrorBucketRelayerFee?: string | undefined;
            mirrorBucketAckRelayerFee?: string | undefined;
            mirrorObjectRelayerFee?: string | undefined;
            mirrorObjectAckRelayerFee?: string | undefined;
            mirrorGroupRelayerFee?: string | undefined;
            mirrorGroupAckRelayerFee?: string | undefined;
            maxBucketsPerAccount?: number | undefined;
            discontinueCountingWindow?: string | number | Long.Long | undefined;
            discontinueObjectMax?: string | number | Long.Long | undefined;
            discontinueBucketMax?: string | number | Long.Long | undefined;
            discontinueConfirmPeriod?: string | number | Long.Long | undefined;
            discontinueDeletionMax?: string | number | Long.Long | undefined;
            stalePolicyCleanupMax?: string | number | Long.Long | undefined;
        } & {
            versionedParams?: ({
                maxSegmentSize?: string | number | Long.Long | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | Long.Long | undefined;
            } & {
                maxSegmentSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["maxSegmentSize"], keyof Long.Long>, never>) | undefined;
                redundantDataChunkNum?: number | undefined;
                redundantParityChunkNum?: number | undefined;
                minChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["minChargeSize"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>) | undefined;
            maxPayloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxPayloadSize"], keyof Long.Long>, never>) | undefined;
            mirrorBucketRelayerFee?: string | undefined;
            mirrorBucketAckRelayerFee?: string | undefined;
            mirrorObjectRelayerFee?: string | undefined;
            mirrorObjectAckRelayerFee?: string | undefined;
            mirrorGroupRelayerFee?: string | undefined;
            mirrorGroupAckRelayerFee?: string | undefined;
            maxBucketsPerAccount?: number | undefined;
            discontinueCountingWindow?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueCountingWindow"], keyof Long.Long>, never>) | undefined;
            discontinueObjectMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueObjectMax"], keyof Long.Long>, never>) | undefined;
            discontinueBucketMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueBucketMax"], keyof Long.Long>, never>) | undefined;
            discontinueConfirmPeriod?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueConfirmPeriod"], keyof Long.Long>, never>) | undefined;
            discontinueDeletionMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueDeletionMax"], keyof Long.Long>, never>) | undefined;
            stalePolicyCleanupMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["stalePolicyCleanupMax"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgUpdateParams>, never>>(object: I): MsgUpdateParams;
    fromSDK(object: MsgUpdateParamsSDKType): MsgUpdateParams;
    toSDK(message: MsgUpdateParams): MsgUpdateParamsSDKType;
};
export declare const MsgUpdateParamsResponse: {
    encode(_: MsgUpdateParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParamsResponse;
    fromJSON(_: any): MsgUpdateParamsResponse;
    toJSON(_: MsgUpdateParamsResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateParamsResponse;
    fromSDK(_: MsgUpdateParamsResponseSDKType): MsgUpdateParamsResponse;
    toSDK(_: MsgUpdateParamsResponse): MsgUpdateParamsResponseSDKType;
};
/** Msg defines the Msg service. */
export interface Msg {
    /** basic operation of bucket */
    CreateBucket(request: MsgCreateBucket): Promise<MsgCreateBucketResponse>;
    DeleteBucket(request: MsgDeleteBucket): Promise<MsgDeleteBucketResponse>;
    UpdateBucketInfo(request: MsgUpdateBucketInfo): Promise<MsgUpdateBucketInfoResponse>;
    MirrorBucket(request: MsgMirrorBucket): Promise<MsgMirrorBucketResponse>;
    DiscontinueBucket(request: MsgDiscontinueBucket): Promise<MsgDiscontinueBucketResponse>;
    /** basic operation of object */
    CreateObject(request: MsgCreateObject): Promise<MsgCreateObjectResponse>;
    SealObject(request: MsgSealObject): Promise<MsgSealObjectResponse>;
    RejectSealObject(request: MsgRejectSealObject): Promise<MsgRejectSealObjectResponse>;
    CopyObject(request: MsgCopyObject): Promise<MsgCopyObjectResponse>;
    DeleteObject(request: MsgDeleteObject): Promise<MsgDeleteObjectResponse>;
    CancelCreateObject(request: MsgCancelCreateObject): Promise<MsgCancelCreateObjectResponse>;
    MirrorObject(request: MsgMirrorObject): Promise<MsgMirrorObjectResponse>;
    DiscontinueObject(request: MsgDiscontinueObject): Promise<MsgDiscontinueObjectResponse>;
    UpdateObjectInfo(request: MsgUpdateObjectInfo): Promise<MsgUpdateObjectInfoResponse>;
    /** basic operation of group */
    CreateGroup(request: MsgCreateGroup): Promise<MsgCreateGroupResponse>;
    DeleteGroup(request: MsgDeleteGroup): Promise<MsgDeleteGroupResponse>;
    UpdateGroupMember(request: MsgUpdateGroupMember): Promise<MsgUpdateGroupMemberResponse>;
    LeaveGroup(request: MsgLeaveGroup): Promise<MsgLeaveGroupResponse>;
    MirrorGroup(request: MsgMirrorGroup): Promise<MsgMirrorGroupResponse>;
    /** basic operation of policy */
    PutPolicy(request: MsgPutPolicy): Promise<MsgPutPolicyResponse>;
    DeletePolicy(request: MsgDeletePolicy): Promise<MsgDeletePolicyResponse>;
    /**
     * UpdateParams defines a governance operation for updating the x/storage module parameters.
     * The authority is defined in the keeper.
     *
     * Since: cosmos-sdk 0.47
     */
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    constructor(rpc: Rpc);
    CreateBucket(request: MsgCreateBucket): Promise<MsgCreateBucketResponse>;
    DeleteBucket(request: MsgDeleteBucket): Promise<MsgDeleteBucketResponse>;
    UpdateBucketInfo(request: MsgUpdateBucketInfo): Promise<MsgUpdateBucketInfoResponse>;
    MirrorBucket(request: MsgMirrorBucket): Promise<MsgMirrorBucketResponse>;
    DiscontinueBucket(request: MsgDiscontinueBucket): Promise<MsgDiscontinueBucketResponse>;
    CreateObject(request: MsgCreateObject): Promise<MsgCreateObjectResponse>;
    SealObject(request: MsgSealObject): Promise<MsgSealObjectResponse>;
    RejectSealObject(request: MsgRejectSealObject): Promise<MsgRejectSealObjectResponse>;
    CopyObject(request: MsgCopyObject): Promise<MsgCopyObjectResponse>;
    DeleteObject(request: MsgDeleteObject): Promise<MsgDeleteObjectResponse>;
    CancelCreateObject(request: MsgCancelCreateObject): Promise<MsgCancelCreateObjectResponse>;
    MirrorObject(request: MsgMirrorObject): Promise<MsgMirrorObjectResponse>;
    DiscontinueObject(request: MsgDiscontinueObject): Promise<MsgDiscontinueObjectResponse>;
    UpdateObjectInfo(request: MsgUpdateObjectInfo): Promise<MsgUpdateObjectInfoResponse>;
    CreateGroup(request: MsgCreateGroup): Promise<MsgCreateGroupResponse>;
    DeleteGroup(request: MsgDeleteGroup): Promise<MsgDeleteGroupResponse>;
    UpdateGroupMember(request: MsgUpdateGroupMember): Promise<MsgUpdateGroupMemberResponse>;
    LeaveGroup(request: MsgLeaveGroup): Promise<MsgLeaveGroupResponse>;
    MirrorGroup(request: MsgMirrorGroup): Promise<MsgMirrorGroupResponse>;
    PutPolicy(request: MsgPutPolicy): Promise<MsgPutPolicyResponse>;
    DeletePolicy(request: MsgDeletePolicy): Promise<MsgDeletePolicyResponse>;
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}
