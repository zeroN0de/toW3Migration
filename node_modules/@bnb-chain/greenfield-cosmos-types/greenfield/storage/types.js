"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleteInfo = exports.Ids = exports.GroupMetaData = exports.ObjectMetaData = exports.BucketMetaData = exports.Trait = exports.GroupInfo = exports.ObjectInfo = exports.SecondarySpObjectsSize = exports.BillingInfo = exports.BucketInfo = exports.protobufPackage = void 0;
/* eslint-disable */
const common_1 = require("./common");
const helpers_1 = require("../../helpers");
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "greenfield.storage";
function createBaseBucketInfo() {
    return {
        owner: "",
        bucketName: "",
        visibility: 0,
        id: "",
        sourceType: 0,
        createAt: helpers_1.Long.ZERO,
        paymentAddress: "",
        primarySpAddress: "",
        chargedReadQuota: helpers_1.Long.UZERO,
        billingInfo: undefined,
        bucketStatus: 0
    };
}
exports.BucketInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        if (message.bucketName !== "") {
            writer.uint32(18).string(message.bucketName);
        }
        if (message.visibility !== 0) {
            writer.uint32(24).int32(message.visibility);
        }
        if (message.id !== "") {
            writer.uint32(34).string(message.id);
        }
        if (message.sourceType !== 0) {
            writer.uint32(40).int32(message.sourceType);
        }
        if (!message.createAt.isZero()) {
            writer.uint32(48).int64(message.createAt);
        }
        if (message.paymentAddress !== "") {
            writer.uint32(58).string(message.paymentAddress);
        }
        if (message.primarySpAddress !== "") {
            writer.uint32(66).string(message.primarySpAddress);
        }
        if (!message.chargedReadQuota.isZero()) {
            writer.uint32(72).uint64(message.chargedReadQuota);
        }
        if (message.billingInfo !== undefined) {
            exports.BillingInfo.encode(message.billingInfo, writer.uint32(82).fork()).ldelim();
        }
        if (message.bucketStatus !== 0) {
            writer.uint32(88).int32(message.bucketStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBucketInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.bucketName = reader.string();
                    break;
                case 3:
                    message.visibility = reader.int32();
                    break;
                case 4:
                    message.id = reader.string();
                    break;
                case 5:
                    message.sourceType = reader.int32();
                    break;
                case 6:
                    message.createAt = reader.int64();
                    break;
                case 7:
                    message.paymentAddress = reader.string();
                    break;
                case 8:
                    message.primarySpAddress = reader.string();
                    break;
                case 9:
                    message.chargedReadQuota = reader.uint64();
                    break;
                case 10:
                    message.billingInfo = exports.BillingInfo.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.bucketStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : "",
            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : "",
            sourceType: (0, helpers_1.isSet)(object.sourceType) ? (0, common_1.sourceTypeFromJSON)(object.sourceType) : 0,
            createAt: (0, helpers_1.isSet)(object.createAt) ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO,
            paymentAddress: (0, helpers_1.isSet)(object.paymentAddress) ? String(object.paymentAddress) : "",
            primarySpAddress: (0, helpers_1.isSet)(object.primarySpAddress) ? String(object.primarySpAddress) : "",
            chargedReadQuota: (0, helpers_1.isSet)(object.chargedReadQuota) ? helpers_1.Long.fromValue(object.chargedReadQuota) : helpers_1.Long.UZERO,
            billingInfo: (0, helpers_1.isSet)(object.billingInfo) ? exports.BillingInfo.fromJSON(object.billingInfo) : undefined,
            bucketStatus: (0, helpers_1.isSet)(object.bucketStatus) ? (0, common_1.bucketStatusFromJSON)(object.bucketStatus) : 0
        };
    },
    toJSON(message) {
        const obj = {};
        message.owner !== undefined && (obj.owner = message.owner);
        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
        message.id !== undefined && (obj.id = message.id);
        message.sourceType !== undefined && (obj.sourceType = (0, common_1.sourceTypeToJSON)(message.sourceType));
        message.createAt !== undefined && (obj.createAt = (message.createAt || helpers_1.Long.ZERO).toString());
        message.paymentAddress !== undefined && (obj.paymentAddress = message.paymentAddress);
        message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);
        message.chargedReadQuota !== undefined && (obj.chargedReadQuota = (message.chargedReadQuota || helpers_1.Long.UZERO).toString());
        message.billingInfo !== undefined && (obj.billingInfo = message.billingInfo ? exports.BillingInfo.toJSON(message.billingInfo) : undefined);
        message.bucketStatus !== undefined && (obj.bucketStatus = (0, common_1.bucketStatusToJSON)(message.bucketStatus));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBucketInfo();
        message.owner = object.owner ?? "";
        message.bucketName = object.bucketName ?? "";
        message.visibility = object.visibility ?? 0;
        message.id = object.id ?? "";
        message.sourceType = object.sourceType ?? 0;
        message.createAt = object.createAt !== undefined && object.createAt !== null ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO;
        message.paymentAddress = object.paymentAddress ?? "";
        message.primarySpAddress = object.primarySpAddress ?? "";
        message.chargedReadQuota = object.chargedReadQuota !== undefined && object.chargedReadQuota !== null ? helpers_1.Long.fromValue(object.chargedReadQuota) : helpers_1.Long.UZERO;
        message.billingInfo = object.billingInfo !== undefined && object.billingInfo !== null ? exports.BillingInfo.fromPartial(object.billingInfo) : undefined;
        message.bucketStatus = object.bucketStatus ?? 0;
        return message;
    },
    fromSDK(object) {
        return {
            owner: object?.owner,
            bucketName: object?.bucket_name,
            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
            id: object?.id,
            sourceType: (0, helpers_1.isSet)(object.source_type) ? (0, common_1.sourceTypeFromJSON)(object.source_type) : 0,
            createAt: object?.create_at,
            paymentAddress: object?.payment_address,
            primarySpAddress: object?.primary_sp_address,
            chargedReadQuota: object?.charged_read_quota,
            billingInfo: object.billing_info ? exports.BillingInfo.fromSDK(object.billing_info) : undefined,
            bucketStatus: (0, helpers_1.isSet)(object.bucket_status) ? (0, common_1.bucketStatusFromJSON)(object.bucket_status) : 0
        };
    },
    toSDK(message) {
        const obj = {};
        obj.owner = message.owner;
        obj.bucket_name = message.bucketName;
        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
        obj.id = message.id;
        message.sourceType !== undefined && (obj.source_type = (0, common_1.sourceTypeToJSON)(message.sourceType));
        obj.create_at = message.createAt;
        obj.payment_address = message.paymentAddress;
        obj.primary_sp_address = message.primarySpAddress;
        obj.charged_read_quota = message.chargedReadQuota;
        message.billingInfo !== undefined && (obj.billing_info = message.billingInfo ? exports.BillingInfo.toSDK(message.billingInfo) : undefined);
        message.bucketStatus !== undefined && (obj.bucket_status = (0, common_1.bucketStatusToJSON)(message.bucketStatus));
        return obj;
    }
};
function createBaseBillingInfo() {
    return {
        priceTime: helpers_1.Long.ZERO,
        totalChargeSize: helpers_1.Long.UZERO,
        secondarySpObjectsSize: []
    };
}
exports.BillingInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (!message.priceTime.isZero()) {
            writer.uint32(8).int64(message.priceTime);
        }
        if (!message.totalChargeSize.isZero()) {
            writer.uint32(16).uint64(message.totalChargeSize);
        }
        for (const v of message.secondarySpObjectsSize) {
            exports.SecondarySpObjectsSize.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBillingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.priceTime = reader.int64();
                    break;
                case 2:
                    message.totalChargeSize = reader.uint64();
                    break;
                case 3:
                    message.secondarySpObjectsSize.push(exports.SecondarySpObjectsSize.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            priceTime: (0, helpers_1.isSet)(object.priceTime) ? helpers_1.Long.fromValue(object.priceTime) : helpers_1.Long.ZERO,
            totalChargeSize: (0, helpers_1.isSet)(object.totalChargeSize) ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO,
            secondarySpObjectsSize: Array.isArray(object?.secondarySpObjectsSize) ? object.secondarySpObjectsSize.map((e) => exports.SecondarySpObjectsSize.fromJSON(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        message.priceTime !== undefined && (obj.priceTime = (message.priceTime || helpers_1.Long.ZERO).toString());
        message.totalChargeSize !== undefined && (obj.totalChargeSize = (message.totalChargeSize || helpers_1.Long.UZERO).toString());
        if (message.secondarySpObjectsSize) {
            obj.secondarySpObjectsSize = message.secondarySpObjectsSize.map(e => e ? exports.SecondarySpObjectsSize.toJSON(e) : undefined);
        }
        else {
            obj.secondarySpObjectsSize = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBillingInfo();
        message.priceTime = object.priceTime !== undefined && object.priceTime !== null ? helpers_1.Long.fromValue(object.priceTime) : helpers_1.Long.ZERO;
        message.totalChargeSize = object.totalChargeSize !== undefined && object.totalChargeSize !== null ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO;
        message.secondarySpObjectsSize = object.secondarySpObjectsSize?.map(e => exports.SecondarySpObjectsSize.fromPartial(e)) || [];
        return message;
    },
    fromSDK(object) {
        return {
            priceTime: object?.price_time,
            totalChargeSize: object?.total_charge_size,
            secondarySpObjectsSize: Array.isArray(object?.secondary_sp_objects_size) ? object.secondary_sp_objects_size.map((e) => exports.SecondarySpObjectsSize.fromSDK(e)) : []
        };
    },
    toSDK(message) {
        const obj = {};
        obj.price_time = message.priceTime;
        obj.total_charge_size = message.totalChargeSize;
        if (message.secondarySpObjectsSize) {
            obj.secondary_sp_objects_size = message.secondarySpObjectsSize.map(e => e ? exports.SecondarySpObjectsSize.toSDK(e) : undefined);
        }
        else {
            obj.secondary_sp_objects_size = [];
        }
        return obj;
    }
};
function createBaseSecondarySpObjectsSize() {
    return {
        spAddress: "",
        totalChargeSize: helpers_1.Long.UZERO
    };
}
exports.SecondarySpObjectsSize = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.spAddress !== "") {
            writer.uint32(10).string(message.spAddress);
        }
        if (!message.totalChargeSize.isZero()) {
            writer.uint32(16).uint64(message.totalChargeSize);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecondarySpObjectsSize();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spAddress = reader.string();
                    break;
                case 2:
                    message.totalChargeSize = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            spAddress: (0, helpers_1.isSet)(object.spAddress) ? String(object.spAddress) : "",
            totalChargeSize: (0, helpers_1.isSet)(object.totalChargeSize) ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO
        };
    },
    toJSON(message) {
        const obj = {};
        message.spAddress !== undefined && (obj.spAddress = message.spAddress);
        message.totalChargeSize !== undefined && (obj.totalChargeSize = (message.totalChargeSize || helpers_1.Long.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSecondarySpObjectsSize();
        message.spAddress = object.spAddress ?? "";
        message.totalChargeSize = object.totalChargeSize !== undefined && object.totalChargeSize !== null ? helpers_1.Long.fromValue(object.totalChargeSize) : helpers_1.Long.UZERO;
        return message;
    },
    fromSDK(object) {
        return {
            spAddress: object?.sp_address,
            totalChargeSize: object?.total_charge_size
        };
    },
    toSDK(message) {
        const obj = {};
        obj.sp_address = message.spAddress;
        obj.total_charge_size = message.totalChargeSize;
        return obj;
    }
};
function createBaseObjectInfo() {
    return {
        owner: "",
        bucketName: "",
        objectName: "",
        id: "",
        payloadSize: helpers_1.Long.UZERO,
        visibility: 0,
        contentType: "",
        createAt: helpers_1.Long.ZERO,
        objectStatus: 0,
        redundancyType: 0,
        sourceType: 0,
        checksums: [],
        secondarySpAddresses: []
    };
}
exports.ObjectInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        if (message.bucketName !== "") {
            writer.uint32(18).string(message.bucketName);
        }
        if (message.objectName !== "") {
            writer.uint32(26).string(message.objectName);
        }
        if (message.id !== "") {
            writer.uint32(34).string(message.id);
        }
        if (!message.payloadSize.isZero()) {
            writer.uint32(40).uint64(message.payloadSize);
        }
        if (message.visibility !== 0) {
            writer.uint32(48).int32(message.visibility);
        }
        if (message.contentType !== "") {
            writer.uint32(58).string(message.contentType);
        }
        if (!message.createAt.isZero()) {
            writer.uint32(64).int64(message.createAt);
        }
        if (message.objectStatus !== 0) {
            writer.uint32(72).int32(message.objectStatus);
        }
        if (message.redundancyType !== 0) {
            writer.uint32(80).int32(message.redundancyType);
        }
        if (message.sourceType !== 0) {
            writer.uint32(88).int32(message.sourceType);
        }
        for (const v of message.checksums) {
            writer.uint32(98).bytes(v);
        }
        for (const v of message.secondarySpAddresses) {
            writer.uint32(106).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseObjectInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.bucketName = reader.string();
                    break;
                case 3:
                    message.objectName = reader.string();
                    break;
                case 4:
                    message.id = reader.string();
                    break;
                case 5:
                    message.payloadSize = reader.uint64();
                    break;
                case 6:
                    message.visibility = reader.int32();
                    break;
                case 7:
                    message.contentType = reader.string();
                    break;
                case 8:
                    message.createAt = reader.int64();
                    break;
                case 9:
                    message.objectStatus = reader.int32();
                    break;
                case 10:
                    message.redundancyType = reader.int32();
                    break;
                case 11:
                    message.sourceType = reader.int32();
                    break;
                case 12:
                    message.checksums.push(reader.bytes());
                    break;
                case 13:
                    message.secondarySpAddresses.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : "",
            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : "",
            payloadSize: (0, helpers_1.isSet)(object.payloadSize) ? helpers_1.Long.fromValue(object.payloadSize) : helpers_1.Long.UZERO,
            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
            contentType: (0, helpers_1.isSet)(object.contentType) ? String(object.contentType) : "",
            createAt: (0, helpers_1.isSet)(object.createAt) ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO,
            objectStatus: (0, helpers_1.isSet)(object.objectStatus) ? (0, common_1.objectStatusFromJSON)(object.objectStatus) : 0,
            redundancyType: (0, helpers_1.isSet)(object.redundancyType) ? (0, common_1.redundancyTypeFromJSON)(object.redundancyType) : 0,
            sourceType: (0, helpers_1.isSet)(object.sourceType) ? (0, common_1.sourceTypeFromJSON)(object.sourceType) : 0,
            checksums: Array.isArray(object?.checksums) ? object.checksums.map((e) => (0, helpers_1.bytesFromBase64)(e)) : [],
            secondarySpAddresses: Array.isArray(object?.secondarySpAddresses) ? object.secondarySpAddresses.map((e) => String(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        message.owner !== undefined && (obj.owner = message.owner);
        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
        message.objectName !== undefined && (obj.objectName = message.objectName);
        message.id !== undefined && (obj.id = message.id);
        message.payloadSize !== undefined && (obj.payloadSize = (message.payloadSize || helpers_1.Long.UZERO).toString());
        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
        message.contentType !== undefined && (obj.contentType = message.contentType);
        message.createAt !== undefined && (obj.createAt = (message.createAt || helpers_1.Long.ZERO).toString());
        message.objectStatus !== undefined && (obj.objectStatus = (0, common_1.objectStatusToJSON)(message.objectStatus));
        message.redundancyType !== undefined && (obj.redundancyType = (0, common_1.redundancyTypeToJSON)(message.redundancyType));
        message.sourceType !== undefined && (obj.sourceType = (0, common_1.sourceTypeToJSON)(message.sourceType));
        if (message.checksums) {
            obj.checksums = message.checksums.map(e => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.checksums = [];
        }
        if (message.secondarySpAddresses) {
            obj.secondarySpAddresses = message.secondarySpAddresses.map(e => e);
        }
        else {
            obj.secondarySpAddresses = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseObjectInfo();
        message.owner = object.owner ?? "";
        message.bucketName = object.bucketName ?? "";
        message.objectName = object.objectName ?? "";
        message.id = object.id ?? "";
        message.payloadSize = object.payloadSize !== undefined && object.payloadSize !== null ? helpers_1.Long.fromValue(object.payloadSize) : helpers_1.Long.UZERO;
        message.visibility = object.visibility ?? 0;
        message.contentType = object.contentType ?? "";
        message.createAt = object.createAt !== undefined && object.createAt !== null ? helpers_1.Long.fromValue(object.createAt) : helpers_1.Long.ZERO;
        message.objectStatus = object.objectStatus ?? 0;
        message.redundancyType = object.redundancyType ?? 0;
        message.sourceType = object.sourceType ?? 0;
        message.checksums = object.checksums?.map(e => e) || [];
        message.secondarySpAddresses = object.secondarySpAddresses?.map(e => e) || [];
        return message;
    },
    fromSDK(object) {
        return {
            owner: object?.owner,
            bucketName: object?.bucket_name,
            objectName: object?.object_name,
            id: object?.id,
            payloadSize: object?.payload_size,
            visibility: (0, helpers_1.isSet)(object.visibility) ? (0, common_1.visibilityTypeFromJSON)(object.visibility) : 0,
            contentType: object?.content_type,
            createAt: object?.create_at,
            objectStatus: (0, helpers_1.isSet)(object.object_status) ? (0, common_1.objectStatusFromJSON)(object.object_status) : 0,
            redundancyType: (0, helpers_1.isSet)(object.redundancy_type) ? (0, common_1.redundancyTypeFromJSON)(object.redundancy_type) : 0,
            sourceType: (0, helpers_1.isSet)(object.source_type) ? (0, common_1.sourceTypeFromJSON)(object.source_type) : 0,
            checksums: Array.isArray(object?.checksums) ? object.checksums.map((e) => e) : [],
            secondarySpAddresses: Array.isArray(object?.secondary_sp_addresses) ? object.secondary_sp_addresses.map((e) => e) : []
        };
    },
    toSDK(message) {
        const obj = {};
        obj.owner = message.owner;
        obj.bucket_name = message.bucketName;
        obj.object_name = message.objectName;
        obj.id = message.id;
        obj.payload_size = message.payloadSize;
        message.visibility !== undefined && (obj.visibility = (0, common_1.visibilityTypeToJSON)(message.visibility));
        obj.content_type = message.contentType;
        obj.create_at = message.createAt;
        message.objectStatus !== undefined && (obj.object_status = (0, common_1.objectStatusToJSON)(message.objectStatus));
        message.redundancyType !== undefined && (obj.redundancy_type = (0, common_1.redundancyTypeToJSON)(message.redundancyType));
        message.sourceType !== undefined && (obj.source_type = (0, common_1.sourceTypeToJSON)(message.sourceType));
        if (message.checksums) {
            obj.checksums = message.checksums.map(e => e);
        }
        else {
            obj.checksums = [];
        }
        if (message.secondarySpAddresses) {
            obj.secondary_sp_addresses = message.secondarySpAddresses.map(e => e);
        }
        else {
            obj.secondary_sp_addresses = [];
        }
        return obj;
    }
};
function createBaseGroupInfo() {
    return {
        owner: "",
        groupName: "",
        sourceType: 0,
        id: ""
    };
}
exports.GroupInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        if (message.groupName !== "") {
            writer.uint32(18).string(message.groupName);
        }
        if (message.sourceType !== 0) {
            writer.uint32(24).int32(message.sourceType);
        }
        if (message.id !== "") {
            writer.uint32(34).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.groupName = reader.string();
                    break;
                case 3:
                    message.sourceType = reader.int32();
                    break;
                case 4:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            owner: (0, helpers_1.isSet)(object.owner) ? String(object.owner) : "",
            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : "",
            sourceType: (0, helpers_1.isSet)(object.sourceType) ? (0, common_1.sourceTypeFromJSON)(object.sourceType) : 0,
            id: (0, helpers_1.isSet)(object.id) ? String(object.id) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.owner !== undefined && (obj.owner = message.owner);
        message.groupName !== undefined && (obj.groupName = message.groupName);
        message.sourceType !== undefined && (obj.sourceType = (0, common_1.sourceTypeToJSON)(message.sourceType));
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGroupInfo();
        message.owner = object.owner ?? "";
        message.groupName = object.groupName ?? "";
        message.sourceType = object.sourceType ?? 0;
        message.id = object.id ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            owner: object?.owner,
            groupName: object?.group_name,
            sourceType: (0, helpers_1.isSet)(object.source_type) ? (0, common_1.sourceTypeFromJSON)(object.source_type) : 0,
            id: object?.id
        };
    },
    toSDK(message) {
        const obj = {};
        obj.owner = message.owner;
        obj.group_name = message.groupName;
        message.sourceType !== undefined && (obj.source_type = (0, common_1.sourceTypeToJSON)(message.sourceType));
        obj.id = message.id;
        return obj;
    }
};
function createBaseTrait() {
    return {
        traitType: "",
        value: ""
    };
}
exports.Trait = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.traitType !== "") {
            writer.uint32(10).string(message.traitType);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrait();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.traitType = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            traitType: (0, helpers_1.isSet)(object.traitType) ? String(object.traitType) : "",
            value: (0, helpers_1.isSet)(object.value) ? String(object.value) : ""
        };
    },
    toJSON(message) {
        const obj = {};
        message.traitType !== undefined && (obj.traitType = message.traitType);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTrait();
        message.traitType = object.traitType ?? "";
        message.value = object.value ?? "";
        return message;
    },
    fromSDK(object) {
        return {
            traitType: object?.trait_type,
            value: object?.value
        };
    },
    toSDK(message) {
        const obj = {};
        obj.trait_type = message.traitType;
        obj.value = message.value;
        return obj;
    }
};
function createBaseBucketMetaData() {
    return {
        description: "",
        externalUrl: "",
        bucketName: "",
        image: "",
        attributes: []
    };
}
exports.BucketMetaData = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.externalUrl !== "") {
            writer.uint32(18).string(message.externalUrl);
        }
        if (message.bucketName !== "") {
            writer.uint32(26).string(message.bucketName);
        }
        if (message.image !== "") {
            writer.uint32(34).string(message.image);
        }
        for (const v of message.attributes) {
            exports.Trait.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBucketMetaData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.externalUrl = reader.string();
                    break;
                case 3:
                    message.bucketName = reader.string();
                    break;
                case 4:
                    message.image = reader.string();
                    break;
                case 5:
                    message.attributes.push(exports.Trait.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
            externalUrl: (0, helpers_1.isSet)(object.externalUrl) ? String(object.externalUrl) : "",
            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
            image: (0, helpers_1.isSet)(object.image) ? String(object.image) : "",
            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromJSON(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        message.description !== undefined && (obj.description = message.description);
        message.externalUrl !== undefined && (obj.externalUrl = message.externalUrl);
        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
        message.image !== undefined && (obj.image = message.image);
        if (message.attributes) {
            obj.attributes = message.attributes.map(e => e ? exports.Trait.toJSON(e) : undefined);
        }
        else {
            obj.attributes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBucketMetaData();
        message.description = object.description ?? "";
        message.externalUrl = object.externalUrl ?? "";
        message.bucketName = object.bucketName ?? "";
        message.image = object.image ?? "";
        message.attributes = object.attributes?.map(e => exports.Trait.fromPartial(e)) || [];
        return message;
    },
    fromSDK(object) {
        return {
            description: object?.description,
            externalUrl: object?.external_url,
            bucketName: object?.bucket_name,
            image: object?.image,
            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromSDK(e)) : []
        };
    },
    toSDK(message) {
        const obj = {};
        obj.description = message.description;
        obj.external_url = message.externalUrl;
        obj.bucket_name = message.bucketName;
        obj.image = message.image;
        if (message.attributes) {
            obj.attributes = message.attributes.map(e => e ? exports.Trait.toSDK(e) : undefined);
        }
        else {
            obj.attributes = [];
        }
        return obj;
    }
};
function createBaseObjectMetaData() {
    return {
        description: "",
        externalUrl: "",
        objectName: "",
        image: "",
        attributes: []
    };
}
exports.ObjectMetaData = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.externalUrl !== "") {
            writer.uint32(18).string(message.externalUrl);
        }
        if (message.objectName !== "") {
            writer.uint32(26).string(message.objectName);
        }
        if (message.image !== "") {
            writer.uint32(34).string(message.image);
        }
        for (const v of message.attributes) {
            exports.Trait.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseObjectMetaData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.externalUrl = reader.string();
                    break;
                case 3:
                    message.objectName = reader.string();
                    break;
                case 4:
                    message.image = reader.string();
                    break;
                case 5:
                    message.attributes.push(exports.Trait.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
            externalUrl: (0, helpers_1.isSet)(object.externalUrl) ? String(object.externalUrl) : "",
            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
            image: (0, helpers_1.isSet)(object.image) ? String(object.image) : "",
            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromJSON(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        message.description !== undefined && (obj.description = message.description);
        message.externalUrl !== undefined && (obj.externalUrl = message.externalUrl);
        message.objectName !== undefined && (obj.objectName = message.objectName);
        message.image !== undefined && (obj.image = message.image);
        if (message.attributes) {
            obj.attributes = message.attributes.map(e => e ? exports.Trait.toJSON(e) : undefined);
        }
        else {
            obj.attributes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseObjectMetaData();
        message.description = object.description ?? "";
        message.externalUrl = object.externalUrl ?? "";
        message.objectName = object.objectName ?? "";
        message.image = object.image ?? "";
        message.attributes = object.attributes?.map(e => exports.Trait.fromPartial(e)) || [];
        return message;
    },
    fromSDK(object) {
        return {
            description: object?.description,
            externalUrl: object?.external_url,
            objectName: object?.object_name,
            image: object?.image,
            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromSDK(e)) : []
        };
    },
    toSDK(message) {
        const obj = {};
        obj.description = message.description;
        obj.external_url = message.externalUrl;
        obj.object_name = message.objectName;
        obj.image = message.image;
        if (message.attributes) {
            obj.attributes = message.attributes.map(e => e ? exports.Trait.toSDK(e) : undefined);
        }
        else {
            obj.attributes = [];
        }
        return obj;
    }
};
function createBaseGroupMetaData() {
    return {
        description: "",
        externalUrl: "",
        groupName: "",
        image: "",
        attributes: []
    };
}
exports.GroupMetaData = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.externalUrl !== "") {
            writer.uint32(18).string(message.externalUrl);
        }
        if (message.groupName !== "") {
            writer.uint32(26).string(message.groupName);
        }
        if (message.image !== "") {
            writer.uint32(34).string(message.image);
        }
        for (const v of message.attributes) {
            exports.Trait.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMetaData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.externalUrl = reader.string();
                    break;
                case 3:
                    message.groupName = reader.string();
                    break;
                case 4:
                    message.image = reader.string();
                    break;
                case 5:
                    message.attributes.push(exports.Trait.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: (0, helpers_1.isSet)(object.description) ? String(object.description) : "",
            externalUrl: (0, helpers_1.isSet)(object.externalUrl) ? String(object.externalUrl) : "",
            groupName: (0, helpers_1.isSet)(object.groupName) ? String(object.groupName) : "",
            image: (0, helpers_1.isSet)(object.image) ? String(object.image) : "",
            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromJSON(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        message.description !== undefined && (obj.description = message.description);
        message.externalUrl !== undefined && (obj.externalUrl = message.externalUrl);
        message.groupName !== undefined && (obj.groupName = message.groupName);
        message.image !== undefined && (obj.image = message.image);
        if (message.attributes) {
            obj.attributes = message.attributes.map(e => e ? exports.Trait.toJSON(e) : undefined);
        }
        else {
            obj.attributes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGroupMetaData();
        message.description = object.description ?? "";
        message.externalUrl = object.externalUrl ?? "";
        message.groupName = object.groupName ?? "";
        message.image = object.image ?? "";
        message.attributes = object.attributes?.map(e => exports.Trait.fromPartial(e)) || [];
        return message;
    },
    fromSDK(object) {
        return {
            description: object?.description,
            externalUrl: object?.external_url,
            groupName: object?.group_name,
            image: object?.image,
            attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => exports.Trait.fromSDK(e)) : []
        };
    },
    toSDK(message) {
        const obj = {};
        obj.description = message.description;
        obj.external_url = message.externalUrl;
        obj.group_name = message.groupName;
        obj.image = message.image;
        if (message.attributes) {
            obj.attributes = message.attributes.map(e => e ? exports.Trait.toSDK(e) : undefined);
        }
        else {
            obj.attributes = [];
        }
        return obj;
    }
};
function createBaseIds() {
    return {
        id: []
    };
}
exports.Ids = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: Array.isArray(object?.id) ? object.id.map((e) => String(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id) {
            obj.id = message.id.map(e => e);
        }
        else {
            obj.id = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseIds();
        message.id = object.id?.map(e => e) || [];
        return message;
    },
    fromSDK(object) {
        return {
            id: Array.isArray(object?.id) ? object.id.map((e) => e) : []
        };
    },
    toSDK(message) {
        const obj = {};
        if (message.id) {
            obj.id = message.id.map(e => e);
        }
        else {
            obj.id = [];
        }
        return obj;
    }
};
function createBaseDeleteInfo() {
    return {
        bucketIds: undefined,
        objectIds: undefined,
        groupIds: undefined
    };
}
exports.DeleteInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.bucketIds !== undefined) {
            exports.Ids.encode(message.bucketIds, writer.uint32(10).fork()).ldelim();
        }
        if (message.objectIds !== undefined) {
            exports.Ids.encode(message.objectIds, writer.uint32(18).fork()).ldelim();
        }
        if (message.groupIds !== undefined) {
            exports.Ids.encode(message.groupIds, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bucketIds = exports.Ids.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.objectIds = exports.Ids.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.groupIds = exports.Ids.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bucketIds: (0, helpers_1.isSet)(object.bucketIds) ? exports.Ids.fromJSON(object.bucketIds) : undefined,
            objectIds: (0, helpers_1.isSet)(object.objectIds) ? exports.Ids.fromJSON(object.objectIds) : undefined,
            groupIds: (0, helpers_1.isSet)(object.groupIds) ? exports.Ids.fromJSON(object.groupIds) : undefined
        };
    },
    toJSON(message) {
        const obj = {};
        message.bucketIds !== undefined && (obj.bucketIds = message.bucketIds ? exports.Ids.toJSON(message.bucketIds) : undefined);
        message.objectIds !== undefined && (obj.objectIds = message.objectIds ? exports.Ids.toJSON(message.objectIds) : undefined);
        message.groupIds !== undefined && (obj.groupIds = message.groupIds ? exports.Ids.toJSON(message.groupIds) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteInfo();
        message.bucketIds = object.bucketIds !== undefined && object.bucketIds !== null ? exports.Ids.fromPartial(object.bucketIds) : undefined;
        message.objectIds = object.objectIds !== undefined && object.objectIds !== null ? exports.Ids.fromPartial(object.objectIds) : undefined;
        message.groupIds = object.groupIds !== undefined && object.groupIds !== null ? exports.Ids.fromPartial(object.groupIds) : undefined;
        return message;
    },
    fromSDK(object) {
        return {
            bucketIds: object.bucket_ids ? exports.Ids.fromSDK(object.bucket_ids) : undefined,
            objectIds: object.object_ids ? exports.Ids.fromSDK(object.object_ids) : undefined,
            groupIds: object.group_ids ? exports.Ids.fromSDK(object.group_ids) : undefined
        };
    },
    toSDK(message) {
        const obj = {};
        message.bucketIds !== undefined && (obj.bucket_ids = message.bucketIds ? exports.Ids.toSDK(message.bucketIds) : undefined);
        message.objectIds !== undefined && (obj.object_ids = message.objectIds ? exports.Ids.toSDK(message.objectIds) : undefined);
        message.groupIds !== undefined && (obj.group_ids = message.groupIds ? exports.Ids.toSDK(message.groupIds) : undefined);
        return obj;
    }
};
//# sourceMappingURL=types.js.map