"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgAttestResponse = exports.MsgAttest = exports.MsgSubmitResponse = exports.MsgSubmit = exports.protobufPackage = void 0;
/* eslint-disable */
const types_1 = require("./types");
const params_1 = require("./params");
const _m0 = __importStar(require("protobufjs/minimal"));
const helpers_1 = require("../../helpers");
exports.protobufPackage = "greenfield.challenge";
function createBaseMsgSubmit() {
    return {
        challenger: "",
        spOperatorAddress: "",
        bucketName: "",
        objectName: "",
        segmentIndex: 0,
        randomIndex: false
    };
}
exports.MsgSubmit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.challenger !== "") {
            writer.uint32(10).string(message.challenger);
        }
        if (message.spOperatorAddress !== "") {
            writer.uint32(18).string(message.spOperatorAddress);
        }
        if (message.bucketName !== "") {
            writer.uint32(26).string(message.bucketName);
        }
        if (message.objectName !== "") {
            writer.uint32(34).string(message.objectName);
        }
        if (message.segmentIndex !== 0) {
            writer.uint32(40).uint32(message.segmentIndex);
        }
        if (message.randomIndex === true) {
            writer.uint32(48).bool(message.randomIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.challenger = reader.string();
                    break;
                case 2:
                    message.spOperatorAddress = reader.string();
                    break;
                case 3:
                    message.bucketName = reader.string();
                    break;
                case 4:
                    message.objectName = reader.string();
                    break;
                case 5:
                    message.segmentIndex = reader.uint32();
                    break;
                case 6:
                    message.randomIndex = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            challenger: (0, helpers_1.isSet)(object.challenger) ? String(object.challenger) : "",
            spOperatorAddress: (0, helpers_1.isSet)(object.spOperatorAddress) ? String(object.spOperatorAddress) : "",
            bucketName: (0, helpers_1.isSet)(object.bucketName) ? String(object.bucketName) : "",
            objectName: (0, helpers_1.isSet)(object.objectName) ? String(object.objectName) : "",
            segmentIndex: (0, helpers_1.isSet)(object.segmentIndex) ? Number(object.segmentIndex) : 0,
            randomIndex: (0, helpers_1.isSet)(object.randomIndex) ? Boolean(object.randomIndex) : false
        };
    },
    toJSON(message) {
        const obj = {};
        message.challenger !== undefined && (obj.challenger = message.challenger);
        message.spOperatorAddress !== undefined && (obj.spOperatorAddress = message.spOperatorAddress);
        message.bucketName !== undefined && (obj.bucketName = message.bucketName);
        message.objectName !== undefined && (obj.objectName = message.objectName);
        message.segmentIndex !== undefined && (obj.segmentIndex = Math.round(message.segmentIndex));
        message.randomIndex !== undefined && (obj.randomIndex = message.randomIndex);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMsgSubmit();
        message.challenger = object.challenger ?? "";
        message.spOperatorAddress = object.spOperatorAddress ?? "";
        message.bucketName = object.bucketName ?? "";
        message.objectName = object.objectName ?? "";
        message.segmentIndex = object.segmentIndex ?? 0;
        message.randomIndex = object.randomIndex ?? false;
        return message;
    },
    fromSDK(object) {
        return {
            challenger: object?.challenger,
            spOperatorAddress: object?.sp_operator_address,
            bucketName: object?.bucket_name,
            objectName: object?.object_name,
            segmentIndex: object?.segment_index,
            randomIndex: object?.random_index
        };
    },
    toSDK(message) {
        const obj = {};
        obj.challenger = message.challenger;
        obj.sp_operator_address = message.spOperatorAddress;
        obj.bucket_name = message.bucketName;
        obj.object_name = message.objectName;
        obj.segment_index = message.segmentIndex;
        obj.random_index = message.randomIndex;
        return obj;
    }
};
function createBaseMsgSubmitResponse() {
    return {};
}
exports.MsgSubmitResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgSubmitResponse();
        return message;
    },
    fromSDK(_) {
        return {};
    },
    toSDK(_) {
        const obj = {};
        return obj;
    }
};
function createBaseMsgAttest() {
    return {
        submitter: "",
        challengeId: helpers_1.Long.UZERO,
        objectId: "",
        spOperatorAddress: "",
        voteResult: 0,
        challengerAddress: "",
        voteValidatorSet: [],
        voteAggSignature: new Uint8Array()
    };
}
exports.MsgAttest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.submitter !== "") {
            writer.uint32(10).string(message.submitter);
        }
        if (!message.challengeId.isZero()) {
            writer.uint32(16).uint64(message.challengeId);
        }
        if (message.objectId !== "") {
            writer.uint32(26).string(message.objectId);
        }
        if (message.spOperatorAddress !== "") {
            writer.uint32(34).string(message.spOperatorAddress);
        }
        if (message.voteResult !== 0) {
            writer.uint32(40).int32(message.voteResult);
        }
        if (message.challengerAddress !== "") {
            writer.uint32(50).string(message.challengerAddress);
        }
        writer.uint32(58).fork();
        for (const v of message.voteValidatorSet) {
            writer.fixed64(v);
        }
        writer.ldelim();
        if (message.voteAggSignature.length !== 0) {
            writer.uint32(66).bytes(message.voteAggSignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAttest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.submitter = reader.string();
                    break;
                case 2:
                    message.challengeId = reader.uint64();
                    break;
                case 3:
                    message.objectId = reader.string();
                    break;
                case 4:
                    message.spOperatorAddress = reader.string();
                    break;
                case 5:
                    message.voteResult = reader.int32();
                    break;
                case 6:
                    message.challengerAddress = reader.string();
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.voteValidatorSet.push(reader.fixed64());
                        }
                    }
                    else {
                        message.voteValidatorSet.push(reader.fixed64());
                    }
                    break;
                case 8:
                    message.voteAggSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            submitter: (0, helpers_1.isSet)(object.submitter) ? String(object.submitter) : "",
            challengeId: (0, helpers_1.isSet)(object.challengeId) ? helpers_1.Long.fromValue(object.challengeId) : helpers_1.Long.UZERO,
            objectId: (0, helpers_1.isSet)(object.objectId) ? String(object.objectId) : "",
            spOperatorAddress: (0, helpers_1.isSet)(object.spOperatorAddress) ? String(object.spOperatorAddress) : "",
            voteResult: (0, helpers_1.isSet)(object.voteResult) ? (0, types_1.voteResultFromJSON)(object.voteResult) : 0,
            challengerAddress: (0, helpers_1.isSet)(object.challengerAddress) ? String(object.challengerAddress) : "",
            voteValidatorSet: Array.isArray(object?.voteValidatorSet) ? object.voteValidatorSet.map((e) => helpers_1.Long.fromValue(e)) : [],
            voteAggSignature: (0, helpers_1.isSet)(object.voteAggSignature) ? (0, helpers_1.bytesFromBase64)(object.voteAggSignature) : new Uint8Array()
        };
    },
    toJSON(message) {
        const obj = {};
        message.submitter !== undefined && (obj.submitter = message.submitter);
        message.challengeId !== undefined && (obj.challengeId = (message.challengeId || helpers_1.Long.UZERO).toString());
        message.objectId !== undefined && (obj.objectId = message.objectId);
        message.spOperatorAddress !== undefined && (obj.spOperatorAddress = message.spOperatorAddress);
        message.voteResult !== undefined && (obj.voteResult = (0, types_1.voteResultToJSON)(message.voteResult));
        message.challengerAddress !== undefined && (obj.challengerAddress = message.challengerAddress);
        if (message.voteValidatorSet) {
            obj.voteValidatorSet = message.voteValidatorSet.map(e => (e || helpers_1.Long.ZERO).toString());
        }
        else {
            obj.voteValidatorSet = [];
        }
        message.voteAggSignature !== undefined && (obj.voteAggSignature = (0, helpers_1.base64FromBytes)(message.voteAggSignature !== undefined ? message.voteAggSignature : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMsgAttest();
        message.submitter = object.submitter ?? "";
        message.challengeId = object.challengeId !== undefined && object.challengeId !== null ? helpers_1.Long.fromValue(object.challengeId) : helpers_1.Long.UZERO;
        message.objectId = object.objectId ?? "";
        message.spOperatorAddress = object.spOperatorAddress ?? "";
        message.voteResult = object.voteResult ?? 0;
        message.challengerAddress = object.challengerAddress ?? "";
        message.voteValidatorSet = object.voteValidatorSet?.map(e => helpers_1.Long.fromValue(e)) || [];
        message.voteAggSignature = object.voteAggSignature ?? new Uint8Array();
        return message;
    },
    fromSDK(object) {
        return {
            submitter: object?.submitter,
            challengeId: object?.challenge_id,
            objectId: object?.object_id,
            spOperatorAddress: object?.sp_operator_address,
            voteResult: (0, helpers_1.isSet)(object.vote_result) ? (0, types_1.voteResultFromJSON)(object.vote_result) : 0,
            challengerAddress: object?.challenger_address,
            voteValidatorSet: Array.isArray(object?.vote_validator_set) ? object.vote_validator_set.map((e) => e) : [],
            voteAggSignature: object?.vote_agg_signature
        };
    },
    toSDK(message) {
        const obj = {};
        obj.submitter = message.submitter;
        obj.challenge_id = message.challengeId;
        obj.object_id = message.objectId;
        obj.sp_operator_address = message.spOperatorAddress;
        message.voteResult !== undefined && (obj.vote_result = (0, types_1.voteResultToJSON)(message.voteResult));
        obj.challenger_address = message.challengerAddress;
        if (message.voteValidatorSet) {
            obj.vote_validator_set = message.voteValidatorSet.map(e => e);
        }
        else {
            obj.vote_validator_set = [];
        }
        obj.vote_agg_signature = message.voteAggSignature;
        return obj;
    }
};
function createBaseMsgAttestResponse() {
    return {};
}
exports.MsgAttestResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAttestResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgAttestResponse();
        return message;
    },
    fromSDK(_) {
        return {};
    },
    toSDK(_) {
        const obj = {};
        return obj;
    }
};
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: undefined
    };
}
exports.MsgUpdateParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.authority !== "") {
            writer.uint32(10).string(message.authority);
        }
        if (message.params !== undefined) {
            params_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = params_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            authority: (0, helpers_1.isSet)(object.authority) ? String(object.authority) : "",
            params: (0, helpers_1.isSet)(object.params) ? params_1.Params.fromJSON(object.params) : undefined
        };
    },
    toJSON(message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.params !== undefined && (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
        return message;
    },
    fromSDK(object) {
        return {
            authority: object?.authority,
            params: object.params ? params_1.Params.fromSDK(object.params) : undefined
        };
    },
    toSDK(message) {
        const obj = {};
        obj.authority = message.authority;
        message.params !== undefined && (obj.params = message.params ? params_1.Params.toSDK(message.params) : undefined);
        return obj;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    },
    fromSDK(_) {
        return {};
    },
    toSDK(_) {
        const obj = {};
        return obj;
    }
};
class MsgClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.Submit = this.Submit.bind(this);
        this.Attest = this.Attest.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
    }
    Submit(request) {
        const data = exports.MsgSubmit.encode(request).finish();
        const promise = this.rpc.request("greenfield.challenge.Msg", "Submit", data);
        return promise.then(data => exports.MsgSubmitResponse.decode(new _m0.Reader(data)));
    }
    Attest(request) {
        const data = exports.MsgAttest.encode(request).finish();
        const promise = this.rpc.request("greenfield.challenge.Msg", "Attest", data);
        return promise.then(data => exports.MsgAttestResponse.decode(new _m0.Reader(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("greenfield.challenge.Msg", "UpdateParams", data);
        return promise.then(data => exports.MsgUpdateParamsResponse.decode(new _m0.Reader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
//# sourceMappingURL=tx.js.map